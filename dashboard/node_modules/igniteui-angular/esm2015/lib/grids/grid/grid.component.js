/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ChangeDetectionStrategy, Input, Output, EventEmitter, ContentChild, ViewChildren, QueryList, ViewChild, ElementRef, TemplateRef, HostBinding, forwardRef } from '@angular/core';
import { GridBaseAPIService } from '../api.service';
import { IgxGridBaseComponent } from '../grid-base.component';
import { IgxGridNavigationService } from '../grid-navigation.service';
import { IgxGridAPIService } from './grid-api.service';
import { cloneArray } from '../../core/utils';
import { IgxGroupByRowTemplateDirective } from './grid.directives';
import { IgxGridGroupByRowComponent } from './groupby-row.component';
import { takeUntil } from 'rxjs/operators';
import { IgxFilteringService } from '../filtering/grid-filtering.service';
import { IgxColumnResizingService } from '../grid-column-resizing.service';
import { IgxGridSummaryService } from '../summaries/grid-summary.service';
import { IgxGridSelectionService, IgxGridCRUDService } from '../../core/grid-selection';
import { IgxForOfSyncService, IgxForOfScrollSyncService } from '../../directives/for-of/for_of.sync.service';
import { IgxGridMRLNavigationService } from '../grid-mrl-navigation.service';
import { IgxRowIslandAPIService } from '../hierarchical-grid/row-island-api.service';
import { FilterMode } from '../common/enums';
/** @type {?} */
let NEXT_ID = 0;
/**
 * @record
 */
export function IGroupingDoneEventArgs() { }
if (false) {
    /** @type {?} */
    IGroupingDoneEventArgs.prototype.expressions;
    /** @type {?} */
    IGroupingDoneEventArgs.prototype.groupedColumns;
    /** @type {?} */
    IGroupingDoneEventArgs.prototype.ungroupedColumns;
}
/**
 * **Ignite UI for Angular Grid** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/grid.html)
 *
 * The Ignite UI Grid is used for presenting and manipulating tabular data in the simplest way possible.  Once data
 * has been bound, it can be manipulated through filtering, sorting & editing operations.
 *
 * Example:
 * ```html
 * <igx-grid [data]="employeeData" autoGenerate="false">
 *   <igx-column field="first" header="First Name"></igx-column>
 *   <igx-column field="last" header="Last Name"></igx-column>
 *   <igx-column field="role" header="Role"></igx-column>
 * </igx-grid>
 * ```
 */
export class IgxGridComponent extends IgxGridBaseComponent {
    constructor() {
        super(...arguments);
        this._id = `igx-grid-${NEXT_ID++}`;
        /**
         * @hidden
         */
        this._groupingExpressions = [];
        /**
         * @hidden
         */
        this._groupingExpandState = [];
        this._hideGroupedColumns = false;
        this._dropAreaMessage = null;
        this._filteredData = null;
        /**
         * @hidden
         */
        this.groupingExpressionsChange = new EventEmitter();
        /**
         * @hidden
         */
        this.groupingExpansionStateChange = new EventEmitter();
        /**
         * An \@Input property that determines whether created groups are rendered expanded or collapsed.
         * The default rendered state is expanded.
         * ```html
         * <igx-grid #grid [data]="Data" [groupsExpanded]="false" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridComponent
         */
        this.groupsExpanded = true;
        /**
         * A hierarchical representation of the group by records.
         * ```typescript
         * let groupRecords = this.grid.groupsRecords;
         * ```
         * \@memberof IgxGridComponent
         */
        this.groupsRecords = [];
        /**
         * Emitted when a new `IgxColumnComponent` gets grouped/ungrouped, or multiple columns get
         * grouped/ungrouped at once by using the Group By API.
         * The `onGroupingDone` event would be raised only once if several columns get grouped at once by calling
         * the `groupBy()` or `clearGrouping()` API methods and passing an array as an argument.
         * The event arguments provide the `expressions`, `groupedColumns` and `ungroupedColumns` properties, which contain
         * the `ISortingExpression` and the `IgxColumnComponent` related to the grouping/ungrouping operation.
         * Please note that `groupedColumns` and `ungroupedColumns` show only the **newly** changed columns (affected by the **last**
         * grouping/ungrouping operation), not all columns which are currently grouped/ungrouped.
         * columns.
         * ```typescript
         * groupingDone(event: IGroupingDoneEventArgs){
         *     const expressions = event.expressions;
         *     //the newly grouped columns
         *     const groupedColumns = event.groupedColumns;
         *     //the newly ungrouped columns
         *     const ungroupedColumns = event.ungroupedColumns;
         * }
         * ```
         * ```html
         * <igx-grid #grid [data]="localData" (onGroupingDone)="groupingDone($event)" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridComponent
         */
        this.onGroupingDone = new EventEmitter();
    }
    /**
     * An \@Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.
     * ```html
     * <igx-grid [id]="'igx-grid-1'" [data]="Data" [autoGenerate]="true"></igx-grid>
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    get id() {
        return this._id;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set id(value) {
        this._id = value;
    }
    /**
     * An \@Input property that lets you fill the `IgxGridComponent` with an array of data.
     * ```html
     * <igx-grid [data]="Data" [autoGenerate]="true"></igx-grid>
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set data(value) {
        this._data = value || [];
        this.summaryService.clearSummaryCache();
        if (this.shouldGenerate) {
            this.setupColumns();
        }
        this.cdr.markForCheck();
    }
    /**
     * Returns an array of objects containing the filtered data in the `IgxGridComponent`.
     * ```typescript
     * let filteredData = this.grid.filteredData;
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    get filteredData() {
        return this._filteredData;
    }
    /**
     * Sets an array of objects containing the filtered data in the `IgxGridComponent`.
     * ```typescript
     * this.grid.filteredData = [{
     *       ID: 1,
     *       Name: "A"
     * }];
     * ```
     * \@memberof IgxGridComponent
     * @param {?} value
     * @return {?}
     */
    set filteredData(value) {
        this._filteredData = value;
    }
    /**
     * Returns the state of the grid virtualization, including the start index and how many records are rendered.
     * ```typescript
     * const gridVirtState = this.grid1.virtualizationState;
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    get virtualizationState() {
        return this.verticalScrollContainer.state;
    }
    /**
     * @hidden
     * @param {?} state
     * @return {?}
     */
    set virtualizationState(state) {
        this.verticalScrollContainer.state = state;
    }
    /**
     * Sets the total number of records in the data source.
     * This property is required for remote grid virtualization to function when it is bound to remote data.
     * ```typescript
     * this.grid1.totalItemCount = 55;
     * ```
     * \@memberof IgxGridComponent
     * @param {?} count
     * @return {?}
     */
    set totalItemCount(count) {
        this.verticalScrollContainer.totalItemCount = count;
        this.cdr.detectChanges();
    }
    /**
     * Returns the total number of records in the data source.
     * Works only with remote grid virtualization.
     * ```typescript
     * const itemCount = this.grid1.totalItemCount;
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    get totalItemCount() {
        return this.verticalScrollContainer.totalItemCount;
    }
    /**
     * @private
     * @return {?}
     */
    get _gridAPI() {
        return (/** @type {?} */ (this.gridAPI));
    }
    /**
     * Returns the group by state of the `IgxGridComponent`.
     * ```typescript
     * let groupByState = this.grid.groupingExpressions;
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    get groupingExpressions() {
        return this._groupingExpressions;
    }
    /**
     * Sets the group by state of the `IgxGridComponent` and emits the `onGroupingDone`
     * event with the appropriate arguments.
     * ```typescript
     * this.grid.groupingExpressions = [{
     *     fieldName: "ID",
     *     dir: SortingDirection.Asc,
     *     ignoreCase: false
     * }];
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-grid #grid [data]="Data" [autoGenerate]="true" [(groupingExpressions)]="model.groupingExpressions"></igx-grid>
     * ```
     * \@memberof IgxGridComponent
     * @param {?} value
     * @return {?}
     */
    set groupingExpressions(value) {
        if (value && value.length > 10) {
            throw Error('Maximum amount of grouped columns is 10.');
        }
        /** @type {?} */
        const oldExpressions = this.groupingExpressions;
        /** @type {?} */
        const newExpressions = value;
        this._groupingExpressions = cloneArray(value);
        this.groupingExpressionsChange.emit(this._groupingExpressions);
        this.chipsGoupingExpressions = cloneArray(value);
        if (this._gridAPI.grid) {
            /* grouping should work in conjunction with sorting
            and without overriding separate sorting expressions */
            this._applyGrouping();
            this._gridAPI.arrange_sorting_expressions();
            this.notifyChanges();
        }
        else {
            // setter called before grid is registered in grid API service
            this.sortingExpressions.unshift.apply(this.sortingExpressions, this._groupingExpressions);
        }
        if (!this._init && JSON.stringify(oldExpressions) !== JSON.stringify(newExpressions) && this.columnList) {
            /** @type {?} */
            const groupedCols = [];
            /** @type {?} */
            const ungroupedCols = [];
            /** @type {?} */
            const groupedColsArr = newExpressions.filter((obj) => {
                return !oldExpressions.some((obj2) => {
                    return obj.fieldName === obj2.fieldName;
                });
            });
            groupedColsArr.forEach((elem) => {
                groupedCols.push(this.getColumnByName(elem.fieldName));
            }, this);
            /** @type {?} */
            const ungroupedColsArr = oldExpressions.filter((obj) => {
                return !newExpressions.some((obj2) => {
                    return obj.fieldName === obj2.fieldName;
                });
            });
            ungroupedColsArr.forEach((elem) => {
                ungroupedCols.push(this.getColumnByName(elem.fieldName));
            }, this);
            this.notifyChanges();
            /** @type {?} */
            const groupingDoneArgs = {
                expressions: newExpressions,
                groupedColumns: groupedCols,
                ungroupedColumns: ungroupedCols
            };
            this.onGroupingDone.emit(groupingDoneArgs);
        }
    }
    /**
     * Returns a list of expansion states for group rows.
     * Includes only states that differ from the default one (controlled through groupsExpanded and states that the user has changed.
     * Contains the expansion state (expanded: boolean) and the unique identifier for the group row (Array).
     * ```typescript
     * const groupExpState = this.grid.groupingExpansionState;
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    get groupingExpansionState() {
        return this._groupingExpandState;
    }
    /**
     * Sets a list of expansion states for group rows.
     * ```typescript
     *      this.grid.groupingExpansionState = [{
     *      expanded: false,
     *      hierarchy: [{ fieldName: 'ID', value: 1 }]
     *   }];
     * // You can use DataUtil.getHierarchy(groupRow) to get the group `IgxGridRowComponent` hierarchy.
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-grid #grid [data]="Data" [autoGenerate]="true" [(groupingExpansionState)]="model.groupingExpansionState"></igx-grid>
     * ```
     * \@memberof IgxGridComponent
     * @param {?} value
     * @return {?}
     */
    set groupingExpansionState(value) {
        if (value !== this._groupingExpandState) {
            this.groupingExpansionStateChange.emit(value);
        }
        this._groupingExpandState = value;
        if (this.gridAPI.grid) {
            this.cdr.detectChanges();
        }
    }
    /**
     * An \@Input property that sets whether the grouped columns should be hidden as well.
     * The default value is "false"
     * ```html
     * <igx-grid #grid [data]="localData" [hideGroupedColumns]="true" [autoGenerate]="true"></igx-grid>
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    get hideGroupedColumns() {
        return this._hideGroupedColumns;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set hideGroupedColumns(value) {
        if (value) {
            this.groupingDiffer = this.differs.find(this.groupingExpressions).create();
        }
        else {
            this.groupingDiffer = null;
        }
        if (this.columnList && this.groupingExpressions) {
            this._setGroupColsVisibility(value);
        }
        this._hideGroupedColumns = value;
    }
    /**
     * An \@Input property that sets the message displayed inside the GroupBy drop area where columns can be dragged on.
     * Note: The grid needs to have at least one groupable column in order the GroupBy area to be displayed.
     * ```html
     * <igx-grid dropAreaMessage="Drop here to group!">
     *      <igx-column [groupable]="true" field="ID"></igx-column>
     * </igx-grid>
     * ```
     * \@memberof IgxGridComponent
     * @param {?} value
     * @return {?}
     */
    set dropAreaMessage(value) {
        this._dropAreaMessage = value;
        this.notifyChanges();
    }
    /**
     * An accessor that returns the message displayed inside the GroupBy drop area where columns can be dragged on.
     * @return {?}
     */
    get dropAreaMessage() {
        return this._dropAreaMessage || this.resourceStrings.igx_grid_groupByArea_message;
    }
    /**
     * A list of all group rows.
     * ```typescript
     * const groupList = this.grid.groupsRowList;
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    get groupsRowList() {
        /** @type {?} */
        const res = new QueryList();
        if (!this._groupsRowList) {
            return res;
        }
        /** @type {?} */
        const rList = this._groupsRowList.filter((item) => {
            return item.element.nativeElement.parentElement !== null;
        });
        res.reset(rList);
        return res;
    }
    /**
     * @hidden
     * @return {?}
     */
    get groupAreaHostClass() {
        return this.getComponentDensityClass('igx-drop-area');
    }
    /**
     * Returns the template reference of the `IgxGridComponent`'s group row.
     * ```
     * const groupRowTemplate = this.grid.groupRowTemplate;
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    get groupRowTemplate() {
        return this._groupRowTemplate;
    }
    /**
     * Sets the template reference of the `IgxGridComponent`'s group `IgxGridRowComponent`.
     * ```typescript
     * this.grid.groupRowTemplate = myRowTemplate.
     * ```
     * \@memberof IgxGridComponent
     * @param {?} template
     * @return {?}
     */
    set groupRowTemplate(template) {
        this._groupRowTemplate = template;
        this.notifyChanges();
    }
    /**
     * Returns the template reference of the `IgxGridComponent`'s group area.
     * ```typescript
     * const groupAreaTemplate = this.grid.groupAreaTemplate;
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    get groupAreaTemplate() {
        return this._groupAreaTemplate;
    }
    /**
     * Sets the template reference of the `IgxGridComponent`'s group area.
     * ```typescript
     * this.grid.groupAreaTemplate = myAreaTemplate.
     * ```
     * \@memberof IgxGridComponent
     * @param {?} template
     * @return {?}
     */
    set groupAreaTemplate(template) {
        this._groupAreaTemplate = template;
        this.notifyChanges();
    }
    /**
     * Groups by a new `IgxColumnComponent` based on the provided expression, or modifies an existing one.
     * Also allows for multiple columns to be grouped at once if an array of `ISortingExpression` is passed.
     * The onGroupingDone event would get raised only **once** if this method gets called multiple times with the same arguments.
     * ```typescript
     * this.grid.groupBy({ fieldName: name, dir: SortingDirection.Asc, ignoreCase: false });
     * this.grid.groupBy([
     * { fieldName: name1, dir: SortingDirection.Asc, ignoreCase: false },
     * { fieldName: name2, dir: SortingDirection.Desc, ignoreCase: true },
     * { fieldName: name3, dir: SortingDirection.Desc, ignoreCase: false }
     * ]);
     * ```
     * \@memberof IgxGridComponent
     * @param {?} expression
     * @return {?}
     */
    groupBy(expression) {
        if (this.checkIfNoColumnField(expression)) {
            return;
        }
        this.endEdit(true);
        if (expression instanceof Array) {
            this._gridAPI.groupBy_multiple(expression);
        }
        else {
            this._gridAPI.groupBy(expression);
        }
        this.notifyChanges(true);
    }
    /**
     * Clears all grouping in the grid, if no parameter is passed.
     * If a parameter is provided, clears grouping for a particular column or an array of columns.
     * ```typescript
     * this.grid.clearGrouping(); //clears all grouping
     * this.grid.clearGrouping("ID"); //ungroups a single column
     * this.grid.clearGrouping(["ID", "Column1", "Column2"]); //ungroups multiple columns
     * ```
     *
     * @param {?=} name
     * @return {?}
     */
    clearGrouping(name) {
        this._gridAPI.clear_groupby(name);
        this.notifyChanges(true);
    }
    /**
     * Returns if a group is expanded or not.
     * ```typescript
     * public groupRow: IGroupByRecord;
     * const expandedGroup = this.grid.isExpandedGroup(this.groupRow);
     * ```
     * \@memberof IgxGridComponent
     * @param {?} group
     * @return {?}
     */
    isExpandedGroup(group) {
        /** @type {?} */
        const state = this._getStateForGroupRow(group);
        return state ? state.expanded : this.groupsExpanded;
    }
    /**
     * Toggles the expansion state of a group.
     * ```typescript
     * public groupRow: IGroupByRecord;
     * const toggleExpGroup = this.grid.toggleGroup(this.groupRow);
     * ```
     * \@memberof IgxGridComponent
     * @param {?} groupRow
     * @return {?}
     */
    toggleGroup(groupRow) {
        this._toggleGroup(groupRow);
        this.notifyChanges();
    }
    /**
     * Expands the specified group and all of its parent groups.
     * ```typescript
     * public groupRow: IGroupByRecord;
     * this.grid.fullyExpandGroup(this.groupRow);
     * ```
     * \@memberof IgxGridComponent
     * @param {?} groupRow
     * @return {?}
     */
    fullyExpandGroup(groupRow) {
        this._fullyExpandGroup(groupRow);
        this.notifyChanges();
    }
    /**
     * @hidden
     * @param {?} record
     * @return {?}
     */
    isGroupByRecord(record) {
        // return record.records instance of GroupedRecords fails under Webpack
        return record.records && record.records.length;
    }
    /**
     * Toggles the expansion state of all group rows recursively.
     * ```typescript
     * this.grid.toggleAllGroupRows;
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    toggleAllGroupRows() {
        this.groupingExpansionState = [];
        this.groupsExpanded = !this.groupsExpanded;
        this.notifyChanges();
    }
    /**
     * Returns if the `IgxGridComponent` has groupable columns.
     * ```typescript
     * const groupableGrid = this.grid.hasGroupableColumns;
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    get hasGroupableColumns() {
        return this.columnList.some((col) => col.groupable && !col.columnGroup);
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    _setGroupColsVisibility(value) {
        if (this.columnList && !this.hasColumnLayouts) {
            this.groupingExpressions.forEach((expr) => {
                /** @type {?} */
                const col = this.getColumnByName(expr.fieldName);
                col.hidden = value;
            });
        }
    }
    /**
     * Returns if the grid's group by drop area is visible.
     * ```typescript
     * const dropVisible = this.grid.dropAreaVisible;
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    get dropAreaVisible() {
        return (this.draggedColumn && this.draggedColumn.groupable) ||
            !this.chipsGoupingExpressions.length;
    }
    /**
     * @hidden
     * @protected
     * @param {?} groupRow
     * @return {?}
     */
    _getStateForGroupRow(groupRow) {
        return this._gridAPI.groupBy_get_expanded_for_group(groupRow);
    }
    /**
     * @hidden
     * @protected
     * @param {?} groupRow
     * @return {?}
     */
    _toggleGroup(groupRow) {
        this._gridAPI.groupBy_toggle_group(groupRow);
    }
    /**
     * @hidden
     * @protected
     * @param {?} groupRow
     * @return {?}
     */
    _fullyExpandGroup(groupRow) {
        this._gridAPI.groupBy_fully_expand_group(groupRow);
    }
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    _applyGrouping() {
        this._gridAPI.sort_multiple(this._groupingExpressions);
    }
    /**
     * @hidden
     * @param {?} fieldName
     * @return {?}
     */
    isColumnGrouped(fieldName) {
        return this.groupingExpressions.find(exp => exp.fieldName === fieldName) ? true : false;
    }
    /**
     * @hidden
     * @param {?} rowData
     * @param {?} rowIndex
     * @return {?}
     */
    getContext(rowData, rowIndex) {
        return {
            $implicit: rowData,
            index: rowIndex,
            templateID: this.isGroupByRecord(rowData) ? 'groupRow' : this.isSummaryRow(rowData) ? 'summaryRow' : 'dataRow'
        };
    }
    /**
     * @hidden
     * @return {?}
     */
    get template() {
        if (this.filteredData && this.filteredData.length === 0) {
            return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyFilteredGridTemplate;
        }
        if (this.isLoading && (!this.data || this.dataLength === 0)) {
            return this.loadingGridTemplate ? this.loadingGridTemplate : this.loadingGridDefaultTemplate;
        }
        if (this.dataLength === 0) {
            return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyGridDefaultTemplate;
        }
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onChipRemoved(event) {
        this.clearGrouping(event.owner.id);
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    chipsOrderChanged(event) {
        /** @type {?} */
        const newGrouping = [];
        for (let i = 0; i < event.chipsArray.length; i++) {
            /** @type {?} */
            const expr = this.groupingExpressions.filter((item) => {
                return item.fieldName === event.chipsArray[i].id;
            })[0];
            if (!this.getColumnByName(expr.fieldName).groupable) {
                // disallow changing order if there are columns with groupable: false
                return;
            }
            newGrouping.push(expr);
        }
        this.groupingExpansionState = [];
        this.chipsGoupingExpressions = newGrouping;
        if (event.originalEvent instanceof KeyboardEvent) {
            // When reordered using keyboard navigation, we don't have `onMoveEnd` event.
            this.groupingExpressions = this.chipsGoupingExpressions;
        }
        this.notifyChanges();
    }
    /**
     * @hidden
     * @return {?}
     */
    chipsMovingEnded() {
        this.groupingExpressions = this.chipsGoupingExpressions;
        this.notifyChanges();
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onChipClicked(event) {
        /** @type {?} */
        const sortingExpr = this.sortingExpressions;
        /** @type {?} */
        const columnExpr = sortingExpr.find((expr) => expr.fieldName === event.owner.id);
        columnExpr.dir = 3 - columnExpr.dir;
        this.sort(columnExpr);
        this.notifyChanges();
    }
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    onChipKeyDown(event) {
        if (event.originalEvent.key === ' ' || event.originalEvent.key === 'Spacebar' || event.originalEvent.key === 'Enter') {
            /** @type {?} */
            const sortingExpr = this.sortingExpressions;
            /** @type {?} */
            const columnExpr = sortingExpr.find((expr) => expr.fieldName === event.owner.id);
            columnExpr.dir = 3 - columnExpr.dir;
            this.sort(columnExpr);
            this.notifyChanges();
        }
    }
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    get defaultTargetBodyHeight() {
        /** @type {?} */
        const allItems = this.totalItemCount || this.dataLength;
        return this.renderedRowHeight * Math.min(this._defaultTargetRecordNumber, this.paging ? Math.min(allItems, this.perPage) : allItems);
    }
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    getGroupAreaHeight() {
        return this.groupArea ? this.groupArea.nativeElement.offsetHeight : 0;
    }
    /**
     * @hidden
     * Gets the combined width of the columns that are specific to the enabled grid features. They are fixed.
     * TODO: Remove for Angular 8. Calling parent class getter using super is not supported for now.
     * @return {?}
     */
    getFeatureColumnsWidth() {
        /** @type {?} */
        let width = super.getFeatureColumnsWidth();
        if (this.groupingExpressions.length && this.headerGroupContainer) {
            width += this.headerGroupContainer.nativeElement.offsetWidth;
        }
        return width;
    }
    /**
     * @hidden
     * @protected
     * @param {?} row
     * @param {?} column
     * @return {?}
     */
    scrollTo(row, column) {
        if (this.groupingExpressions && this.groupingExpressions.length
            && typeof (row) !== 'number') {
            /** @type {?} */
            const rowIndex = this.groupingResult.indexOf(row);
            /** @type {?} */
            const groupByRecord = this.groupingMetadata[rowIndex];
            if (groupByRecord) {
                this._fullyExpandGroup(groupByRecord);
            }
        }
        super.scrollTo(row, column, this.groupingFlatResult);
    }
    /**
     * @hidden
     * @return {?}
     */
    get dropAreaTemplateResolved() {
        if (this.dropAreaTemplate) {
            return this.dropAreaTemplate;
        }
        else {
            return this.defaultDropAreaTemplate;
        }
    }
    /**
     * @hidden
     * @param {?} expression
     * @return {?}
     */
    getGroupByChipTitle(expression) {
        /** @type {?} */
        const column = this.getColumnByName(expression.fieldName);
        return (column && column.header) || expression.fieldName;
    }
    /**
     * @hidden
     * @return {?}
     */
    get iconTemplate() {
        if (this.groupsExpanded) {
            return this.headerExpandIndicatorTemplate || this.defaultExpandedTemplate;
        }
        else {
            return this.headerCollapseIndicatorTemplate || this.defaultCollapsedTemplate;
        }
    }
    /**
     * @hidden
     * @param {?} fieldName
     * @return {?}
     */
    getColumnGroupable(fieldName) {
        /** @type {?} */
        const column = this.getColumnByName(fieldName);
        return column && column.groupable;
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterContentInit() {
        super.ngAfterContentInit();
        if (this.allowFiltering && this.hasColumnLayouts) {
            this.filterMode = FilterMode.excelStyleFilter;
        }
        if (this.groupTemplate) {
            this._groupRowTemplate = this.groupTemplate.template;
        }
        if (this.hideGroupedColumns && this.columnList && this.groupingExpressions) {
            this._setGroupColsVisibility(this.hideGroupedColumns);
        }
        this._setupNavigationService();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        this.onGroupingDone.pipe(takeUntil(this.destroy$)).subscribe((args) => {
            this.endEdit(true);
            this.summaryService.updateSummaryCache(args);
        });
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this.groupingDiffer && this.columnList && !this.hasColumnLayouts) {
            /** @type {?} */
            const changes = this.groupingDiffer.diff(this.groupingExpressions);
            if (changes && this.columnList) {
                changes.forEachAddedItem((rec) => {
                    /** @type {?} */
                    const col = this.getColumnByName(rec.item.fieldName);
                    col.hidden = true;
                });
                changes.forEachRemovedItem((rec) => {
                    /** @type {?} */
                    const col = this.getColumnByName(rec.item.fieldName);
                    col.hidden = false;
                });
            }
        }
        super.ngDoCheck();
    }
    /**
     * \@inheritdoc
     * @param {?=} formatters
     * @param {?=} headers
     * @return {?}
     */
    getSelectedData(formatters = false, headers = false) {
        if (this.groupingExpressions.length) {
            /** @type {?} */
            const source = [];
            /** @type {?} */
            const process = (record) => {
                if (record.expression || record.summaries) {
                    source.push(null);
                    return;
                }
                source.push(record);
            };
            this.dataView.forEach(process);
            return this.extractDataFromSelection(source, formatters, headers);
        }
        else {
            return super.getSelectedData(formatters, headers);
        }
    }
    /**
     * @private
     * @return {?}
     */
    _setupNavigationService() {
        if (this.hasColumnLayouts) {
            this.navigation = new IgxGridMRLNavigationService();
            this.navigation.grid = this;
        }
    }
    /**
     * @private
     * @param {?} expression
     * @return {?}
     */
    checkIfNoColumnField(expression) {
        if (expression instanceof Array) {
            for (const singleExpression of expression) {
                if (!singleExpression.fieldName) {
                    return true;
                }
            }
            return false;
        }
        return !expression.fieldName;
    }
}
IgxGridComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                providers: [
                    IgxGridNavigationService,
                    IgxGridSummaryService,
                    IgxGridSelectionService,
                    IgxGridCRUDService,
                    { provide: GridBaseAPIService, useClass: IgxGridAPIService },
                    { provide: IgxGridBaseComponent, useExisting: forwardRef(() => IgxGridComponent) },
                    IgxFilteringService,
                    IgxColumnResizingService,
                    IgxForOfSyncService,
                    IgxForOfScrollSyncService,
                    IgxRowIslandAPIService
                ],
                selector: 'igx-grid',
                template: "<igx-grid-toolbar [style.flex-basis.px]=\"outerWidth\" role=\"rowgroup\" *ngIf=\"showToolbar\" [gridID]=\"id\"\n    [displayDensity]=\"displayDensity\" #toolbar>\n</igx-grid-toolbar>\n\n<div [style.flex-basis.px]='outerWidth' class=\"igx-grid__grouparea\"\n    *ngIf=\"groupingExpressions.length > 0 || hasGroupableColumns\" #groupArea>\n    <igx-chips-area (onReorder)=\"chipsOrderChanged($event)\" (onMoveEnd)=\"chipsMovingEnded()\">\n        <ng-container *ngFor=\"let expr of chipsGoupingExpressions; let last = last;\">\n            <igx-chip [id]=\"expr.fieldName\" [attr.title]=\"getGroupByChipTitle(expr)\"\n                [removable]=\"getColumnGroupable(expr.fieldName)\"\n                [draggable]=\"getColumnGroupable(expr.fieldName)\" [displayDensity]=\"displayDensity\"\n                (onKeyDown)=\"onChipKeyDown($event)\" (onRemove)=\"onChipRemoved($event)\"\n                (onClick)=\"getColumnGroupable(expr.fieldName) ? onChipClicked($event): null\"\n                [disabled]='!getColumnGroupable(expr.fieldName)'>\n                <span>{{ getGroupByChipTitle(expr) }}</span>\n                <igx-icon igxSuffix>{{ expr.dir == 1 ? 'arrow_upward' : 'arrow_downward' }}</igx-icon>\n            </igx-chip>\n            <span class=\"igx-grid__grouparea-connector\">\n                <igx-icon [style.visibility]=\"(!last || dropAreaVisible) ? 'visible' : 'hidden'\">arrow_forward\n                </igx-icon>\n            </span>\n        </ng-container>\n        <div igxGroupAreaDrop [style.visibility]=\"dropAreaVisible ? 'visible' : 'hidden'\" [class]=\"groupAreaHostClass\"\n            [attr.gridId]='this.id'>\n            <ng-container *ngTemplateOutlet=\"dropAreaTemplateResolved\"></ng-container>\n        </div>\n    </igx-chips-area>\n</div>\n\n<div class=\"igx-grid__thead\">\n    <div class=\"igx-grid__thead-wrapper\" [class.igx-grid__tr--mrl]='hasColumnLayouts' role=\"rowgroup\"\n    [style.width.px]='calcWidth' #theadRow>\n        <div class=\"igx-grid__tr\" role=\"row\" [style.width.px]='calcWidth'>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-left\" [style.left.px]=\"featureColumnsWidth\"></span>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n\n            <ng-container *ngIf=\"groupingExpressions.length > 0\">\n                <div class=\"igx-grid__header-indentation igx-grid__row-indentation--level-{{groupingExpressions.length}}\"\n                    [ngClass]=\"{\n                    'igx-grid__header-indentation--no-border': isRowSelectable || rowDraggable\n                }\" #headerGroupContainer  (click)=\"toggleAllGroupRows()\">\n\n                <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit: this }\"></ng-container>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"rowDraggable\">\n                <div class=\"igx-grid__drag-indicator\" [ngClass]=\"{\n                    'igx-grid__drag-indicator--header': !isRowSelectable\n                }\" #headerDragContainer>\n                    <div style=\"visibility: hidden;\">\n                        <ng-container\n                            *ngTemplateOutlet=\"this.dragIndicatorIconTemplate ? this.dragIndicatorIconTemplate : dragIndicatorIconBase\">\n                        </ng-container>\n                    </div>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"showRowSelectors\">\n                <div class=\"igx-grid__cbx-selection\" (click)=\"onHeaderSelectorClick($event)\" #headerSelectorContainer [ngClass]=\"{\n                    'igx-grid__cbx-selection--push': filteringService.isFilterRowVisible\n                }\">\n                    <ng-template #headSelector\n                        *ngTemplateOutlet=\"\n                        this.headSelectorTemplate ? this.headSelectorTemplate : headSelectorBaseTemplate;\n                        context: { $implicit: {\n                                        selectedCount: this.selectionService.filteredSelectedRowIds.length,\n                                        totalCount: this.totalRowsCountAfterFilter }}\">\n                    </ng-template>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"pinnedColumns.length > 0\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width.px]=\"getHeaderGroupWidth(col)\"\n                        [style.flex-basis.px]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n            <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxTopLevel\"\n                [igxForScrollOrientation]=\"'horizontal'\" [igxForScrollContainer]=\"parentVirtDir\"\n                [igxForContainerSize]='unpinnedWidth' [igxForTrackBy]='trackColumnChanges'\n                [igxForSizePropName]='\"calcPixelWidth\"' #hContainer>\n                <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width.px]=\"getHeaderGroupWidth(col)\"\n                    [style.flex-basis.px]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n            </ng-template>\n        </div>\n        <igx-grid-filtering-row #filteringRow [style.width.px]='calcWidth' *ngIf=\"filteringService.isFilterRowVisible\"\n            [column]=\"filteringService.filteredColumn\"></igx-grid-filtering-row>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div class=\"igx-grid__thead-thumb\" [hidden]='!hasVerticalSroll()' [style.width.px]=\"scrollWidth\"></div>\n</div>\n\n<div igxGridBody (keydown.control.c)=\"copyHandlerIE()\" (copy)=\"copyHandler($event)\" class=\"igx-grid__tbody\">\n    <div class=\"igx-grid__tbody-content\" role=\"rowgroup\" (onDragStop)=\"selectionService.dragMode = $event\"\n        (onDragScroll)=\"dragScroll($event)\" [igxGridDragSelect]=\"selectionService.dragMode\"\n        [style.height.px]='calcHeight' [style.width.px]='calcWidth || null' #tbody>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-left\"></span>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n        <ng-template igxGridFor let-rowData [igxGridForOf]=\"data\n        | gridTransaction:id:pipeTrigger\n        | visibleColumns:hasVisibleColumns\n        | gridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:id:pipeTrigger:filteringPipeTrigger\n        | gridSort:sortingExpressions:id:pipeTrigger\n        | gridGroupBy:groupingExpressions:groupingExpansionState:groupsExpanded:id:groupsRecords:pipeTrigger\n        | gridPaging:page:perPage:id:pipeTrigger\n        | gridSummary:hasSummarizedColumns:summaryCalculationMode:summaryPosition:id:pipeTrigger:summaryPipeTrigger\"\n            let-rowIndex=\"index\" [igxForScrollOrientation]=\"'vertical'\" [igxForScrollContainer]='verticalScroll'\n            [igxForContainerSize]='calcHeight'\n            [igxForItemSize]=\"hasColumnLayouts ? rowHeight * multiRowLayoutRowSize + 1 : renderedRowHeight\"\n            #verticalScrollContainer (onChunkPreload)=\"dataLoading($event)\">\n            <ng-template #record_template>\n                <igx-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [rowData]=\"rowData\" #row>\n                </igx-grid-row>\n            </ng-template>\n            <ng-template #group_template>\n                <igx-grid-groupby-row [gridID]=\"id\" [index]=\"rowIndex\" [groupRow]=\"rowData\" #row>\n                </igx-grid-groupby-row>\n            </ng-template>\n            <ng-template #summary_template>\n                <igx-grid-summary-row [gridID]=\"id\" [summaries]=\"rowData.summaries\" [index]=\"rowIndex\"\n                    class=\"igx-grid__summaries--body\" #summaryRow>\n                </igx-grid-summary-row>\n            </ng-template>\n            <ng-template\n                [igxTemplateOutlet]='isGroupByRecord(rowData) ? group_template : isSummaryRow(rowData) ? summary_template : record_template'\n                [igxTemplateOutletContext]='getContext(rowData, rowIndex)'\n                (onCachedViewLoaded)='cachedViewLoaded($event)'\n                (onBeforeViewDetach)='viewDetachHandler($event)' >\n            </ng-template>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"template\"></ng-container>\n        <div class=\"igx-grid__row-editing-outlet\" igxOverlayOutlet #igxRowEditingOverlayOutlet></div>\n    </div>\n    <div [style.display]=\"shouldOverlayLoading ? 'flex' : 'none'\" #loadingOverlay>\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div [hidden]='!hasVerticalSroll()' class=\"igx-grid__tbody-scrollbar\" [style.width.px]=\"scrollWidth\"\n        [style.height.px]='calcHeight'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #verticalScrollHolder></ng-template>\n    </div>\n</div>\n\n\n<div class=\"igx-grid__tfoot\" role=\"rowgroup\" [style.height.px]='summariesHeight' #tfoot>\n    <igx-grid-summary-row [style.width.px]='calcWidth' [style.height.px]='summariesHeight'\n        *ngIf=\"hasSummarizedColumns && rootSummariesEnabled\" [gridID]=\"id\"\n        [summaries]=\"id | igxGridSummaryDataPipe:summaryService.retriggerRootPipe\" [index]=\"0\"\n        class=\"igx-grid__summaries\" #summaryRow>\n    </igx-grid-summary-row>\n    <div class=\"igx-grid__tfoot-thumb\" [hidden]='!hasVerticalSroll()' [style.height.px]='summariesHeight'\n        [style.width.px]=\"scrollWidth\"></div>\n</div>\n\n<div class=\"igx-grid__scroll\" [style.height]=\"'18px'\" #scr [hidden]=\"isHorizontalScrollHidden\">\n    <div class=\"igx-grid__scroll-start\" [style.width.px]='pinnedWidth' [hidden]=\"pinnedWidth === 0\"></div>\n    <div class=\"igx-grid__scroll-main\" [style.width.px]='unpinnedWidth'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #scrollContainer>\n        </ng-template>\n    </div>\n</div>\n\n<div class=\"igx-grid__footer\" #footer>\n    <ng-content select=\"igx-grid-footer\"></ng-content>\n    <ng-container *ngIf=\"paging && totalRecords\">\n        <ng-container\n            *ngTemplateOutlet=\"paginationTemplate ? paginationTemplate : defaultPaginator; context: {$implicit: this}\">\n        </ng-container>\n    </ng-container>\n</div>\n\n<ng-template #defaultPaginator>\n    <igx-paginator [displayDensity]=\"displayDensity\" [(page)]=\"page\" [totalRecords]=\"totalRecords\" [(perPage)]=\"perPage\">\n    </igx-paginator>\n</ng-template>\n\n<ng-template #emptyFilteredGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyFilteredGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultEmptyGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultLoadingGrid>\n    <div class=\"igx-grid__loading\">\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n</ng-template>\n\n<ng-template #defaultDropArea>\n    <igx-icon fontSet=\"material\" class=\"igx-drop-area__icon\">group_work</igx-icon>\n    <span class=\"igx-drop-area__text\">{{dropAreaMessage}}</span>\n</ng-template>\n\n<ng-template #defaultExpandedTemplate>\n    <igx-icon role=\"button\" class=\"igx-grid__group-expand-btn\"\n   [ngClass]=\"{\n    'igx-grid__group-expand-btn--push': filteringService.isFilterRowVisible\n}\">unfold_less</igx-icon>\n</ng-template>\n\n <ng-template #defaultCollapsedTemplate>\n    <igx-icon role=\"button\" class=\"igx-grid__group-expand-btn\"\n    [ngClass]=\"{\n    'igx-grid__group-expand-btn--push': filteringService.isFilterRowVisible\n}\">unfold_more</igx-icon>\n</ng-template>\n\n<div *ngIf=\"rowEditable\" igxToggle>\n    <div [className]=\"bannerClass\">\n        <ng-container\n            *ngTemplateOutlet=\"rowEditContainer; context: { rowChangesCount: rowChangesCount, endEdit: endEdit.bind(this) }\">\n        </ng-container>\n    </div>\n</div>\n\n<ng-template #defaultRowEditText>\n    You have {{ rowChangesCount }} changes in this row\n</ng-template>\n\n<ng-template #defaultRowEditActions>\n    <button igxButton igxRowEditTabStop (click)=\"endEdit(false, $event)\">Cancel</button>\n    <button igxButton igxRowEditTabStop (click)=\"endEdit(true, $event)\">Done</button>\n</ng-template>\n\n<ng-template #defaultRowEditTemplate>\n    <div class=\"igx-banner__message\">\n        <span class=\"igx-banner__text\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditText ? rowEditText : defaultRowEditText; context: { $implicit: rowChangesCount }\">\n            </ng-container>\n        </span>\n    </div>\n    <div class=\"igx-banner__actions\">\n        <div class=\"igx-banner__row\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditActions ? rowEditActions : defaultRowEditActions; context: { $implicit: endEdit.bind(this) }\">\n            </ng-container>\n        </div>\n    </div>\n</ng-template>\n\n<ng-template #dragIndicatorIconBase>\n    <igx-icon fontSet=\"material\">drag_indicator</igx-icon>\n</ng-template>\n\n<ng-template #headSelectorBaseTemplate igxHeadSelector let-context>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [readonly]=\"true\"\n            [checked]=\"context.selectedCount > 0 && context.totalCount === context.selectedCount\"\n            disableRipple=\"true\"\n            [ngStyle]=\"{'visibility': isMultiRowSelectionEnabled? 'visible' : 'hidden' }\"\n            [indeterminate]=\"context.selectedCount > 0 && context.selectedCount !== context.totalCount\"\n            [aria-label]=\"headSelectorBaseAriaLabel\"\n            #headerCheckbox>\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n<igx-grid-column-resizer *ngIf=\"colResizingService.showResizer\"></igx-grid-column-resizer>\n<div class=\"igx-grid__loading-outlet\" #igxLoadingOverlayOutlet igxOverlayOutlet></div>\n<div class=\"igx-grid__outlet\" #igxFilteringOverlayOutlet igxOverlayOutlet (keydown)=\"gridOutletKeyboardHandler($event)\"></div>\n"
            }] }
];
IgxGridComponent.propDecorators = {
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    data: [{ type: Input }],
    groupingExpressions: [{ type: Input }],
    groupingExpressionsChange: [{ type: Output }],
    groupingExpansionState: [{ type: Input }],
    groupingExpansionStateChange: [{ type: Output }],
    groupsExpanded: [{ type: Input }],
    hideGroupedColumns: [{ type: Input }],
    dropAreaMessage: [{ type: Input }],
    dropAreaTemplate: [{ type: Input }],
    onGroupingDone: [{ type: Output }],
    groupTemplate: [{ type: ContentChild, args: [IgxGroupByRowTemplateDirective, { read: IgxGroupByRowTemplateDirective, static: false },] }],
    _groupsRowList: [{ type: ViewChildren, args: [IgxGridGroupByRowComponent, { read: IgxGridGroupByRowComponent },] }],
    defaultDropAreaTemplate: [{ type: ViewChild, args: ['defaultDropArea', { read: TemplateRef, static: true },] }],
    groupArea: [{ type: ViewChild, args: ['groupArea', { static: false },] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    IgxGridComponent.prototype._id;
    /**
     * @hidden \@internal
     * @type {?}
     */
    IgxGridComponent.prototype.groupingResult;
    /**
     * @hidden \@internal
     * @type {?}
     */
    IgxGridComponent.prototype.groupingMetadata;
    /**
     * @hidden \@internal
     * @type {?}
     */
    IgxGridComponent.prototype.groupingFlatResult;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxGridComponent.prototype._groupingExpressions;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxGridComponent.prototype._groupingExpandState;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxGridComponent.prototype._groupRowTemplate;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxGridComponent.prototype._groupAreaTemplate;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxGridComponent.prototype.groupingDiffer;
    /**
     * @type {?}
     * @private
     */
    IgxGridComponent.prototype._data;
    /**
     * @type {?}
     * @private
     */
    IgxGridComponent.prototype._hideGroupedColumns;
    /**
     * @type {?}
     * @private
     */
    IgxGridComponent.prototype._dropAreaMessage;
    /**
     * @type {?}
     * @private
     */
    IgxGridComponent.prototype._filteredData;
    /**
     * @hidden
     * @type {?}
     */
    IgxGridComponent.prototype.groupingExpressionsChange;
    /**
     * @hidden
     * @type {?}
     */
    IgxGridComponent.prototype.groupingExpansionStateChange;
    /**
     * An \@Input property that determines whether created groups are rendered expanded or collapsed.
     * The default rendered state is expanded.
     * ```html
     * <igx-grid #grid [data]="Data" [groupsExpanded]="false" [autoGenerate]="true"></igx-grid>
     * ```
     * \@memberof IgxGridComponent
     * @type {?}
     */
    IgxGridComponent.prototype.groupsExpanded;
    /**
     * A hierarchical representation of the group by records.
     * ```typescript
     * let groupRecords = this.grid.groupsRecords;
     * ```
     * \@memberof IgxGridComponent
     * @type {?}
     */
    IgxGridComponent.prototype.groupsRecords;
    /**
     * An \@Input property that sets the template that will be rendered as a GroupBy drop area.
     * Note: The grid needs to have at least one groupable column in order the GroupBy area to be displayed.
     * ```html
     * <igx-grid [dropAreaTemplate]="dropAreaRef">
     *      <igx-column [groupable]="true" field="ID"></igx-column>
     * </igx-grid>
     * <ng-template #myDropArea>
     *      <span> Custom drop area! </span>
     * </ng-template>
     * ```
     * ```ts
     * \@ViewChild('myDropArea', { read: TemplateRef })
     * public dropAreaRef: TemplateRef<any>;
     * ```
     * \@memberof IgxGridComponent
     * @type {?}
     */
    IgxGridComponent.prototype.dropAreaTemplate;
    /**
     * Emitted when a new `IgxColumnComponent` gets grouped/ungrouped, or multiple columns get
     * grouped/ungrouped at once by using the Group By API.
     * The `onGroupingDone` event would be raised only once if several columns get grouped at once by calling
     * the `groupBy()` or `clearGrouping()` API methods and passing an array as an argument.
     * The event arguments provide the `expressions`, `groupedColumns` and `ungroupedColumns` properties, which contain
     * the `ISortingExpression` and the `IgxColumnComponent` related to the grouping/ungrouping operation.
     * Please note that `groupedColumns` and `ungroupedColumns` show only the **newly** changed columns (affected by the **last**
     * grouping/ungrouping operation), not all columns which are currently grouped/ungrouped.
     * columns.
     * ```typescript
     * groupingDone(event: IGroupingDoneEventArgs){
     *     const expressions = event.expressions;
     *     //the newly grouped columns
     *     const groupedColumns = event.groupedColumns;
     *     //the newly ungrouped columns
     *     const ungroupedColumns = event.ungroupedColumns;
     * }
     * ```
     * ```html
     * <igx-grid #grid [data]="localData" (onGroupingDone)="groupingDone($event)" [autoGenerate]="true"></igx-grid>
     * ```
     * \@memberof IgxGridComponent
     * @type {?}
     */
    IgxGridComponent.prototype.onGroupingDone;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxGridComponent.prototype.groupTemplate;
    /**
     * @type {?}
     * @private
     */
    IgxGridComponent.prototype._groupsRowList;
    /**
     * @hidden
     * @type {?}
     */
    IgxGridComponent.prototype.defaultDropAreaTemplate;
    /**
     * @hidden
     * @type {?}
     */
    IgxGridComponent.prototype.groupArea;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JpZC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLyIsInNvdXJjZXMiOlsibGliL2dyaWRzL2dyaWQvZ3JpZC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFDSCxTQUFTLEVBQUUsdUJBQXVCLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFDM0YsU0FBUyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUE2QixXQUFXLEVBQUUsVUFBVSxFQUNwRyxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNwRCxPQUFPLEVBQUUsb0JBQW9CLEVBQXFCLE1BQU0sd0JBQXdCLENBQUM7QUFDakYsT0FBTyxFQUFFLHdCQUF3QixFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDdEUsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFFdkQsT0FBTyxFQUFFLFVBQVUsRUFBa0IsTUFBTSxrQkFBa0IsQ0FBQztBQUU5RCxPQUFPLEVBQUUsOEJBQThCLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNuRSxPQUFPLEVBQUUsMEJBQTBCLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUtyRSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDM0MsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0scUNBQXFDLENBQUM7QUFFMUUsT0FBTyxFQUFFLHdCQUF3QixFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFDM0UsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sbUNBQW1DLENBQUM7QUFDMUUsT0FBTyxFQUFFLHVCQUF1QixFQUFFLGtCQUFrQixFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDeEYsT0FBTyxFQUFFLG1CQUFtQixFQUFFLHlCQUF5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LEtBQUs7d0NBeUVMLE1BQU07cUNBWU4sS0FBSzsyQ0FrQ0wsTUFBTTs2QkFXTixLQUFLO2lDQW9CTCxLQUFLOzhCQTRCTCxLQUFLOytCQThCTCxLQUFLOzZCQTJCTCxNQUFNOzRCQU1OLFlBQVksU0FBQyw4QkFBOEIsRUFBRSxFQUFFLElBQUksRUFBRSw4QkFBOEIsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFOzZCQUdwRyxZQUFZLFNBQUMsMEJBQTBCLEVBQUUsRUFBRSxJQUFJLEVBQUUsMEJBQTBCLEVBQUU7c0NBTTdFLFNBQVMsU0FBQyxpQkFBaUIsRUFBRSxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTt3QkF5QmhFLFNBQVMsU0FBQyxXQUFXLEVBQUUsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFOzs7Ozs7O0lBL2F6QywrQkFBc0M7Ozs7O0lBSXRDLDBDQUE2Qjs7Ozs7SUFLN0IsNENBQStCOzs7OztJQUsvQiw4Q0FBaUM7Ozs7OztJQUlqQyxnREFBMkQ7Ozs7OztJQUkzRCxnREFBMkQ7Ozs7OztJQUkzRCw2Q0FBOEM7Ozs7OztJQUk5Qyw4Q0FBK0M7Ozs7OztJQUkvQywwQ0FBeUI7Ozs7O0lBQ3pCLGlDQUFjOzs7OztJQUNkLCtDQUFvQzs7Ozs7SUFDcEMsNENBQWdDOzs7OztJQThHaEMseUNBQTZCOzs7OztJQWtGN0IscURBQzZFOzs7OztJQTZDN0Usd0RBQ2dGOzs7Ozs7Ozs7O0lBVWhGLDBDQUM2Qjs7Ozs7Ozs7O0lBUzdCLHlDQUE0Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQW9FNUMsNENBQzBDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQTBCMUMsMENBQ21FOzs7Ozs7SUFLbkUseUNBQ3dEOzs7OztJQUV4RCwwQ0FDOEQ7Ozs7O0lBSzlELG1EQUNpRDs7Ozs7SUF3QmpELHFDQUM2QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQ29tcG9uZW50LCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyLCBDb250ZW50Q2hpbGQsIFZpZXdDaGlsZHJlbixcbiAgICBRdWVyeUxpc3QsIFZpZXdDaGlsZCwgRWxlbWVudFJlZiwgVGVtcGxhdGVSZWYsIERvQ2hlY2ssIEFmdGVyQ29udGVudEluaXQsIEhvc3RCaW5kaW5nLCBmb3J3YXJkUmVmLCBPbkluaXRcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBHcmlkQmFzZUFQSVNlcnZpY2UgfSBmcm9tICcuLi9hcGkuc2VydmljZSc7XG5pbXBvcnQgeyBJZ3hHcmlkQmFzZUNvbXBvbmVudCwgSUdyaWREYXRhQmluZGFibGUgfSBmcm9tICcuLi9ncmlkLWJhc2UuY29tcG9uZW50JztcbmltcG9ydCB7IElneEdyaWROYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4uL2dyaWQtbmF2aWdhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IElneEdyaWRBUElTZXJ2aWNlIH0gZnJvbSAnLi9ncmlkLWFwaS5zZXJ2aWNlJztcbmltcG9ydCB7IElTb3J0aW5nRXhwcmVzc2lvbiB9IGZyb20gJy4uLy4uL2RhdGEtb3BlcmF0aW9ucy9zb3J0aW5nLWV4cHJlc3Npb24uaW50ZXJmYWNlJztcbmltcG9ydCB7IGNsb25lQXJyYXksIElCYXNlRXZlbnRBcmdzIH0gZnJvbSAnLi4vLi4vY29yZS91dGlscyc7XG5pbXBvcnQgeyBJR3JvdXBCeVJlY29yZCB9IGZyb20gJy4uLy4uL2RhdGEtb3BlcmF0aW9ucy9ncm91cGJ5LXJlY29yZC5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgSWd4R3JvdXBCeVJvd1RlbXBsYXRlRGlyZWN0aXZlIH0gZnJvbSAnLi9ncmlkLmRpcmVjdGl2ZXMnO1xuaW1wb3J0IHsgSWd4R3JpZEdyb3VwQnlSb3dDb21wb25lbnQgfSBmcm9tICcuL2dyb3VwYnktcm93LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJR3JvdXBCeUV4cGFuZFN0YXRlIH0gZnJvbSAnLi4vLi4vZGF0YS1vcGVyYXRpb25zL2dyb3VwYnktZXhwYW5kLXN0YXRlLmludGVyZmFjZSc7XG5pbXBvcnQgeyBJQmFzZUNoaXBFdmVudEFyZ3MsIElDaGlwQ2xpY2tFdmVudEFyZ3MsIElDaGlwS2V5RG93bkV2ZW50QXJncyB9IGZyb20gJy4uLy4uL2NoaXBzL2NoaXAuY29tcG9uZW50JztcbmltcG9ydCB7IElDaGlwc0FyZWFSZW9yZGVyRXZlbnRBcmdzIH0gZnJvbSAnLi4vLi4vY2hpcHMvY2hpcHMtYXJlYS5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4Q29sdW1uQ29tcG9uZW50IH0gZnJvbSAnLi4vY29sdW1uLmNvbXBvbmVudCc7XG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBJZ3hGaWx0ZXJpbmdTZXJ2aWNlIH0gZnJvbSAnLi4vZmlsdGVyaW5nL2dyaWQtZmlsdGVyaW5nLnNlcnZpY2UnO1xuaW1wb3J0IHsgSUdyb3VwaW5nRXhwcmVzc2lvbiB9IGZyb20gJy4uLy4uL2RhdGEtb3BlcmF0aW9ucy9ncm91cGluZy1leHByZXNzaW9uLmludGVyZmFjZSc7XG5pbXBvcnQgeyBJZ3hDb2x1bW5SZXNpemluZ1NlcnZpY2UgfSBmcm9tICcuLi9ncmlkLWNvbHVtbi1yZXNpemluZy5zZXJ2aWNlJztcbmltcG9ydCB7IElneEdyaWRTdW1tYXJ5U2VydmljZSB9IGZyb20gJy4uL3N1bW1hcmllcy9ncmlkLXN1bW1hcnkuc2VydmljZSc7XG5pbXBvcnQgeyBJZ3hHcmlkU2VsZWN0aW9uU2VydmljZSwgSWd4R3JpZENSVURTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vY29yZS9ncmlkLXNlbGVjdGlvbic7XG5pbXBvcnQgeyBJZ3hGb3JPZlN5bmNTZXJ2aWNlLCBJZ3hGb3JPZlNjcm9sbFN5bmNTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9mb3Itb2YvZm9yX29mLnN5bmMuc2VydmljZSc7XG5pbXBvcnQgeyBJZ3hEcmFnSW5kaWNhdG9ySWNvbkRpcmVjdGl2ZSB9IGZyb20gJy4uL3Jvdy1kcmFnLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBJZ3hHcmlkTVJMTmF2aWdhdGlvblNlcnZpY2UgfSBmcm9tICcuLi9ncmlkLW1ybC1uYXZpZ2F0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgSWd4Um93SXNsYW5kQVBJU2VydmljZSB9IGZyb20gJy4uL2hpZXJhcmNoaWNhbC1ncmlkL3Jvdy1pc2xhbmQtYXBpLnNlcnZpY2UnO1xuaW1wb3J0IHsgRmlsdGVyTW9kZSB9IGZyb20gJy4uL2NvbW1vbi9lbnVtcyc7XG5cbmxldCBORVhUX0lEID0gMDtcblxuZXhwb3J0IGludGVyZmFjZSBJR3JvdXBpbmdEb25lRXZlbnRBcmdzIGV4dGVuZHMgSUJhc2VFdmVudEFyZ3Mge1xuICAgIGV4cHJlc3Npb25zOiBBcnJheTxJU29ydGluZ0V4cHJlc3Npb24+IHwgSVNvcnRpbmdFeHByZXNzaW9uO1xuICAgIGdyb3VwZWRDb2x1bW5zOiBBcnJheTxJZ3hDb2x1bW5Db21wb25lbnQ+IHwgSWd4Q29sdW1uQ29tcG9uZW50O1xuICAgIHVuZ3JvdXBlZENvbHVtbnM6IEFycmF5PElneENvbHVtbkNvbXBvbmVudD4gfCBJZ3hDb2x1bW5Db21wb25lbnQ7XG59XG5cbi8qKlxuICogKipJZ25pdGUgVUkgZm9yIEFuZ3VsYXIgR3JpZCoqIC1cbiAqIFtEb2N1bWVudGF0aW9uXShodHRwczovL3d3dy5pbmZyYWdpc3RpY3MuY29tL3Byb2R1Y3RzL2lnbml0ZS11aS1hbmd1bGFyL2FuZ3VsYXIvY29tcG9uZW50cy9ncmlkLmh0bWwpXG4gKlxuICogVGhlIElnbml0ZSBVSSBHcmlkIGlzIHVzZWQgZm9yIHByZXNlbnRpbmcgYW5kIG1hbmlwdWxhdGluZyB0YWJ1bGFyIGRhdGEgaW4gdGhlIHNpbXBsZXN0IHdheSBwb3NzaWJsZS4gIE9uY2UgZGF0YVxuICogaGFzIGJlZW4gYm91bmQsIGl0IGNhbiBiZSBtYW5pcHVsYXRlZCB0aHJvdWdoIGZpbHRlcmluZywgc29ydGluZyAmIGVkaXRpbmcgb3BlcmF0aW9ucy5cbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgaHRtbFxuICogPGlneC1ncmlkIFtkYXRhXT1cImVtcGxveWVlRGF0YVwiIGF1dG9HZW5lcmF0ZT1cImZhbHNlXCI+XG4gKiAgIDxpZ3gtY29sdW1uIGZpZWxkPVwiZmlyc3RcIiBoZWFkZXI9XCJGaXJzdCBOYW1lXCI+PC9pZ3gtY29sdW1uPlxuICogICA8aWd4LWNvbHVtbiBmaWVsZD1cImxhc3RcIiBoZWFkZXI9XCJMYXN0IE5hbWVcIj48L2lneC1jb2x1bW4+XG4gKiAgIDxpZ3gtY29sdW1uIGZpZWxkPVwicm9sZVwiIGhlYWRlcj1cIlJvbGVcIj48L2lneC1jb2x1bW4+XG4gKiA8L2lneC1ncmlkPlxuICogYGBgXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgIHByZXNlcnZlV2hpdGVzcGFjZXM6IGZhbHNlLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICBJZ3hHcmlkTmF2aWdhdGlvblNlcnZpY2UsXG4gICAgICAgIElneEdyaWRTdW1tYXJ5U2VydmljZSxcbiAgICAgICAgSWd4R3JpZFNlbGVjdGlvblNlcnZpY2UsXG4gICAgICAgIElneEdyaWRDUlVEU2VydmljZSxcbiAgICAgICAgeyBwcm92aWRlOiBHcmlkQmFzZUFQSVNlcnZpY2UsIHVzZUNsYXNzOiBJZ3hHcmlkQVBJU2VydmljZSB9LFxuICAgICAgICB7IHByb3ZpZGU6IElneEdyaWRCYXNlQ29tcG9uZW50LCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBJZ3hHcmlkQ29tcG9uZW50KSB9LFxuICAgICAgICBJZ3hGaWx0ZXJpbmdTZXJ2aWNlLFxuICAgICAgICBJZ3hDb2x1bW5SZXNpemluZ1NlcnZpY2UsXG4gICAgICAgIElneEZvck9mU3luY1NlcnZpY2UsXG4gICAgICAgIElneEZvck9mU2Nyb2xsU3luY1NlcnZpY2UsXG4gICAgICAgIElneFJvd0lzbGFuZEFQSVNlcnZpY2VcbiAgICBdLFxuICAgIHNlbGVjdG9yOiAnaWd4LWdyaWQnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9ncmlkLmNvbXBvbmVudC5odG1sJ1xufSlcbmV4cG9ydCBjbGFzcyBJZ3hHcmlkQ29tcG9uZW50IGV4dGVuZHMgSWd4R3JpZEJhc2VDb21wb25lbnQgaW1wbGVtZW50cyBJR3JpZERhdGFCaW5kYWJsZSwgT25Jbml0LCBEb0NoZWNrLCBBZnRlckNvbnRlbnRJbml0IHtcbiAgICBwcml2YXRlIF9pZCA9IGBpZ3gtZ3JpZC0ke05FWFRfSUQrK31gO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdyb3VwaW5nUmVzdWx0OiBhbnlbXTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdyb3VwaW5nTWV0YWRhdGE6IGFueVtdO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgZ3JvdXBpbmdGbGF0UmVzdWx0OiBhbnlbXTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9ncm91cGluZ0V4cHJlc3Npb25zOiBJR3JvdXBpbmdFeHByZXNzaW9uW10gPSBbXTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9ncm91cGluZ0V4cGFuZFN0YXRlOiBJR3JvdXBCeUV4cGFuZFN0YXRlW10gPSBbXTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9ncm91cFJvd1RlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2dyb3VwQXJlYVRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZ3JvdXBpbmdEaWZmZXI7XG4gICAgcHJpdmF0ZSBfZGF0YTtcbiAgICBwcml2YXRlIF9oaWRlR3JvdXBlZENvbHVtbnMgPSBmYWxzZTtcbiAgICBwcml2YXRlIF9kcm9wQXJlYU1lc3NhZ2UgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgdmFsdWUgb2YgdGhlIGBpZGAgYXR0cmlidXRlLiBJZiBub3QgcHJvdmlkZWQgaXQgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1ncmlkIFtpZF09XCInaWd4LWdyaWQtMSdcIiBbZGF0YV09XCJEYXRhXCIgW2F1dG9HZW5lcmF0ZV09XCJ0cnVlXCI+PC9pZ3gtZ3JpZD5cbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneEdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuaWQnKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBpZCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5faWQ7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgaWQodmFsdWU6IHN0cmluZykge1xuICAgICAgICB0aGlzLl9pZCA9IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IGxldHMgeW91IGZpbGwgdGhlIGBJZ3hHcmlkQ29tcG9uZW50YCB3aXRoIGFuIGFycmF5IG9mIGRhdGEuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZCBbZGF0YV09XCJEYXRhXCIgW2F1dG9HZW5lcmF0ZV09XCJ0cnVlXCI+PC9pZ3gtZ3JpZD5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4R3JpZENvbXBvbmVudFxuICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IGRhdGEoKTogYW55W10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IGRhdGEodmFsdWU6IGFueVtdKSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSB2YWx1ZSB8fCBbXTtcbiAgICAgICAgdGhpcy5zdW1tYXJ5U2VydmljZS5jbGVhclN1bW1hcnlDYWNoZSgpO1xuICAgICAgICBpZiAodGhpcy5zaG91bGRHZW5lcmF0ZSkge1xuICAgICAgICAgICAgdGhpcy5zZXR1cENvbHVtbnMoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIG9iamVjdHMgY29udGFpbmluZyB0aGUgZmlsdGVyZWQgZGF0YSBpbiB0aGUgYElneEdyaWRDb21wb25lbnRgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgZmlsdGVyZWREYXRhID0gdGhpcy5ncmlkLmZpbHRlcmVkRGF0YTtcbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneEdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBnZXQgZmlsdGVyZWREYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmlsdGVyZWREYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgYW4gYXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIHRoZSBmaWx0ZXJlZCBkYXRhIGluIHRoZSBgSWd4R3JpZENvbXBvbmVudGAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuZ3JpZC5maWx0ZXJlZERhdGEgPSBbe1xuICAgICAqICAgICAgIElEOiAxLFxuICAgICAqICAgICAgIE5hbWU6IFwiQVwiXG4gICAgICogfV07XG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgc2V0IGZpbHRlcmVkRGF0YSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9maWx0ZXJlZERhdGEgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdGF0ZSBvZiB0aGUgZ3JpZCB2aXJ0dWFsaXphdGlvbiwgaW5jbHVkaW5nIHRoZSBzdGFydCBpbmRleCBhbmQgaG93IG1hbnkgcmVjb3JkcyBhcmUgcmVuZGVyZWQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGdyaWRWaXJ0U3RhdGUgPSB0aGlzLmdyaWQxLnZpcnR1YWxpemF0aW9uU3RhdGU7XG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IHZpcnR1YWxpemF0aW9uU3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLnN0YXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBzZXQgdmlydHVhbGl6YXRpb25TdGF0ZShzdGF0ZSkge1xuICAgICAgICB0aGlzLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLnN0YXRlID0gc3RhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdG90YWwgbnVtYmVyIG9mIHJlY29yZHMgaW4gdGhlIGRhdGEgc291cmNlLlxuICAgICAqIFRoaXMgcHJvcGVydHkgaXMgcmVxdWlyZWQgZm9yIHJlbW90ZSBncmlkIHZpcnR1YWxpemF0aW9uIHRvIGZ1bmN0aW9uIHdoZW4gaXQgaXMgYm91bmQgdG8gcmVtb3RlIGRhdGEuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuZ3JpZDEudG90YWxJdGVtQ291bnQgPSA1NTtcbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneEdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBzZXQgdG90YWxJdGVtQ291bnQoY291bnQpIHtcbiAgICAgICAgdGhpcy52ZXJ0aWNhbFNjcm9sbENvbnRhaW5lci50b3RhbEl0ZW1Db3VudCA9IGNvdW50O1xuICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdG90YWwgbnVtYmVyIG9mIHJlY29yZHMgaW4gdGhlIGRhdGEgc291cmNlLlxuICAgICAqIFdvcmtzIG9ubHkgd2l0aCByZW1vdGUgZ3JpZCB2aXJ0dWFsaXphdGlvbi5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgaXRlbUNvdW50ID0gdGhpcy5ncmlkMS50b3RhbEl0ZW1Db3VudDtcbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneEdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBnZXQgdG90YWxJdGVtQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLnRvdGFsSXRlbUNvdW50O1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0IF9ncmlkQVBJKCk6IElneEdyaWRBUElTZXJ2aWNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZEFQSSBhcyBJZ3hHcmlkQVBJU2VydmljZTtcbiAgICB9XG4gICAgcHJpdmF0ZSBfZmlsdGVyZWREYXRhID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGdyb3VwIGJ5IHN0YXRlIG9mIHRoZSBgSWd4R3JpZENvbXBvbmVudGAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBncm91cEJ5U3RhdGUgPSB0aGlzLmdyaWQuZ3JvdXBpbmdFeHByZXNzaW9ucztcbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneEdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGdldCBncm91cGluZ0V4cHJlc3Npb25zKCk6IElHcm91cGluZ0V4cHJlc3Npb25bXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ncm91cGluZ0V4cHJlc3Npb25zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGdyb3VwIGJ5IHN0YXRlIG9mIHRoZSBgSWd4R3JpZENvbXBvbmVudGAgYW5kIGVtaXRzIHRoZSBgb25Hcm91cGluZ0RvbmVgXG4gICAgICogZXZlbnQgd2l0aCB0aGUgYXBwcm9wcmlhdGUgYXJndW1lbnRzLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmdyaWQuZ3JvdXBpbmdFeHByZXNzaW9ucyA9IFt7XG4gICAgICogICAgIGZpZWxkTmFtZTogXCJJRFwiLFxuICAgICAqICAgICBkaXI6IFNvcnRpbmdEaXJlY3Rpb24uQXNjLFxuICAgICAqICAgICBpZ25vcmVDYXNlOiBmYWxzZVxuICAgICAqIH1dO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVHdvLXdheSBkYXRhIGJpbmRpbmcuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZCAjZ3JpZCBbZGF0YV09XCJEYXRhXCIgW2F1dG9HZW5lcmF0ZV09XCJ0cnVlXCIgWyhncm91cGluZ0V4cHJlc3Npb25zKV09XCJtb2RlbC5ncm91cGluZ0V4cHJlc3Npb25zXCI+PC9pZ3gtZ3JpZD5cbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneEdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBzZXQgZ3JvdXBpbmdFeHByZXNzaW9ucyh2YWx1ZTogSUdyb3VwaW5nRXhwcmVzc2lvbltdKSB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5sZW5ndGggPiAxMCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ01heGltdW0gYW1vdW50IG9mIGdyb3VwZWQgY29sdW1ucyBpcyAxMC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbGRFeHByZXNzaW9uczogSUdyb3VwaW5nRXhwcmVzc2lvbltdID0gdGhpcy5ncm91cGluZ0V4cHJlc3Npb25zO1xuICAgICAgICBjb25zdCBuZXdFeHByZXNzaW9uczogSUdyb3VwaW5nRXhwcmVzc2lvbltdID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX2dyb3VwaW5nRXhwcmVzc2lvbnMgPSBjbG9uZUFycmF5KHZhbHVlKTtcbiAgICAgICAgdGhpcy5ncm91cGluZ0V4cHJlc3Npb25zQ2hhbmdlLmVtaXQodGhpcy5fZ3JvdXBpbmdFeHByZXNzaW9ucyk7XG4gICAgICAgIHRoaXMuY2hpcHNHb3VwaW5nRXhwcmVzc2lvbnMgPSBjbG9uZUFycmF5KHZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMuX2dyaWRBUEkuZ3JpZCkge1xuICAgICAgICAgICAgLyogZ3JvdXBpbmcgc2hvdWxkIHdvcmsgaW4gY29uanVuY3Rpb24gd2l0aCBzb3J0aW5nXG4gICAgICAgICAgICBhbmQgd2l0aG91dCBvdmVycmlkaW5nIHNlcGFyYXRlIHNvcnRpbmcgZXhwcmVzc2lvbnMgKi9cbiAgICAgICAgICAgIHRoaXMuX2FwcGx5R3JvdXBpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuX2dyaWRBUEkuYXJyYW5nZV9zb3J0aW5nX2V4cHJlc3Npb25zKCk7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeUNoYW5nZXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNldHRlciBjYWxsZWQgYmVmb3JlIGdyaWQgaXMgcmVnaXN0ZXJlZCBpbiBncmlkIEFQSSBzZXJ2aWNlXG4gICAgICAgICAgICB0aGlzLnNvcnRpbmdFeHByZXNzaW9ucy51bnNoaWZ0LmFwcGx5KHRoaXMuc29ydGluZ0V4cHJlc3Npb25zLCB0aGlzLl9ncm91cGluZ0V4cHJlc3Npb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2luaXQgJiYgSlNPTi5zdHJpbmdpZnkob2xkRXhwcmVzc2lvbnMpICE9PSBKU09OLnN0cmluZ2lmeShuZXdFeHByZXNzaW9ucykgJiYgdGhpcy5jb2x1bW5MaXN0KSB7XG4gICAgICAgICAgICBjb25zdCBncm91cGVkQ29sczogSWd4Q29sdW1uQ29tcG9uZW50W10gPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHVuZ3JvdXBlZENvbHM6IElneENvbHVtbkNvbXBvbmVudFtdID0gW107XG4gICAgICAgICAgICBjb25zdCBncm91cGVkQ29sc0FyciA9IG5ld0V4cHJlc3Npb25zLmZpbHRlcigob2JqKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFvbGRFeHByZXNzaW9ucy5zb21lKChvYmoyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmouZmllbGROYW1lID09PSBvYmoyLmZpZWxkTmFtZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ3JvdXBlZENvbHNBcnIuZm9yRWFjaCgoZWxlbSkgPT4ge1xuICAgICAgICAgICAgICAgIGdyb3VwZWRDb2xzLnB1c2godGhpcy5nZXRDb2x1bW5CeU5hbWUoZWxlbS5maWVsZE5hbWUpKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgdW5ncm91cGVkQ29sc0FyciA9IG9sZEV4cHJlc3Npb25zLmZpbHRlcigob2JqKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFuZXdFeHByZXNzaW9ucy5zb21lKChvYmoyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmouZmllbGROYW1lID09PSBvYmoyLmZpZWxkTmFtZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdW5ncm91cGVkQ29sc0Fyci5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgdW5ncm91cGVkQ29scy5wdXNoKHRoaXMuZ2V0Q29sdW1uQnlOYW1lKGVsZW0uZmllbGROYW1lKSk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5Q2hhbmdlcygpO1xuICAgICAgICAgICAgY29uc3QgZ3JvdXBpbmdEb25lQXJnczogSUdyb3VwaW5nRG9uZUV2ZW50QXJncyA9IHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uczogbmV3RXhwcmVzc2lvbnMsXG4gICAgICAgICAgICAgICAgZ3JvdXBlZENvbHVtbnM6IGdyb3VwZWRDb2xzLFxuICAgICAgICAgICAgICAgIHVuZ3JvdXBlZENvbHVtbnM6IHVuZ3JvdXBlZENvbHNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLm9uR3JvdXBpbmdEb25lLmVtaXQoZ3JvdXBpbmdEb25lQXJncyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKkBoaWRkZW5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgZ3JvdXBpbmdFeHByZXNzaW9uc0NoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8SUdyb3VwaW5nRXhwcmVzc2lvbltdPigpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgZXhwYW5zaW9uIHN0YXRlcyBmb3IgZ3JvdXAgcm93cy5cbiAgICAgKiBJbmNsdWRlcyBvbmx5IHN0YXRlcyB0aGF0IGRpZmZlciBmcm9tIHRoZSBkZWZhdWx0IG9uZSAoY29udHJvbGxlZCB0aHJvdWdoIGdyb3Vwc0V4cGFuZGVkIGFuZCBzdGF0ZXMgdGhhdCB0aGUgdXNlciBoYXMgY2hhbmdlZC5cbiAgICAgKiBDb250YWlucyB0aGUgZXhwYW5zaW9uIHN0YXRlIChleHBhbmRlZDogYm9vbGVhbikgYW5kIHRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGdyb3VwIHJvdyAoQXJyYXkpLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBncm91cEV4cFN0YXRlID0gdGhpcy5ncmlkLmdyb3VwaW5nRXhwYW5zaW9uU3RhdGU7XG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBnZXQgZ3JvdXBpbmdFeHBhbnNpb25TdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyb3VwaW5nRXhwYW5kU3RhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIGxpc3Qgb2YgZXhwYW5zaW9uIHN0YXRlcyBmb3IgZ3JvdXAgcm93cy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogICAgICB0aGlzLmdyaWQuZ3JvdXBpbmdFeHBhbnNpb25TdGF0ZSA9IFt7XG4gICAgICogICAgICBleHBhbmRlZDogZmFsc2UsXG4gICAgICogICAgICBoaWVyYXJjaHk6IFt7IGZpZWxkTmFtZTogJ0lEJywgdmFsdWU6IDEgfV1cbiAgICAgKiAgIH1dO1xuICAgICAqIC8vIFlvdSBjYW4gdXNlIERhdGFVdGlsLmdldEhpZXJhcmNoeShncm91cFJvdykgdG8gZ2V0IHRoZSBncm91cCBgSWd4R3JpZFJvd0NvbXBvbmVudGAgaGllcmFyY2h5LlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVHdvLXdheSBkYXRhIGJpbmRpbmcuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZCAjZ3JpZCBbZGF0YV09XCJEYXRhXCIgW2F1dG9HZW5lcmF0ZV09XCJ0cnVlXCIgWyhncm91cGluZ0V4cGFuc2lvblN0YXRlKV09XCJtb2RlbC5ncm91cGluZ0V4cGFuc2lvblN0YXRlXCI+PC9pZ3gtZ3JpZD5cbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneEdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBzZXQgZ3JvdXBpbmdFeHBhbnNpb25TdGF0ZSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX2dyb3VwaW5nRXhwYW5kU3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBpbmdFeHBhbnNpb25TdGF0ZUNoYW5nZS5lbWl0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ncm91cGluZ0V4cGFuZFN0YXRlID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLmdyaWRBUEkuZ3JpZCkge1xuICAgICAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGdyb3VwaW5nRXhwYW5zaW9uU3RhdGVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPElHcm91cEJ5RXhwYW5kU3RhdGVbXT4oKTtcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IGRldGVybWluZXMgd2hldGhlciBjcmVhdGVkIGdyb3VwcyBhcmUgcmVuZGVyZWQgZXhwYW5kZWQgb3IgY29sbGFwc2VkLlxuICAgICAqIFRoZSBkZWZhdWx0IHJlbmRlcmVkIHN0YXRlIGlzIGV4cGFuZGVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQgI2dyaWQgW2RhdGFdPVwiRGF0YVwiIFtncm91cHNFeHBhbmRlZF09XCJmYWxzZVwiIFthdXRvR2VuZXJhdGVdPVwidHJ1ZVwiPjwvaWd4LWdyaWQ+XG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ3JvdXBzRXhwYW5kZWQgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQSBoaWVyYXJjaGljYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdyb3VwIGJ5IHJlY29yZHMuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBncm91cFJlY29yZHMgPSB0aGlzLmdyaWQuZ3JvdXBzUmVjb3JkcztcbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneEdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgZ3JvdXBzUmVjb3JkczogSUdyb3VwQnlSZWNvcmRbXSA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB3aGV0aGVyIHRoZSBncm91cGVkIGNvbHVtbnMgc2hvdWxkIGJlIGhpZGRlbiBhcyB3ZWxsLlxuICAgICAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIFwiZmFsc2VcIlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQgI2dyaWQgW2RhdGFdPVwibG9jYWxEYXRhXCIgW2hpZGVHcm91cGVkQ29sdW1uc109XCJ0cnVlXCIgW2F1dG9HZW5lcmF0ZV09XCJ0cnVlXCI+PC9pZ3gtZ3JpZD5cbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneEdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgaGlkZUdyb3VwZWRDb2x1bW5zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGlkZUdyb3VwZWRDb2x1bW5zO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgaGlkZUdyb3VwZWRDb2x1bW5zKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5ncm91cGluZ0RpZmZlciA9IHRoaXMuZGlmZmVycy5maW5kKHRoaXMuZ3JvdXBpbmdFeHByZXNzaW9ucykuY3JlYXRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmdyb3VwaW5nRGlmZmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb2x1bW5MaXN0ICYmIHRoaXMuZ3JvdXBpbmdFeHByZXNzaW9ucykge1xuICAgICAgICAgICAgdGhpcy5fc2V0R3JvdXBDb2xzVmlzaWJpbGl0eSh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9oaWRlR3JvdXBlZENvbHVtbnMgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSBtZXNzYWdlIGRpc3BsYXllZCBpbnNpZGUgdGhlIEdyb3VwQnkgZHJvcCBhcmVhIHdoZXJlIGNvbHVtbnMgY2FuIGJlIGRyYWdnZWQgb24uXG4gICAgICogTm90ZTogVGhlIGdyaWQgbmVlZHMgdG8gaGF2ZSBhdCBsZWFzdCBvbmUgZ3JvdXBhYmxlIGNvbHVtbiBpbiBvcmRlciB0aGUgR3JvdXBCeSBhcmVhIHRvIGJlIGRpc3BsYXllZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1ncmlkIGRyb3BBcmVhTWVzc2FnZT1cIkRyb3AgaGVyZSB0byBncm91cCFcIj5cbiAgICAgKiAgICAgIDxpZ3gtY29sdW1uIFtncm91cGFibGVdPVwidHJ1ZVwiIGZpZWxkPVwiSURcIj48L2lneC1jb2x1bW4+XG4gICAgICogPC9pZ3gtZ3JpZD5cbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneEdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNldCBkcm9wQXJlYU1lc3NhZ2UodmFsdWU6IHN0cmluZykge1xuICAgICAgICB0aGlzLl9kcm9wQXJlYU1lc3NhZ2UgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5ub3RpZnlDaGFuZ2VzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gYWNjZXNzb3IgdGhhdCByZXR1cm5zIHRoZSBtZXNzYWdlIGRpc3BsYXllZCBpbnNpZGUgdGhlIEdyb3VwQnkgZHJvcCBhcmVhIHdoZXJlIGNvbHVtbnMgY2FuIGJlIGRyYWdnZWQgb24uXG4gICAgKi9cbiAgICBnZXQgZHJvcEFyZWFNZXNzYWdlKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kcm9wQXJlYU1lc3NhZ2UgfHwgdGhpcy5yZXNvdXJjZVN0cmluZ3MuaWd4X2dyaWRfZ3JvdXBCeUFyZWFfbWVzc2FnZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSB0ZW1wbGF0ZSB0aGF0IHdpbGwgYmUgcmVuZGVyZWQgYXMgYSBHcm91cEJ5IGRyb3AgYXJlYS5cbiAgICAgKiBOb3RlOiBUaGUgZ3JpZCBuZWVkcyB0byBoYXZlIGF0IGxlYXN0IG9uZSBncm91cGFibGUgY29sdW1uIGluIG9yZGVyIHRoZSBHcm91cEJ5IGFyZWEgdG8gYmUgZGlzcGxheWVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQgW2Ryb3BBcmVhVGVtcGxhdGVdPVwiZHJvcEFyZWFSZWZcIj5cbiAgICAgKiAgICAgIDxpZ3gtY29sdW1uIFtncm91cGFibGVdPVwidHJ1ZVwiIGZpZWxkPVwiSURcIj48L2lneC1jb2x1bW4+XG4gICAgICogPC9pZ3gtZ3JpZD5cbiAgICAgKiA8bmctdGVtcGxhdGUgI215RHJvcEFyZWE+XG4gICAgICogICAgICA8c3Bhbj4gQ3VzdG9tIGRyb3AgYXJlYSEgPC9zcGFuPlxuICAgICAqIDwvbmctdGVtcGxhdGU+XG4gICAgICogYGBgXG4gICAgICogYGBgdHNcbiAgICAgKiBAVmlld0NoaWxkKCdteURyb3BBcmVhJywgeyByZWFkOiBUZW1wbGF0ZVJlZiB9KVxuICAgICAqIHB1YmxpYyBkcm9wQXJlYVJlZjogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneEdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBkcm9wQXJlYVRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIGEgbmV3IGBJZ3hDb2x1bW5Db21wb25lbnRgIGdldHMgZ3JvdXBlZC91bmdyb3VwZWQsIG9yIG11bHRpcGxlIGNvbHVtbnMgZ2V0XG4gICAgICogZ3JvdXBlZC91bmdyb3VwZWQgYXQgb25jZSBieSB1c2luZyB0aGUgR3JvdXAgQnkgQVBJLlxuICAgICAqIFRoZSBgb25Hcm91cGluZ0RvbmVgIGV2ZW50IHdvdWxkIGJlIHJhaXNlZCBvbmx5IG9uY2UgaWYgc2V2ZXJhbCBjb2x1bW5zIGdldCBncm91cGVkIGF0IG9uY2UgYnkgY2FsbGluZ1xuICAgICAqIHRoZSBgZ3JvdXBCeSgpYCBvciBgY2xlYXJHcm91cGluZygpYCBBUEkgbWV0aG9kcyBhbmQgcGFzc2luZyBhbiBhcnJheSBhcyBhbiBhcmd1bWVudC5cbiAgICAgKiBUaGUgZXZlbnQgYXJndW1lbnRzIHByb3ZpZGUgdGhlIGBleHByZXNzaW9uc2AsIGBncm91cGVkQ29sdW1uc2AgYW5kIGB1bmdyb3VwZWRDb2x1bW5zYCBwcm9wZXJ0aWVzLCB3aGljaCBjb250YWluXG4gICAgICogdGhlIGBJU29ydGluZ0V4cHJlc3Npb25gIGFuZCB0aGUgYElneENvbHVtbkNvbXBvbmVudGAgcmVsYXRlZCB0byB0aGUgZ3JvdXBpbmcvdW5ncm91cGluZyBvcGVyYXRpb24uXG4gICAgICogUGxlYXNlIG5vdGUgdGhhdCBgZ3JvdXBlZENvbHVtbnNgIGFuZCBgdW5ncm91cGVkQ29sdW1uc2Agc2hvdyBvbmx5IHRoZSAqKm5ld2x5KiogY2hhbmdlZCBjb2x1bW5zIChhZmZlY3RlZCBieSB0aGUgKipsYXN0KipcbiAgICAgKiBncm91cGluZy91bmdyb3VwaW5nIG9wZXJhdGlvbiksIG5vdCBhbGwgY29sdW1ucyB3aGljaCBhcmUgY3VycmVudGx5IGdyb3VwZWQvdW5ncm91cGVkLlxuICAgICAqIGNvbHVtbnMuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGdyb3VwaW5nRG9uZShldmVudDogSUdyb3VwaW5nRG9uZUV2ZW50QXJncyl7XG4gICAgICogICAgIGNvbnN0IGV4cHJlc3Npb25zID0gZXZlbnQuZXhwcmVzc2lvbnM7XG4gICAgICogICAgIC8vdGhlIG5ld2x5IGdyb3VwZWQgY29sdW1uc1xuICAgICAqICAgICBjb25zdCBncm91cGVkQ29sdW1ucyA9IGV2ZW50Lmdyb3VwZWRDb2x1bW5zO1xuICAgICAqICAgICAvL3RoZSBuZXdseSB1bmdyb3VwZWQgY29sdW1uc1xuICAgICAqICAgICBjb25zdCB1bmdyb3VwZWRDb2x1bW5zID0gZXZlbnQudW5ncm91cGVkQ29sdW1ucztcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZCAjZ3JpZCBbZGF0YV09XCJsb2NhbERhdGFcIiAob25Hcm91cGluZ0RvbmUpPVwiZ3JvdXBpbmdEb25lKCRldmVudClcIiBbYXV0b0dlbmVyYXRlXT1cInRydWVcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4R3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBvbkdyb3VwaW5nRG9uZSA9IG5ldyBFdmVudEVtaXR0ZXI8SUdyb3VwaW5nRG9uZUV2ZW50QXJncz4oKTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKElneEdyb3VwQnlSb3dUZW1wbGF0ZURpcmVjdGl2ZSwgeyByZWFkOiBJZ3hHcm91cEJ5Um93VGVtcGxhdGVEaXJlY3RpdmUsIHN0YXRpYzogZmFsc2UgfSlcbiAgICBwcm90ZWN0ZWQgZ3JvdXBUZW1wbGF0ZTogSWd4R3JvdXBCeVJvd1RlbXBsYXRlRGlyZWN0aXZlO1xuXG4gICAgQFZpZXdDaGlsZHJlbihJZ3hHcmlkR3JvdXBCeVJvd0NvbXBvbmVudCwgeyByZWFkOiBJZ3hHcmlkR3JvdXBCeVJvd0NvbXBvbmVudCB9KVxuICAgIHByaXZhdGUgX2dyb3Vwc1Jvd0xpc3Q6IFF1ZXJ5TGlzdDxJZ3hHcmlkR3JvdXBCeVJvd0NvbXBvbmVudD47XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgnZGVmYXVsdERyb3BBcmVhJywgeyByZWFkOiBUZW1wbGF0ZVJlZiwgc3RhdGljOiB0cnVlIH0pXG4gICAgcHVibGljIGRlZmF1bHREcm9wQXJlYVRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogQSBsaXN0IG9mIGFsbCBncm91cCByb3dzLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBncm91cExpc3QgPSB0aGlzLmdyaWQuZ3JvdXBzUm93TGlzdDtcbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneEdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGdyb3Vwc1Jvd0xpc3QoKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBRdWVyeUxpc3Q8YW55PigpO1xuICAgICAgICBpZiAoIXRoaXMuX2dyb3Vwc1Jvd0xpc3QpIHtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgckxpc3QgPSB0aGlzLl9ncm91cHNSb3dMaXN0LmZpbHRlcigoaXRlbSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uZWxlbWVudC5uYXRpdmVFbGVtZW50LnBhcmVudEVsZW1lbnQgIT09IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgICByZXMucmVzZXQockxpc3QpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCdncm91cEFyZWEnLCB7IHN0YXRpYzogZmFsc2UgfSlcbiAgICBwdWJsaWMgZ3JvdXBBcmVhOiBFbGVtZW50UmVmO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBncm91cEFyZWFIb3N0Q2xhc3MoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcG9uZW50RGVuc2l0eUNsYXNzKCdpZ3gtZHJvcC1hcmVhJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdGVtcGxhdGUgcmVmZXJlbmNlIG9mIHRoZSBgSWd4R3JpZENvbXBvbmVudGAncyBncm91cCByb3cuXG4gICAgICogYGBgXG4gICAgICogY29uc3QgZ3JvdXBSb3dUZW1wbGF0ZSA9IHRoaXMuZ3JpZC5ncm91cFJvd1RlbXBsYXRlO1xuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4R3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIGdldCBncm91cFJvd1RlbXBsYXRlKCk6IFRlbXBsYXRlUmVmPGFueT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXBSb3dUZW1wbGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB0ZW1wbGF0ZSByZWZlcmVuY2Ugb2YgdGhlIGBJZ3hHcmlkQ29tcG9uZW50YCdzIGdyb3VwIGBJZ3hHcmlkUm93Q29tcG9uZW50YC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5ncmlkLmdyb3VwUm93VGVtcGxhdGUgPSBteVJvd1RlbXBsYXRlLlxuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4R3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIHNldCBncm91cFJvd1RlbXBsYXRlKHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+KSB7XG4gICAgICAgIHRoaXMuX2dyb3VwUm93VGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICAgICAgdGhpcy5ub3RpZnlDaGFuZ2VzKCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0ZW1wbGF0ZSByZWZlcmVuY2Ugb2YgdGhlIGBJZ3hHcmlkQ29tcG9uZW50YCdzIGdyb3VwIGFyZWEuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGdyb3VwQXJlYVRlbXBsYXRlID0gdGhpcy5ncmlkLmdyb3VwQXJlYVRlbXBsYXRlO1xuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4R3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIGdldCBncm91cEFyZWFUZW1wbGF0ZSgpOiBUZW1wbGF0ZVJlZjxhbnk+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyb3VwQXJlYVRlbXBsYXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHRlbXBsYXRlIHJlZmVyZW5jZSBvZiB0aGUgYElneEdyaWRDb21wb25lbnRgJ3MgZ3JvdXAgYXJlYS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5ncmlkLmdyb3VwQXJlYVRlbXBsYXRlID0gbXlBcmVhVGVtcGxhdGUuXG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgc2V0IGdyb3VwQXJlYVRlbXBsYXRlKHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+KSB7XG4gICAgICAgIHRoaXMuX2dyb3VwQXJlYVRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICAgIHRoaXMubm90aWZ5Q2hhbmdlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdyb3VwcyBieSBhIG5ldyBgSWd4Q29sdW1uQ29tcG9uZW50YCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgZXhwcmVzc2lvbiwgb3IgbW9kaWZpZXMgYW4gZXhpc3Rpbmcgb25lLlxuICAgICAqIEFsc28gYWxsb3dzIGZvciBtdWx0aXBsZSBjb2x1bW5zIHRvIGJlIGdyb3VwZWQgYXQgb25jZSBpZiBhbiBhcnJheSBvZiBgSVNvcnRpbmdFeHByZXNzaW9uYCBpcyBwYXNzZWQuXG4gICAgICogVGhlIG9uR3JvdXBpbmdEb25lIGV2ZW50IHdvdWxkIGdldCByYWlzZWQgb25seSAqKm9uY2UqKiBpZiB0aGlzIG1ldGhvZCBnZXRzIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIHRoZSBzYW1lIGFyZ3VtZW50cy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5ncmlkLmdyb3VwQnkoeyBmaWVsZE5hbWU6IG5hbWUsIGRpcjogU29ydGluZ0RpcmVjdGlvbi5Bc2MsIGlnbm9yZUNhc2U6IGZhbHNlIH0pO1xuICAgICAqIHRoaXMuZ3JpZC5ncm91cEJ5KFtcbiAgICAgICAgICAgIHsgZmllbGROYW1lOiBuYW1lMSwgZGlyOiBTb3J0aW5nRGlyZWN0aW9uLkFzYywgaWdub3JlQ2FzZTogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgZmllbGROYW1lOiBuYW1lMiwgZGlyOiBTb3J0aW5nRGlyZWN0aW9uLkRlc2MsIGlnbm9yZUNhc2U6IHRydWUgfSxcbiAgICAgICAgICAgIHsgZmllbGROYW1lOiBuYW1lMywgZGlyOiBTb3J0aW5nRGlyZWN0aW9uLkRlc2MsIGlnbm9yZUNhc2U6IGZhbHNlIH1cbiAgICAgICAgXSk7XG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIGdyb3VwQnkoZXhwcmVzc2lvbjogSUdyb3VwaW5nRXhwcmVzc2lvbiB8IEFycmF5PElHcm91cGluZ0V4cHJlc3Npb24+KTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrSWZOb0NvbHVtbkZpZWxkKGV4cHJlc3Npb24pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbmRFZGl0KHRydWUpO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICB0aGlzLl9ncmlkQVBJLmdyb3VwQnlfbXVsdGlwbGUoZXhwcmVzc2lvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9ncmlkQVBJLmdyb3VwQnkoZXhwcmVzc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub3RpZnlDaGFuZ2VzKHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgZ3JvdXBpbmcgaW4gdGhlIGdyaWQsIGlmIG5vIHBhcmFtZXRlciBpcyBwYXNzZWQuXG4gICAgICogSWYgYSBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQsIGNsZWFycyBncm91cGluZyBmb3IgYSBwYXJ0aWN1bGFyIGNvbHVtbiBvciBhbiBhcnJheSBvZiBjb2x1bW5zLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmdyaWQuY2xlYXJHcm91cGluZygpOyAvL2NsZWFycyBhbGwgZ3JvdXBpbmdcbiAgICAgKiB0aGlzLmdyaWQuY2xlYXJHcm91cGluZyhcIklEXCIpOyAvL3VuZ3JvdXBzIGEgc2luZ2xlIGNvbHVtblxuICAgICAqIHRoaXMuZ3JpZC5jbGVhckdyb3VwaW5nKFtcIklEXCIsIFwiQ29sdW1uMVwiLCBcIkNvbHVtbjJcIl0pOyAvL3VuZ3JvdXBzIG11bHRpcGxlIGNvbHVtbnNcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqL1xuICAgIHB1YmxpYyBjbGVhckdyb3VwaW5nKG5hbWU/OiBzdHJpbmcgfCBBcnJheTxzdHJpbmc+KTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2dyaWRBUEkuY2xlYXJfZ3JvdXBieShuYW1lKTtcbiAgICAgICAgdGhpcy5ub3RpZnlDaGFuZ2VzKHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWYgYSBncm91cCBpcyBleHBhbmRlZCBvciBub3QuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBncm91cFJvdzogSUdyb3VwQnlSZWNvcmQ7XG4gICAgICogY29uc3QgZXhwYW5kZWRHcm91cCA9IHRoaXMuZ3JpZC5pc0V4cGFuZGVkR3JvdXAodGhpcy5ncm91cFJvdyk7XG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIGlzRXhwYW5kZWRHcm91cChncm91cDogSUdyb3VwQnlSZWNvcmQpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3Qgc3RhdGU6IElHcm91cEJ5RXhwYW5kU3RhdGUgPSB0aGlzLl9nZXRTdGF0ZUZvckdyb3VwUm93KGdyb3VwKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlID8gc3RhdGUuZXhwYW5kZWQgOiB0aGlzLmdyb3Vwc0V4cGFuZGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhlIGV4cGFuc2lvbiBzdGF0ZSBvZiBhIGdyb3VwLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgZ3JvdXBSb3c6IElHcm91cEJ5UmVjb3JkO1xuICAgICAqIGNvbnN0IHRvZ2dsZUV4cEdyb3VwID0gdGhpcy5ncmlkLnRvZ2dsZUdyb3VwKHRoaXMuZ3JvdXBSb3cpO1xuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4R3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyB0b2dnbGVHcm91cChncm91cFJvdzogSUdyb3VwQnlSZWNvcmQpIHtcbiAgICAgICAgdGhpcy5fdG9nZ2xlR3JvdXAoZ3JvdXBSb3cpO1xuICAgICAgICB0aGlzLm5vdGlmeUNoYW5nZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHBhbmRzIHRoZSBzcGVjaWZpZWQgZ3JvdXAgYW5kIGFsbCBvZiBpdHMgcGFyZW50IGdyb3Vwcy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIGdyb3VwUm93OiBJR3JvdXBCeVJlY29yZDtcbiAgICAgKiB0aGlzLmdyaWQuZnVsbHlFeHBhbmRHcm91cCh0aGlzLmdyb3VwUm93KTtcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4R3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBmdWxseUV4cGFuZEdyb3VwKGdyb3VwUm93OiBJR3JvdXBCeVJlY29yZCkge1xuICAgICAgICB0aGlzLl9mdWxseUV4cGFuZEdyb3VwKGdyb3VwUm93KTtcbiAgICAgICAgdGhpcy5ub3RpZnlDaGFuZ2VzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBpc0dyb3VwQnlSZWNvcmQocmVjb3JkOiBhbnkpOiBib29sZWFuIHtcbiAgICAgICAgLy8gcmV0dXJuIHJlY29yZC5yZWNvcmRzIGluc3RhbmNlIG9mIEdyb3VwZWRSZWNvcmRzIGZhaWxzIHVuZGVyIFdlYnBhY2tcbiAgICAgICAgcmV0dXJuIHJlY29yZC5yZWNvcmRzICYmIHJlY29yZC5yZWNvcmRzLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSBleHBhbnNpb24gc3RhdGUgb2YgYWxsIGdyb3VwIHJvd3MgcmVjdXJzaXZlbHkuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuZ3JpZC50b2dnbGVBbGxHcm91cFJvd3M7XG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIHRvZ2dsZUFsbEdyb3VwUm93cygpIHtcbiAgICAgICAgdGhpcy5ncm91cGluZ0V4cGFuc2lvblN0YXRlID0gW107XG4gICAgICAgIHRoaXMuZ3JvdXBzRXhwYW5kZWQgPSAhdGhpcy5ncm91cHNFeHBhbmRlZDtcbiAgICAgICAgdGhpcy5ub3RpZnlDaGFuZ2VzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpZiB0aGUgYElneEdyaWRDb21wb25lbnRgIGhhcyBncm91cGFibGUgY29sdW1ucy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgZ3JvdXBhYmxlR3JpZCA9IHRoaXMuZ3JpZC5oYXNHcm91cGFibGVDb2x1bW5zO1xuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4R3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIGdldCBoYXNHcm91cGFibGVDb2x1bW5zKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5MaXN0LnNvbWUoKGNvbCkgPT4gY29sLmdyb3VwYWJsZSAmJiAhY29sLmNvbHVtbkdyb3VwKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9zZXRHcm91cENvbHNWaXNpYmlsaXR5KHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbkxpc3QgJiYgIXRoaXMuaGFzQ29sdW1uTGF5b3V0cykge1xuICAgICAgICAgICAgdGhpcy5ncm91cGluZ0V4cHJlc3Npb25zLmZvckVhY2goKGV4cHIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2wgPSB0aGlzLmdldENvbHVtbkJ5TmFtZShleHByLmZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgY29sLmhpZGRlbiA9IHZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlmIHRoZSBncmlkJ3MgZ3JvdXAgYnkgZHJvcCBhcmVhIGlzIHZpc2libGUuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGRyb3BWaXNpYmxlID0gdGhpcy5ncmlkLmRyb3BBcmVhVmlzaWJsZTtcbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneEdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGRyb3BBcmVhVmlzaWJsZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmRyYWdnZWRDb2x1bW4gJiYgdGhpcy5kcmFnZ2VkQ29sdW1uLmdyb3VwYWJsZSkgfHxcbiAgICAgICAgICAgICF0aGlzLmNoaXBzR291cGluZ0V4cHJlc3Npb25zLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9nZXRTdGF0ZUZvckdyb3VwUm93KGdyb3VwUm93OiBJR3JvdXBCeVJlY29yZCk6IElHcm91cEJ5RXhwYW5kU3RhdGUge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JpZEFQSS5ncm91cEJ5X2dldF9leHBhbmRlZF9mb3JfZ3JvdXAoZ3JvdXBSb3cpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX3RvZ2dsZUdyb3VwKGdyb3VwUm93OiBJR3JvdXBCeVJlY29yZCkge1xuICAgICAgICB0aGlzLl9ncmlkQVBJLmdyb3VwQnlfdG9nZ2xlX2dyb3VwKGdyb3VwUm93KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9mdWxseUV4cGFuZEdyb3VwKGdyb3VwUm93OiBJR3JvdXBCeVJlY29yZCkge1xuICAgICAgICB0aGlzLl9ncmlkQVBJLmdyb3VwQnlfZnVsbHlfZXhwYW5kX2dyb3VwKGdyb3VwUm93KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9hcHBseUdyb3VwaW5nKCkge1xuICAgICAgICB0aGlzLl9ncmlkQVBJLnNvcnRfbXVsdGlwbGUodGhpcy5fZ3JvdXBpbmdFeHByZXNzaW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBpc0NvbHVtbkdyb3VwZWQoZmllbGROYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXBpbmdFeHByZXNzaW9ucy5maW5kKGV4cCA9PiBleHAuZmllbGROYW1lID09PSBmaWVsZE5hbWUpID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICovXG4gICAgcHVibGljIGdldENvbnRleHQocm93RGF0YSwgcm93SW5kZXgpOiBhbnkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJGltcGxpY2l0OiByb3dEYXRhLFxuICAgICAgICAgICAgaW5kZXg6IHJvd0luZGV4LFxuICAgICAgICAgICAgdGVtcGxhdGVJRDogdGhpcy5pc0dyb3VwQnlSZWNvcmQocm93RGF0YSkgPyAnZ3JvdXBSb3cnIDogdGhpcy5pc1N1bW1hcnlSb3cocm93RGF0YSkgPyAnc3VtbWFyeVJvdycgOiAnZGF0YVJvdydcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqL1xuICAgIHB1YmxpYyBnZXQgdGVtcGxhdGUoKTogVGVtcGxhdGVSZWY8YW55PiB7XG4gICAgICAgIGlmICh0aGlzLmZpbHRlcmVkRGF0YSAmJiB0aGlzLmZpbHRlcmVkRGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVtcHR5R3JpZFRlbXBsYXRlID8gdGhpcy5lbXB0eUdyaWRUZW1wbGF0ZSA6IHRoaXMuZW1wdHlGaWx0ZXJlZEdyaWRUZW1wbGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmlzTG9hZGluZyAmJiAoIXRoaXMuZGF0YSB8fCB0aGlzLmRhdGFMZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2FkaW5nR3JpZFRlbXBsYXRlID8gdGhpcy5sb2FkaW5nR3JpZFRlbXBsYXRlIDogdGhpcy5sb2FkaW5nR3JpZERlZmF1bHRUZW1wbGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmRhdGFMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVtcHR5R3JpZFRlbXBsYXRlID8gdGhpcy5lbXB0eUdyaWRUZW1wbGF0ZSA6IHRoaXMuZW1wdHlHcmlkRGVmYXVsdFRlbXBsYXRlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBvbkNoaXBSZW1vdmVkKGV2ZW50OiBJQmFzZUNoaXBFdmVudEFyZ3MpIHtcbiAgICAgICAgdGhpcy5jbGVhckdyb3VwaW5nKGV2ZW50Lm93bmVyLmlkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGNoaXBzT3JkZXJDaGFuZ2VkKGV2ZW50OiBJQ2hpcHNBcmVhUmVvcmRlckV2ZW50QXJncykge1xuICAgICAgICBjb25zdCBuZXdHcm91cGluZyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50LmNoaXBzQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cHIgPSB0aGlzLmdyb3VwaW5nRXhwcmVzc2lvbnMuZmlsdGVyKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uZmllbGROYW1lID09PSBldmVudC5jaGlwc0FycmF5W2ldLmlkO1xuICAgICAgICAgICAgfSlbMF07XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5nZXRDb2x1bW5CeU5hbWUoZXhwci5maWVsZE5hbWUpLmdyb3VwYWJsZSkge1xuICAgICAgICAgICAgICAgIC8vIGRpc2FsbG93IGNoYW5naW5nIG9yZGVyIGlmIHRoZXJlIGFyZSBjb2x1bW5zIHdpdGggZ3JvdXBhYmxlOiBmYWxzZVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0dyb3VwaW5nLnB1c2goZXhwcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ncm91cGluZ0V4cGFuc2lvblN0YXRlID0gW107XG4gICAgICAgIHRoaXMuY2hpcHNHb3VwaW5nRXhwcmVzc2lvbnMgPSBuZXdHcm91cGluZztcblxuICAgICAgICBpZiAoZXZlbnQub3JpZ2luYWxFdmVudCBpbnN0YW5jZW9mIEtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gcmVvcmRlcmVkIHVzaW5nIGtleWJvYXJkIG5hdmlnYXRpb24sIHdlIGRvbid0IGhhdmUgYG9uTW92ZUVuZGAgZXZlbnQuXG4gICAgICAgICAgICB0aGlzLmdyb3VwaW5nRXhwcmVzc2lvbnMgPSB0aGlzLmNoaXBzR291cGluZ0V4cHJlc3Npb25zO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm90aWZ5Q2hhbmdlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgY2hpcHNNb3ZpbmdFbmRlZCgpIHtcbiAgICAgICAgdGhpcy5ncm91cGluZ0V4cHJlc3Npb25zID0gdGhpcy5jaGlwc0dvdXBpbmdFeHByZXNzaW9ucztcbiAgICAgICAgdGhpcy5ub3RpZnlDaGFuZ2VzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBvbkNoaXBDbGlja2VkKGV2ZW50OiBJQ2hpcENsaWNrRXZlbnRBcmdzKSB7XG4gICAgICAgIGNvbnN0IHNvcnRpbmdFeHByID0gdGhpcy5zb3J0aW5nRXhwcmVzc2lvbnM7XG4gICAgICAgIGNvbnN0IGNvbHVtbkV4cHIgPSBzb3J0aW5nRXhwci5maW5kKChleHByKSA9PiBleHByLmZpZWxkTmFtZSA9PT0gZXZlbnQub3duZXIuaWQpO1xuICAgICAgICBjb2x1bW5FeHByLmRpciA9IDMgLSBjb2x1bW5FeHByLmRpcjtcbiAgICAgICAgdGhpcy5zb3J0KGNvbHVtbkV4cHIpO1xuICAgICAgICB0aGlzLm5vdGlmeUNoYW5nZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG9uQ2hpcEtleURvd24oZXZlbnQ6IElDaGlwS2V5RG93bkV2ZW50QXJncykge1xuICAgICAgICBpZiAoZXZlbnQub3JpZ2luYWxFdmVudC5rZXkgPT09ICcgJyB8fCBldmVudC5vcmlnaW5hbEV2ZW50LmtleSA9PT0gJ1NwYWNlYmFyJyB8fCBldmVudC5vcmlnaW5hbEV2ZW50LmtleSA9PT0gJ0VudGVyJykge1xuICAgICAgICAgICAgY29uc3Qgc29ydGluZ0V4cHIgPSB0aGlzLnNvcnRpbmdFeHByZXNzaW9ucztcbiAgICAgICAgICAgIGNvbnN0IGNvbHVtbkV4cHIgPSBzb3J0aW5nRXhwci5maW5kKChleHByKSA9PiBleHByLmZpZWxkTmFtZSA9PT0gZXZlbnQub3duZXIuaWQpO1xuICAgICAgICAgICAgY29sdW1uRXhwci5kaXIgPSAzIC0gY29sdW1uRXhwci5kaXI7XG4gICAgICAgICAgICB0aGlzLnNvcnQoY29sdW1uRXhwcik7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeUNoYW5nZXMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZ2V0IGRlZmF1bHRUYXJnZXRCb2R5SGVpZ2h0KCk6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IGFsbEl0ZW1zID0gdGhpcy50b3RhbEl0ZW1Db3VudCB8fCB0aGlzLmRhdGFMZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVkUm93SGVpZ2h0ICogTWF0aC5taW4odGhpcy5fZGVmYXVsdFRhcmdldFJlY29yZE51bWJlcixcbiAgICAgICAgICAgIHRoaXMucGFnaW5nID8gTWF0aC5taW4oYWxsSXRlbXMsIHRoaXMucGVyUGFnZSkgOiBhbGxJdGVtcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBnZXRHcm91cEFyZWFIZWlnaHQoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXBBcmVhID8gdGhpcy5ncm91cEFyZWEubmF0aXZlRWxlbWVudC5vZmZzZXRIZWlnaHQgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBHZXRzIHRoZSBjb21iaW5lZCB3aWR0aCBvZiB0aGUgY29sdW1ucyB0aGF0IGFyZSBzcGVjaWZpYyB0byB0aGUgZW5hYmxlZCBncmlkIGZlYXR1cmVzLiBUaGV5IGFyZSBmaXhlZC5cbiAgICAgKiBUT0RPOiBSZW1vdmUgZm9yIEFuZ3VsYXIgOC4gQ2FsbGluZyBwYXJlbnQgY2xhc3MgZ2V0dGVyIHVzaW5nIHN1cGVyIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIG5vdy5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0RmVhdHVyZUNvbHVtbnNXaWR0aCgpIHtcbiAgICAgICAgbGV0IHdpZHRoID0gc3VwZXIuZ2V0RmVhdHVyZUNvbHVtbnNXaWR0aCgpO1xuXG4gICAgICAgIGlmICh0aGlzLmdyb3VwaW5nRXhwcmVzc2lvbnMubGVuZ3RoICYmIHRoaXMuaGVhZGVyR3JvdXBDb250YWluZXIpIHtcbiAgICAgICAgICAgIHdpZHRoICs9IHRoaXMuaGVhZGVyR3JvdXBDb250YWluZXIubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHNjcm9sbFRvKHJvdzogYW55IHwgbnVtYmVyLCBjb2x1bW46IGFueSB8IG51bWJlcik6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5ncm91cGluZ0V4cHJlc3Npb25zICYmIHRoaXMuZ3JvdXBpbmdFeHByZXNzaW9ucy5sZW5ndGhcbiAgICAgICAgICAgICYmIHR5cGVvZihyb3cpICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgY29uc3Qgcm93SW5kZXggPSB0aGlzLmdyb3VwaW5nUmVzdWx0LmluZGV4T2Yocm93KTtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwQnlSZWNvcmQgPSB0aGlzLmdyb3VwaW5nTWV0YWRhdGFbcm93SW5kZXhdO1xuICAgICAgICAgICAgaWYgKGdyb3VwQnlSZWNvcmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mdWxseUV4cGFuZEdyb3VwKGdyb3VwQnlSZWNvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3VwZXIuc2Nyb2xsVG8ocm93LCBjb2x1bW4sIHRoaXMuZ3JvdXBpbmdGbGF0UmVzdWx0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqL1xuICAgIHB1YmxpYyBnZXQgZHJvcEFyZWFUZW1wbGF0ZVJlc29sdmVkKCk6IFRlbXBsYXRlUmVmPGFueT4ge1xuICAgICAgICBpZiAodGhpcy5kcm9wQXJlYVRlbXBsYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kcm9wQXJlYVRlbXBsYXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdERyb3BBcmVhVGVtcGxhdGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldEdyb3VwQnlDaGlwVGl0bGUoZXhwcmVzc2lvbjogSUdyb3VwaW5nRXhwcmVzc2lvbik6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IGNvbHVtbiA9IHRoaXMuZ2V0Q29sdW1uQnlOYW1lKGV4cHJlc3Npb24uZmllbGROYW1lKTtcbiAgICAgICAgcmV0dXJuIChjb2x1bW4gJiYgY29sdW1uLmhlYWRlcikgfHwgZXhwcmVzc2lvbi5maWVsZE5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGljb25UZW1wbGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JvdXBzRXhwYW5kZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhlYWRlckV4cGFuZEluZGljYXRvclRlbXBsYXRlIHx8IHRoaXMuZGVmYXVsdEV4cGFuZGVkVGVtcGxhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oZWFkZXJDb2xsYXBzZUluZGljYXRvclRlbXBsYXRlIHx8IHRoaXMuZGVmYXVsdENvbGxhcHNlZFRlbXBsYXRlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRDb2x1bW5Hcm91cGFibGUoZmllbGROYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgY29sdW1uID0gdGhpcy5nZXRDb2x1bW5CeU5hbWUoZmllbGROYW1lKTtcbiAgICAgICAgcmV0dXJuIGNvbHVtbiAmJiBjb2x1bW4uZ3JvdXBhYmxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICBzdXBlci5uZ0FmdGVyQ29udGVudEluaXQoKTtcbiAgICAgICAgaWYgKHRoaXMuYWxsb3dGaWx0ZXJpbmcgJiYgdGhpcy5oYXNDb2x1bW5MYXlvdXRzKSB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlck1vZGUgPSBGaWx0ZXJNb2RlLmV4Y2VsU3R5bGVGaWx0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ3JvdXBUZW1wbGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fZ3JvdXBSb3dUZW1wbGF0ZSA9IHRoaXMuZ3JvdXBUZW1wbGF0ZS50ZW1wbGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmhpZGVHcm91cGVkQ29sdW1ucyAmJiB0aGlzLmNvbHVtbkxpc3QgJiYgdGhpcy5ncm91cGluZ0V4cHJlc3Npb25zKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRHcm91cENvbHNWaXNpYmlsaXR5KHRoaXMuaGlkZUdyb3VwZWRDb2x1bW5zKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXR1cE5hdmlnYXRpb25TZXJ2aWNlKCk7XG4gICAgfVxuXG4gICAgcHVibGljIG5nT25Jbml0KCkge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgICAgICB0aGlzLm9uR3JvdXBpbmdEb25lLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKS5zdWJzY3JpYmUoKGFyZ3MpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW5kRWRpdCh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuc3VtbWFyeVNlcnZpY2UudXBkYXRlU3VtbWFyeUNhY2hlKGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgbmdEb0NoZWNrKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5ncm91cGluZ0RpZmZlciAmJiB0aGlzLmNvbHVtbkxpc3QgJiYgIXRoaXMuaGFzQ29sdW1uTGF5b3V0cykge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IHRoaXMuZ3JvdXBpbmdEaWZmZXIuZGlmZih0aGlzLmdyb3VwaW5nRXhwcmVzc2lvbnMpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZXMgJiYgdGhpcy5jb2x1bW5MaXN0KSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5mb3JFYWNoQWRkZWRJdGVtKChyZWMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sID0gdGhpcy5nZXRDb2x1bW5CeU5hbWUocmVjLml0ZW0uZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29sLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5mb3JFYWNoUmVtb3ZlZEl0ZW0oKHJlYykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2wgPSB0aGlzLmdldENvbHVtbkJ5TmFtZShyZWMuaXRlbS5maWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb2wuaGlkZGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIubmdEb0NoZWNrKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGluaGVyaXRkb2NcbiAgICAgKi9cbiAgICBnZXRTZWxlY3RlZERhdGEoZm9ybWF0dGVycyA9IGZhbHNlLCBoZWFkZXJzID0gZmFsc2UpOiBhbnlbXSB7XG4gICAgICAgIGlmICh0aGlzLmdyb3VwaW5nRXhwcmVzc2lvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBbXTtcblxuICAgICAgICAgICAgY29uc3QgcHJvY2VzcyA9IChyZWNvcmQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkLmV4cHJlc3Npb24gfHwgcmVjb3JkLnN1bW1hcmllcykge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2UucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzb3VyY2UucHVzaChyZWNvcmQpO1xuXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLmRhdGFWaWV3LmZvckVhY2gocHJvY2Vzcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHRyYWN0RGF0YUZyb21TZWxlY3Rpb24oc291cmNlLCBmb3JtYXR0ZXJzLCBoZWFkZXJzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdXBlci5nZXRTZWxlY3RlZERhdGEoZm9ybWF0dGVycywgaGVhZGVycyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIF9zZXR1cE5hdmlnYXRpb25TZXJ2aWNlKCkge1xuICAgICAgICBpZiAodGhpcy5oYXNDb2x1bW5MYXlvdXRzKSB7XG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRpb24gPSBuZXcgSWd4R3JpZE1STE5hdmlnYXRpb25TZXJ2aWNlKCk7XG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRpb24uZ3JpZCA9IHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGNoZWNrSWZOb0NvbHVtbkZpZWxkKGV4cHJlc3Npb246IElHcm91cGluZ0V4cHJlc3Npb24gfCBBcnJheTxJR3JvdXBpbmdFeHByZXNzaW9uPiB8IGFueSk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNpbmdsZUV4cHJlc3Npb24gb2YgZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgIGlmICghc2luZ2xlRXhwcmVzc2lvbi5maWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhZXhwcmVzc2lvbi5maWVsZE5hbWU7XG4gICAgfVxuXG59XG4iXX0=