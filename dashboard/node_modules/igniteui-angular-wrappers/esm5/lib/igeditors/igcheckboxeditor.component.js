/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Component, ElementRef, Renderer, IterableDiffers, Optional, KeyValueDiffers, ChangeDetectorRef } from "@angular/core";
import { IgEditorBase } from "./igeditorbase";
import { NgModel } from "@angular/forms";
var IgCheckboxEditorComponent = /** @class */ (function (_super) {
    tslib_1.__extends(IgCheckboxEditorComponent, _super);
    function IgCheckboxEditorComponent(el, renderer, differs, kvalDiffers, cdr, model) {
        var _this = _super.call(this, el, renderer, differs, kvalDiffers, cdr, model) || this;
        _this.model = model;
        return _this;
    }
    /**
     * Checks if the value in the editor is valid. Note: This function will not trigger automatic notifications.
     */
    /* istanbul ignore next */
    /**
     * Checks if the value in the editor is valid. Note: This function will not trigger automatic notifications.
     * @return {?}
     */
    /* istanbul ignore next */
    IgCheckboxEditorComponent.prototype.isValid = /**
     * Checks if the value in the editor is valid. Note: This function will not trigger automatic notifications.
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    /**
     * Gets/Sets Current checked state/Value of the igCheckboxEditor that will be submitted by the HTML form.
     * 1. If the [value](ui.igcheckboxeditor#options:value) option IS NOT defined, then 'value' method will match the checked state of the editor.
     * This option is used when the checkbox is intended to operate as a Boolean editor. In that case the return type is bool.
     * 2. If the [value](ui.igcheckboxeditor#options:value) option IS defined, then 'value' method will return the value that will be submitted when the editor is checked and the form is submitted.
     * To get checked state regardless of the 'value' option, use $(".selector").igCheckboxEditor("option", "checked");
     *
     * @param newValue
     */
    /* istanbul ignore next */
    /**
     * Gets/Sets Current checked state/Value of the igCheckboxEditor that will be submitted by the HTML form.
     * 1. If the [value](ui.igcheckboxeditor#options:value) option IS NOT defined, then 'value' method will match the checked state of the editor.
     * This option is used when the checkbox is intended to operate as a Boolean editor. In that case the return type is bool.
     * 2. If the [value](ui.igcheckboxeditor#options:value) option IS defined, then 'value' method will return the value that will be submitted when the editor is checked and the form is submitted.
     * To get checked state regardless of the 'value' option, use $(".selector").igCheckboxEditor("option", "checked");
     *
     * @param {?} newValue
     * @return {?}
     */
    /* istanbul ignore next */
    IgCheckboxEditorComponent.prototype.value = /**
     * Gets/Sets Current checked state/Value of the igCheckboxEditor that will be submitted by the HTML form.
     * 1. If the [value](ui.igcheckboxeditor#options:value) option IS NOT defined, then 'value' method will match the checked state of the editor.
     * This option is used when the checkbox is intended to operate as a Boolean editor. In that case the return type is bool.
     * 2. If the [value](ui.igcheckboxeditor#options:value) option IS defined, then 'value' method will return the value that will be submitted when the editor is checked and the form is submitted.
     * To get checked state regardless of the 'value' option, use $(".selector").igCheckboxEditor("option", "checked");
     *
     * @param {?} newValue
     * @return {?}
     */
    /* istanbul ignore next */
    function (newValue) { return; };
    ;
    /**
     * Toggles the state of the checkbox.
     */
    /* istanbul ignore next */
    /**
     * Toggles the state of the checkbox.
     * @return {?}
     */
    /* istanbul ignore next */
    IgCheckboxEditorComponent.prototype.toggle = /**
     * Toggles the state of the checkbox.
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    /**
     * Gets/Sets name attribute applied to the editor element.
     *
     * @param newValue The new input name.
     */
    /* istanbul ignore next */
    /**
     * Gets/Sets name attribute applied to the editor element.
     *
     * @param {?=} newValue The new input name.
     * @return {?}
     */
    /* istanbul ignore next */
    IgCheckboxEditorComponent.prototype.inputName = /**
     * Gets/Sets name attribute applied to the editor element.
     *
     * @param {?=} newValue The new input name.
     * @return {?}
     */
    /* istanbul ignore next */
    function (newValue) { return; };
    ;
    /**
     * Gets the input element of the editor.
     */
    /* istanbul ignore next */
    /**
     * Gets the input element of the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    IgCheckboxEditorComponent.prototype.field = /**
     * Gets the input element of the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    /**
     * Gets a reference to the jQuery element that wraps the editor.
     */
    /* istanbul ignore next */
    /**
     * Gets a reference to the jQuery element that wraps the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    IgCheckboxEditorComponent.prototype.editorContainer = /**
     * Gets a reference to the jQuery element that wraps the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    /**
     * Gets whether the editor has focus.
     */
    /* istanbul ignore next */
    /**
     * Gets whether the editor has focus.
     * @return {?}
     */
    /* istanbul ignore next */
    IgCheckboxEditorComponent.prototype.hasFocus = /**
     * Gets whether the editor has focus.
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    /**
     * Sets focus to the editor after the specified delay.
     *
     * @param delay The delay before focusing the editor.
     */
    /* istanbul ignore next */
    /**
     * Sets focus to the editor after the specified delay.
     *
     * @param {?=} delay The delay before focusing the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    IgCheckboxEditorComponent.prototype.setFocus = /**
     * Sets focus to the editor after the specified delay.
     *
     * @param {?=} delay The delay before focusing the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    function (delay) { return; };
    ;
    /**
     * Hides the editor.
     */
    /* istanbul ignore next */
    /**
     * Hides the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    IgCheckboxEditorComponent.prototype.hide = /**
     * Hides the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    /**
     * Shows the editor.
     */
    /* istanbul ignore next */
    /**
     * Shows the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    IgCheckboxEditorComponent.prototype.show = /**
     * Shows the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    /**
     * Gets a reference to [igValidator](ui.igvalidator) used by the editor.
     */
    /* istanbul ignore next */
    /**
     * Gets a reference to [igValidator](ui.igvalidator) used by the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    IgCheckboxEditorComponent.prototype.validator = /**
     * Gets a reference to [igValidator](ui.igvalidator) used by the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    /**
     * Triggers validation for the editor. If validatorOptions are set will also call validate on the [igValidator](ui.igvalidator).
     */
    /* istanbul ignore next */
    /**
     * Triggers validation for the editor. If validatorOptions are set will also call validate on the [igValidator](ui.igvalidator).
     * @return {?}
     */
    /* istanbul ignore next */
    IgCheckboxEditorComponent.prototype.validate = /**
     * Triggers validation for the editor. If validatorOptions are set will also call validate on the [igValidator](ui.igvalidator).
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    /**
     * Destroys the widget
     */
    /* istanbul ignore next */
    /**
     * Destroys the widget
     * @return {?}
     */
    /* istanbul ignore next */
    IgCheckboxEditorComponent.prototype.destroy = /**
     * Destroys the widget
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    IgCheckboxEditorComponent.decorators = [
        { type: Component, args: [{
                    selector: "ig-checkbox-editor",
                    template: "<ng-content></ng-content>",
                    inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "width", "height", "value", "tabIndex", "allowNullValue", "nullValue", "inputName", "readOnly", "validatorOptions", "checked", "size", "iconClass"],
                    outputs: ["rendering", "rendered", "mousedown", "mouseup", "mousemove", "mouseover", "mouseout", "blur", "focus", "keydown", "keypress", "keyup", "valueChanging", "valueChanged"]
                }] }
    ];
    /** @nocollapse */
    IgCheckboxEditorComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer },
        { type: IterableDiffers },
        { type: KeyValueDiffers },
        { type: ChangeDetectorRef },
        { type: NgModel, decorators: [{ type: Optional }] }
    ]; };
    return IgCheckboxEditorComponent;
}(IgEditorBase));
export { IgCheckboxEditorComponent };
if (false) {
    /** @type {?} */
    IgCheckboxEditorComponent.prototype.model;
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWdjaGVja2JveGVkaXRvci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLXdyYXBwZXJzLyIsInNvdXJjZXMiOlsibGliL2lnZWRpdG9ycy9pZ2NoZWNrYm94ZWRpdG9yLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxlQUFlLEVBQUUsUUFBUSxFQUFFLGVBQWUsRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMvSCxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDOUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRXpDO0lBTStDLHFEQUE4QjtJQUN6RSxtQ0FBWSxFQUFjLEVBQUUsUUFBa0IsRUFBRSxPQUF3QixFQUFFLFdBQTRCLEVBQUUsR0FBc0IsRUFBcUIsS0FBYztRQUFqSyxZQUFxSyxrQkFBTSxFQUFFLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxXQUFXLEVBQUUsR0FBRyxFQUFFLEtBQUssQ0FBQyxTQUFHO1FBQTFFLFdBQUssR0FBTCxLQUFLLENBQVM7O0lBQTJELENBQUM7SUFFN047O09BRUc7SUFDSCwwQkFBMEI7Ozs7OztJQUNuQiwyQ0FBTzs7Ozs7SUFBZCxjQUE0QixPQUFPLENBQUMsQ0FBQztJQUFBLENBQUM7SUFFdEM7Ozs7Ozs7O09BUUc7SUFDSCwwQkFBMEI7Ozs7Ozs7Ozs7OztJQUNuQix5Q0FBSzs7Ozs7Ozs7Ozs7SUFBWixVQUFhLFFBQWdCLElBQVksT0FBTyxDQUFDLENBQUM7SUFBQSxDQUFDO0lBRW5EOztPQUVHO0lBQ0gsMEJBQTBCOzs7Ozs7SUFDbkIsMENBQU07Ozs7O0lBQWIsY0FBd0IsT0FBTyxDQUFDLENBQUM7SUFBQSxDQUFDO0lBRWxDOzs7O09BSUc7SUFDSCwwQkFBMEI7Ozs7Ozs7O0lBQ25CLDZDQUFTOzs7Ozs7O0lBQWhCLFVBQWlCLFFBQWlCLElBQVksT0FBTyxDQUFDLENBQUM7SUFBQSxDQUFDO0lBRXhEOztPQUVHO0lBQ0gsMEJBQTBCOzs7Ozs7SUFDbkIseUNBQUs7Ozs7O0lBQVosY0FBeUIsT0FBTyxDQUFDLENBQUM7SUFBQSxDQUFDO0lBRW5DOztPQUVHO0lBQ0gsMEJBQTBCOzs7Ozs7SUFDbkIsbURBQWU7Ozs7O0lBQXRCLGNBQW1DLE9BQU8sQ0FBQyxDQUFDO0lBQUEsQ0FBQztJQUU3Qzs7T0FFRztJQUNILDBCQUEwQjs7Ozs7O0lBQ25CLDRDQUFROzs7OztJQUFmLGNBQTZCLE9BQU8sQ0FBQyxDQUFDO0lBQUEsQ0FBQztJQUV2Qzs7OztPQUlHO0lBQ0gsMEJBQTBCOzs7Ozs7OztJQUNuQiw0Q0FBUTs7Ozs7OztJQUFmLFVBQWdCLEtBQWMsSUFBVSxPQUFPLENBQUMsQ0FBQztJQUFBLENBQUM7SUFFbEQ7O09BRUc7SUFDSCwwQkFBMEI7Ozs7OztJQUNuQix3Q0FBSTs7Ozs7SUFBWCxjQUFzQixPQUFPLENBQUMsQ0FBQztJQUFBLENBQUM7SUFFaEM7O09BRUc7SUFDSCwwQkFBMEI7Ozs7OztJQUNuQix3Q0FBSTs7Ozs7SUFBWCxjQUFzQixPQUFPLENBQUMsQ0FBQztJQUFBLENBQUM7SUFFaEM7O09BRUc7SUFDSCwwQkFBMEI7Ozs7OztJQUNuQiw2Q0FBUzs7Ozs7SUFBaEIsY0FBNkIsT0FBTyxDQUFDLENBQUM7SUFBQSxDQUFDO0lBRXZDOztPQUVHO0lBQ0gsMEJBQTBCOzs7Ozs7SUFDbkIsNENBQVE7Ozs7O0lBQWYsY0FBNkIsT0FBTyxDQUFDLENBQUM7SUFBQSxDQUFDO0lBRXZDOztPQUVHO0lBQ0gsMEJBQTBCOzs7Ozs7SUFDbkIsMkNBQU87Ozs7O0lBQWQsY0FBeUIsT0FBTyxDQUFDLENBQUM7SUFBQSxDQUFDOztnQkEvRnRDLFNBQVMsU0FBQztvQkFDUCxRQUFRLEVBQUUsb0JBQW9CO29CQUM5QixRQUFRLEVBQUUsMkJBQTJCO29CQUNyQyxNQUFNLEVBQUUsQ0FBQyxVQUFVLEVBQUUsU0FBUyxFQUFFLHlCQUF5QixFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLGdCQUFnQixFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUUsVUFBVSxFQUFFLGtCQUFrQixFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsV0FBVyxDQUFDO29CQUNwTyxPQUFPLEVBQUUsQ0FBQyxXQUFXLEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUFFLFdBQVcsRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLE9BQU8sRUFBRSxlQUFlLEVBQUUsY0FBYyxDQUFDO2lCQUNyTDs7OztnQkFUbUIsVUFBVTtnQkFBRSxRQUFRO2dCQUFFLGVBQWU7Z0JBQVksZUFBZTtnQkFBRSxpQkFBaUI7Z0JBRTlGLE9BQU8sdUJBU3FILFFBQVE7O0lBeUY3SSxnQ0FBQztDQUFBLEFBaEdELENBTStDLFlBQVksR0EwRjFEO1NBMUZZLHlCQUF5Qjs7O0lBQzhGLDBDQUFpQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiwgUmVuZGVyZXIsIEl0ZXJhYmxlRGlmZmVycywgT3B0aW9uYWwsIEtleVZhbHVlRGlmZmVycywgQ2hhbmdlRGV0ZWN0b3JSZWYgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgSWdFZGl0b3JCYXNlIH0gZnJvbSBcIi4vaWdlZGl0b3JiYXNlXCI7XG5pbXBvcnQgeyBOZ01vZGVsIH0gZnJvbSBcIkBhbmd1bGFyL2Zvcm1zXCI7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiBcImlnLWNoZWNrYm94LWVkaXRvclwiLFxuICAgIHRlbXBsYXRlOiBcIjxuZy1jb250ZW50PjwvbmctY29udGVudD5cIixcbiAgICBpbnB1dHM6IFtcIndpZGdldElkXCIsIFwib3B0aW9uc1wiLCBcImNoYW5nZURldGVjdGlvbkludGVydmFsXCIsIFwiZGlzYWJsZWRcIiwgXCJjcmVhdGVcIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiLCBcInZhbHVlXCIsIFwidGFiSW5kZXhcIiwgXCJhbGxvd051bGxWYWx1ZVwiLCBcIm51bGxWYWx1ZVwiLCBcImlucHV0TmFtZVwiLCBcInJlYWRPbmx5XCIsIFwidmFsaWRhdG9yT3B0aW9uc1wiLCBcImNoZWNrZWRcIiwgXCJzaXplXCIsIFwiaWNvbkNsYXNzXCJdLFxuICAgIG91dHB1dHM6IFtcInJlbmRlcmluZ1wiLCBcInJlbmRlcmVkXCIsIFwibW91c2Vkb3duXCIsIFwibW91c2V1cFwiLCBcIm1vdXNlbW92ZVwiLCBcIm1vdXNlb3ZlclwiLCBcIm1vdXNlb3V0XCIsIFwiYmx1clwiLCBcImZvY3VzXCIsIFwia2V5ZG93blwiLCBcImtleXByZXNzXCIsIFwia2V5dXBcIiwgXCJ2YWx1ZUNoYW5naW5nXCIsIFwidmFsdWVDaGFuZ2VkXCJdXG59KVxuZXhwb3J0IGNsYXNzIElnQ2hlY2tib3hFZGl0b3JDb21wb25lbnQgZXh0ZW5kcyBJZ0VkaXRvckJhc2U8SWdDaGVja2JveEVkaXRvcj4ge1xuICAgIGNvbnN0cnVjdG9yKGVsOiBFbGVtZW50UmVmLCByZW5kZXJlcjogUmVuZGVyZXIsIGRpZmZlcnM6IEl0ZXJhYmxlRGlmZmVycywga3ZhbERpZmZlcnM6IEtleVZhbHVlRGlmZmVycywgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZiwgQE9wdGlvbmFsKCkgcHVibGljIG1vZGVsOiBOZ01vZGVsKSB7IHN1cGVyKGVsLCByZW5kZXJlciwgZGlmZmVycywga3ZhbERpZmZlcnMsIGNkciwgbW9kZWwpOyB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIHZhbHVlIGluIHRoZSBlZGl0b3IgaXMgdmFsaWQuIE5vdGU6IFRoaXMgZnVuY3Rpb24gd2lsbCBub3QgdHJpZ2dlciBhdXRvbWF0aWMgbm90aWZpY2F0aW9ucy5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBpc1ZhbGlkKCk6IGJvb2xlYW4geyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzL1NldHMgQ3VycmVudCBjaGVja2VkIHN0YXRlL1ZhbHVlIG9mIHRoZSBpZ0NoZWNrYm94RWRpdG9yIHRoYXQgd2lsbCBiZSBzdWJtaXR0ZWQgYnkgdGhlIEhUTUwgZm9ybS5cbiAgICAgKiAxLiBJZiB0aGUgW3ZhbHVlXSh1aS5pZ2NoZWNrYm94ZWRpdG9yI29wdGlvbnM6dmFsdWUpIG9wdGlvbiBJUyBOT1QgZGVmaW5lZCwgdGhlbiAndmFsdWUnIG1ldGhvZCB3aWxsIG1hdGNoIHRoZSBjaGVja2VkIHN0YXRlIG9mIHRoZSBlZGl0b3IuXG4gICAgICogVGhpcyBvcHRpb24gaXMgdXNlZCB3aGVuIHRoZSBjaGVja2JveCBpcyBpbnRlbmRlZCB0byBvcGVyYXRlIGFzIGEgQm9vbGVhbiBlZGl0b3IuIEluIHRoYXQgY2FzZSB0aGUgcmV0dXJuIHR5cGUgaXMgYm9vbC5cbiAgICAgKiAyLiBJZiB0aGUgW3ZhbHVlXSh1aS5pZ2NoZWNrYm94ZWRpdG9yI29wdGlvbnM6dmFsdWUpIG9wdGlvbiBJUyBkZWZpbmVkLCB0aGVuICd2YWx1ZScgbWV0aG9kIHdpbGwgcmV0dXJuIHRoZSB2YWx1ZSB0aGF0IHdpbGwgYmUgc3VibWl0dGVkIHdoZW4gdGhlIGVkaXRvciBpcyBjaGVja2VkIGFuZCB0aGUgZm9ybSBpcyBzdWJtaXR0ZWQuXG4gICAgICogVG8gZ2V0IGNoZWNrZWQgc3RhdGUgcmVnYXJkbGVzcyBvZiB0aGUgJ3ZhbHVlJyBvcHRpb24sIHVzZSAkKFwiLnNlbGVjdG9yXCIpLmlnQ2hlY2tib3hFZGl0b3IoXCJvcHRpb25cIiwgXCJjaGVja2VkXCIpO1xuICAgICAqXG4gICAgICogQHBhcmFtIG5ld1ZhbHVlXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgdmFsdWUobmV3VmFsdWU6IE9iamVjdCk6IHN0cmluZyB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhlIHN0YXRlIG9mIHRoZSBjaGVja2JveC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyB0b2dnbGUoKTogdm9pZCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyBuYW1lIGF0dHJpYnV0ZSBhcHBsaWVkIHRvIHRoZSBlZGl0b3IgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXdWYWx1ZSBUaGUgbmV3IGlucHV0IG5hbWUuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgaW5wdXROYW1lKG5ld1ZhbHVlPzogc3RyaW5nKTogc3RyaW5nIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW5wdXQgZWxlbWVudCBvZiB0aGUgZWRpdG9yLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGZpZWxkKCk6IHN0cmluZyB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgYSByZWZlcmVuY2UgdG8gdGhlIGpRdWVyeSBlbGVtZW50IHRoYXQgd3JhcHMgdGhlIGVkaXRvci5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBlZGl0b3JDb250YWluZXIoKTogc3RyaW5nIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBlZGl0b3IgaGFzIGZvY3VzLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGhhc0ZvY3VzKCk6IGJvb2xlYW4geyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGZvY3VzIHRvIHRoZSBlZGl0b3IgYWZ0ZXIgdGhlIHNwZWNpZmllZCBkZWxheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkZWxheSBUaGUgZGVsYXkgYmVmb3JlIGZvY3VzaW5nIHRoZSBlZGl0b3IuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgc2V0Rm9jdXMoZGVsYXk/OiBudW1iZXIpOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogSGlkZXMgdGhlIGVkaXRvci5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBoaWRlKCk6IHZvaWQgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBTaG93cyB0aGUgZWRpdG9yLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIHNob3coKTogdm9pZCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgYSByZWZlcmVuY2UgdG8gW2lnVmFsaWRhdG9yXSh1aS5pZ3ZhbGlkYXRvcikgdXNlZCBieSB0aGUgZWRpdG9yLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIHZhbGlkYXRvcigpOiBPYmplY3QgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyB2YWxpZGF0aW9uIGZvciB0aGUgZWRpdG9yLiBJZiB2YWxpZGF0b3JPcHRpb25zIGFyZSBzZXQgd2lsbCBhbHNvIGNhbGwgdmFsaWRhdGUgb24gdGhlIFtpZ1ZhbGlkYXRvcl0odWkuaWd2YWxpZGF0b3IpLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIHZhbGlkYXRlKCk6IGJvb2xlYW4geyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGUgd2lkZ2V0XG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgZGVzdHJveSgpOiB2b2lkIHsgcmV0dXJuOyB9O1xufSJdfQ==