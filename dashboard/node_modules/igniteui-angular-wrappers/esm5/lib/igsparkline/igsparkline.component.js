/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Component, ElementRef, Renderer, IterableDiffers, KeyValueDiffers, ChangeDetectorRef, Input } from "@angular/core";
import { IgControlBase } from "../igcontrolbase/igcontrolbase";
var IgSparklineComponent = /** @class */ (function (_super) {
    tslib_1.__extends(IgSparklineComponent, _super);
    function IgSparklineComponent(el, renderer, differs, kvalDiffers, cdr) {
        return _super.call(this, el, renderer, differs, kvalDiffers, cdr) || this;
    }
    Object.defineProperty(IgSparklineComponent.prototype, "dataSource", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._dataSource = value;
            /** @type {?} */
            var widget = jQuery(this._el).data(this._widgetName);
            if (widget) {
                jQuery(this._el)[this._widgetName]("option", "dataSource", this._dataSource);
            }
        },
        enumerable: true,
        configurable: true
    });
    ;
    /**
     * @return {?}
     */
    IgSparklineComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this._dataSource === null || this._dataSource === undefined) {
            this._dataSource = this.options["dataSource"];
        }
        if (!this.options["dataSource"] && this._dataSource) {
            this.options["dataSource"] = this._dataSource;
        }
        _super.prototype.ngOnInit.call(this);
    };
    /* istanbul ignore next */
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    IgSparklineComponent.prototype.destroy = /* istanbul ignore next */
    /**
     * @return {?}
     */
    function () { return; };
    ;
    IgSparklineComponent.decorators = [
        { type: Component, args: [{
                    selector: "ig-sparkline",
                    template: "<ng-content></ng-content>",
                    inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "width", "height", "tooltipTemplate", "maxRecCount", "dataSource", "dataSourceType", "dataSourceUrl", "responseTotalRecCountKey", "responseDataKey", "brush", "negativeBrush", "markerBrush", "negativeMarkerBrush", "firstMarkerBrush", "lastMarkerBrush", "highMarkerBrush", "lowMarkerBrush", "trendLineBrush", "horizontalAxisBrush", "verticalAxisBrush", "normalRangeFill", "horizontalAxisVisibility", "verticalAxisVisibility", "markerVisibility", "negativeMarkerVisibility", "firstMarkerVisibility", "lastMarkerVisibility", "lowMarkerVisibility", "highMarkerVisibility", "normalRangeVisibility", "displayNormalRangeInFront", "markerSize", "firstMarkerSize", "lastMarkerSize", "highMarkerSize", "lowMarkerSize", "negativeMarkerSize", "lineThickness", "valueMemberPath", "labelMemberPath", "trendLineType", "trendLinePeriod", "trendLineThickness", "normalRangeMinimum", "normalRangeMaximum", "displayType", "unknownValuePlotting", "verticalAxisLabel", "horizontalAxisLabel", "formatLabel", "pixelScalingRatio"],
                    outputs: ["dataBinding", "dataBound", "updateTooltip", "hideTooltip"]
                }] }
    ];
    /** @nocollapse */
    IgSparklineComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer },
        { type: IterableDiffers },
        { type: KeyValueDiffers },
        { type: ChangeDetectorRef }
    ]; };
    IgSparklineComponent.propDecorators = {
        dataSource: [{ type: Input }]
    };
    return IgSparklineComponent;
}(IgControlBase));
export { IgSparklineComponent };
if (false) {
    /**
     * @type {?}
     * @private
     */
    IgSparklineComponent.prototype._dataSource;
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWdzcGFya2xpbmUuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vaWduaXRldWktYW5ndWxhci13cmFwcGVycy8iLCJzb3VyY2VzIjpbImxpYi9pZ3NwYXJrbGluZS9pZ3NwYXJrbGluZS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsZUFBZSxFQUFFLGVBQWUsRUFBRSxpQkFBaUIsRUFBRSxLQUFLLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDNUgsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBRS9EO0lBTTBDLGdEQUEwQjtJQUNoRSw4QkFBWSxFQUFjLEVBQUUsUUFBa0IsRUFBRSxPQUF3QixFQUFFLFdBQTRCLEVBQUUsR0FBc0I7ZUFDMUgsa0JBQU0sRUFBRSxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsV0FBVyxFQUFFLEdBQUcsQ0FBQztJQUNsRCxDQUFDO0lBRUQsc0JBQ1csNENBQVU7Ozs7O1FBRHJCLFVBQ3NCLEtBQVU7WUFDNUIsSUFBSSxDQUFDLFdBQVcsR0FBRyxLQUFLLENBQUM7O2dCQUNuQixNQUFNLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQztZQUN0RCxJQUFJLE1BQU0sRUFBRTtnQkFDUixNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxRQUFRLEVBQUUsWUFBWSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQzthQUNoRjtRQUNMLENBQUM7OztPQUFBO0lBQUEsQ0FBQzs7OztJQUlGLHVDQUFROzs7SUFBUjtRQUNJLElBQUksSUFBSSxDQUFDLFdBQVcsS0FBSyxJQUFJLElBQUksSUFBSSxDQUFDLFdBQVcsS0FBSyxTQUFTLEVBQUU7WUFDN0QsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDO1NBQ2pEO1FBQ0QsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRTtZQUNqRCxJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUM7U0FDakQ7UUFDRCxpQkFBTSxRQUFRLFdBQUUsQ0FBQztJQUNyQixDQUFDO0lBRUQsMEJBQTBCOzs7OztJQUNuQixzQ0FBTzs7OztJQUFkLGNBQXlCLE9BQU8sQ0FBQyxDQUFDO0lBQUMsQ0FBQzs7Z0JBakN2QyxTQUFTLFNBQUM7b0JBQ1AsUUFBUSxFQUFFLGNBQWM7b0JBQ3hCLFFBQVEsRUFBRSwyQkFBMkI7b0JBQ3JDLE1BQU0sRUFBRSxDQUFDLFVBQVUsRUFBRSxTQUFTLEVBQUUseUJBQXlCLEVBQUMsVUFBVSxFQUFDLFFBQVEsRUFBQyxPQUFPLEVBQUMsUUFBUSxFQUFDLGlCQUFpQixFQUFDLGFBQWEsRUFBQyxZQUFZLEVBQUMsZ0JBQWdCLEVBQUMsZUFBZSxFQUFDLDBCQUEwQixFQUFDLGlCQUFpQixFQUFDLE9BQU8sRUFBQyxlQUFlLEVBQUMsYUFBYSxFQUFDLHFCQUFxQixFQUFDLGtCQUFrQixFQUFDLGlCQUFpQixFQUFDLGlCQUFpQixFQUFDLGdCQUFnQixFQUFDLGdCQUFnQixFQUFDLHFCQUFxQixFQUFDLG1CQUFtQixFQUFDLGlCQUFpQixFQUFDLDBCQUEwQixFQUFDLHdCQUF3QixFQUFDLGtCQUFrQixFQUFDLDBCQUEwQixFQUFDLHVCQUF1QixFQUFDLHNCQUFzQixFQUFDLHFCQUFxQixFQUFDLHNCQUFzQixFQUFDLHVCQUF1QixFQUFDLDJCQUEyQixFQUFDLFlBQVksRUFBQyxpQkFBaUIsRUFBQyxnQkFBZ0IsRUFBQyxnQkFBZ0IsRUFBQyxlQUFlLEVBQUMsb0JBQW9CLEVBQUMsZUFBZSxFQUFDLGlCQUFpQixFQUFDLGlCQUFpQixFQUFDLGVBQWUsRUFBQyxpQkFBaUIsRUFBQyxvQkFBb0IsRUFBQyxvQkFBb0IsRUFBQyxvQkFBb0IsRUFBQyxhQUFhLEVBQUMsc0JBQXNCLEVBQUMsbUJBQW1CLEVBQUMscUJBQXFCLEVBQUMsYUFBYSxFQUFDLG1CQUFtQixDQUFDO29CQUN6Z0MsT0FBTyxFQUFFLENBQUMsYUFBYSxFQUFDLFdBQVcsRUFBQyxlQUFlLEVBQUMsYUFBYSxDQUFDO2lCQUNyRTs7OztnQkFSbUIsVUFBVTtnQkFBRSxRQUFRO2dCQUFFLGVBQWU7Z0JBQUUsZUFBZTtnQkFBRSxpQkFBaUI7Ozs2QkFjeEYsS0FBSzs7SUF1QlYsMkJBQUM7Q0FBQSxBQWxDRCxDQU0wQyxhQUFhLEdBNEJ0RDtTQTVCWSxvQkFBb0I7Ozs7OztJQWM3QiwyQ0FBeUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIEVsZW1lbnRSZWYsIFJlbmRlcmVyLCBJdGVyYWJsZURpZmZlcnMsIEtleVZhbHVlRGlmZmVycywgQ2hhbmdlRGV0ZWN0b3JSZWYsIElucHV0IH0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7IElnQ29udHJvbEJhc2UgfSBmcm9tIFwiLi4vaWdjb250cm9sYmFzZS9pZ2NvbnRyb2xiYXNlXCI7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiBcImlnLXNwYXJrbGluZVwiLFxuICAgIHRlbXBsYXRlOiBcIjxuZy1jb250ZW50PjwvbmctY29udGVudD5cIixcbiAgICBpbnB1dHM6IFtcIndpZGdldElkXCIsIFwib3B0aW9uc1wiLCBcImNoYW5nZURldGVjdGlvbkludGVydmFsXCIsXCJkaXNhYmxlZFwiLFwiY3JlYXRlXCIsXCJ3aWR0aFwiLFwiaGVpZ2h0XCIsXCJ0b29sdGlwVGVtcGxhdGVcIixcIm1heFJlY0NvdW50XCIsXCJkYXRhU291cmNlXCIsXCJkYXRhU291cmNlVHlwZVwiLFwiZGF0YVNvdXJjZVVybFwiLFwicmVzcG9uc2VUb3RhbFJlY0NvdW50S2V5XCIsXCJyZXNwb25zZURhdGFLZXlcIixcImJydXNoXCIsXCJuZWdhdGl2ZUJydXNoXCIsXCJtYXJrZXJCcnVzaFwiLFwibmVnYXRpdmVNYXJrZXJCcnVzaFwiLFwiZmlyc3RNYXJrZXJCcnVzaFwiLFwibGFzdE1hcmtlckJydXNoXCIsXCJoaWdoTWFya2VyQnJ1c2hcIixcImxvd01hcmtlckJydXNoXCIsXCJ0cmVuZExpbmVCcnVzaFwiLFwiaG9yaXpvbnRhbEF4aXNCcnVzaFwiLFwidmVydGljYWxBeGlzQnJ1c2hcIixcIm5vcm1hbFJhbmdlRmlsbFwiLFwiaG9yaXpvbnRhbEF4aXNWaXNpYmlsaXR5XCIsXCJ2ZXJ0aWNhbEF4aXNWaXNpYmlsaXR5XCIsXCJtYXJrZXJWaXNpYmlsaXR5XCIsXCJuZWdhdGl2ZU1hcmtlclZpc2liaWxpdHlcIixcImZpcnN0TWFya2VyVmlzaWJpbGl0eVwiLFwibGFzdE1hcmtlclZpc2liaWxpdHlcIixcImxvd01hcmtlclZpc2liaWxpdHlcIixcImhpZ2hNYXJrZXJWaXNpYmlsaXR5XCIsXCJub3JtYWxSYW5nZVZpc2liaWxpdHlcIixcImRpc3BsYXlOb3JtYWxSYW5nZUluRnJvbnRcIixcIm1hcmtlclNpemVcIixcImZpcnN0TWFya2VyU2l6ZVwiLFwibGFzdE1hcmtlclNpemVcIixcImhpZ2hNYXJrZXJTaXplXCIsXCJsb3dNYXJrZXJTaXplXCIsXCJuZWdhdGl2ZU1hcmtlclNpemVcIixcImxpbmVUaGlja25lc3NcIixcInZhbHVlTWVtYmVyUGF0aFwiLFwibGFiZWxNZW1iZXJQYXRoXCIsXCJ0cmVuZExpbmVUeXBlXCIsXCJ0cmVuZExpbmVQZXJpb2RcIixcInRyZW5kTGluZVRoaWNrbmVzc1wiLFwibm9ybWFsUmFuZ2VNaW5pbXVtXCIsXCJub3JtYWxSYW5nZU1heGltdW1cIixcImRpc3BsYXlUeXBlXCIsXCJ1bmtub3duVmFsdWVQbG90dGluZ1wiLFwidmVydGljYWxBeGlzTGFiZWxcIixcImhvcml6b250YWxBeGlzTGFiZWxcIixcImZvcm1hdExhYmVsXCIsXCJwaXhlbFNjYWxpbmdSYXRpb1wiXSxcbiAgICBvdXRwdXRzOiBbXCJkYXRhQmluZGluZ1wiLFwiZGF0YUJvdW5kXCIsXCJ1cGRhdGVUb29sdGlwXCIsXCJoaWRlVG9vbHRpcFwiXVxufSlcbmV4cG9ydCBjbGFzcyBJZ1NwYXJrbGluZUNvbXBvbmVudCBleHRlbmRzIElnQ29udHJvbEJhc2U8SWdTcGFya2xpbmU+IHsgXG4gICAgY29uc3RydWN0b3IoZWw6IEVsZW1lbnRSZWYsIHJlbmRlcmVyOiBSZW5kZXJlciwgZGlmZmVyczogSXRlcmFibGVEaWZmZXJzLCBrdmFsRGlmZmVyczogS2V5VmFsdWVEaWZmZXJzLCBjZHI6IENoYW5nZURldGVjdG9yUmVmKSB7IFxuICAgICAgICBzdXBlcihlbCwgcmVuZGVyZXIsIGRpZmZlcnMsIGt2YWxEaWZmZXJzLCBjZHIpO1xuICAgIH1cblxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNldCBkYXRhU291cmNlKHZhbHVlOiBhbnkpIHtcbiAgICAgICAgdGhpcy5fZGF0YVNvdXJjZSA9IHZhbHVlO1xuICAgICAgICBjb25zdCB3aWRnZXQgPSBqUXVlcnkodGhpcy5fZWwpLmRhdGEodGhpcy5fd2lkZ2V0TmFtZSk7XG4gICAgICAgIGlmICh3aWRnZXQpIHtcbiAgICAgICAgICAgIGpRdWVyeSh0aGlzLl9lbClbdGhpcy5fd2lkZ2V0TmFtZV0oXCJvcHRpb25cIiwgXCJkYXRhU291cmNlXCIsIHRoaXMuX2RhdGFTb3VyY2UpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByaXZhdGUgX2RhdGFTb3VyY2U6IGFueTtcblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBpZiAodGhpcy5fZGF0YVNvdXJjZSA9PT0gbnVsbCB8fCB0aGlzLl9kYXRhU291cmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGFTb3VyY2UgPSB0aGlzLm9wdGlvbnNbXCJkYXRhU291cmNlXCJdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zW1wiZGF0YVNvdXJjZVwiXSAmJiB0aGlzLl9kYXRhU291cmNlKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNbXCJkYXRhU291cmNlXCJdID0gdGhpcy5fZGF0YVNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgIH1cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGRlc3Ryb3koKTogdm9pZCB7IHJldHVybjsgfSA7XG59Il19