/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Component, ElementRef, Renderer, IterableDiffers, KeyValueDiffers, ChangeDetectorRef } from "@angular/core";
import { IgControlBase } from "../igcontrolbase/igcontrolbase";
var IgRadialGaugeComponent = /** @class */ (function (_super) {
    tslib_1.__extends(IgRadialGaugeComponent, _super);
    function IgRadialGaugeComponent(el, renderer, differs, kvalDiffers, cdr) {
        return _super.call(this, el, renderer, differs, kvalDiffers, cdr) || this;
    }
    /**
     * Returns a string containing the names of all the ranges delimited with a \n symbol.
     */
    /* istanbul ignore next */
    /**
     * Returns a string containing the names of all the ranges delimited with a \n symbol.
     * @return {?}
     */
    /* istanbul ignore next */
    IgRadialGaugeComponent.prototype.getRangeNames = /**
     * Returns a string containing the names of all the ranges delimited with a \n symbol.
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    /**
     * Adds a new range to the radial gauge.
     *
     * @param value
     */
    /* istanbul ignore next */
    /**
     * Adds a new range to the radial gauge.
     *
     * @param {?} value
     * @return {?}
     */
    /* istanbul ignore next */
    IgRadialGaugeComponent.prototype.addRange = /**
     * Adds a new range to the radial gauge.
     *
     * @param {?} value
     * @return {?}
     */
    /* istanbul ignore next */
    function (value) { return; };
    ;
    /**
     * Removes a specified range.
     *
     * @param value
     */
    /* istanbul ignore next */
    /**
     * Removes a specified range.
     *
     * @param {?} value
     * @return {?}
     */
    /* istanbul ignore next */
    IgRadialGaugeComponent.prototype.removeRange = /**
     * Removes a specified range.
     *
     * @param {?} value
     * @return {?}
     */
    /* istanbul ignore next */
    function (value) { return; };
    ;
    /**
     * Updates the range.
     *
     * @param value
     */
    /* istanbul ignore next */
    /**
     * Updates the range.
     *
     * @param {?} value
     * @return {?}
     */
    /* istanbul ignore next */
    IgRadialGaugeComponent.prototype.updateRange = /**
     * Updates the range.
     *
     * @param {?} value
     * @return {?}
     */
    /* istanbul ignore next */
    function (value) { return; };
    ;
    /**
     * Clears the ranges in the radial gauge.
     */
    /* istanbul ignore next */
    /**
     * Clears the ranges in the radial gauge.
     * @return {?}
     */
    /* istanbul ignore next */
    IgRadialGaugeComponent.prototype.clearRanges = /**
     * Clears the ranges in the radial gauge.
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    /**
     * Scales a value on the gauge's main scale to an angle around the center point of the gauge, in radians.
     *
     * @param value
     */
    /* istanbul ignore next */
    /**
     * Scales a value on the gauge's main scale to an angle around the center point of the gauge, in radians.
     *
     * @param {?} value
     * @return {?}
     */
    /* istanbul ignore next */
    IgRadialGaugeComponent.prototype.scaleValue = /**
     * Scales a value on the gauge's main scale to an angle around the center point of the gauge, in radians.
     *
     * @param {?} value
     * @return {?}
     */
    /* istanbul ignore next */
    function (value) { return; };
    ;
    /**
     * Unscales a value from an angle in radians to the represented value along the main scale of the gauge.
     *
     * @param value
     */
    /* istanbul ignore next */
    /**
     * Unscales a value from an angle in radians to the represented value along the main scale of the gauge.
     *
     * @param {?} value
     * @return {?}
     */
    /* istanbul ignore next */
    IgRadialGaugeComponent.prototype.unscaleValue = /**
     * Unscales a value from an angle in radians to the represented value along the main scale of the gauge.
     *
     * @param {?} value
     * @return {?}
     */
    /* istanbul ignore next */
    function (value) { return; };
    ;
    /**
     * Gets the value for the main scale of the gauge for a given point within the bounds of the gauge.
     *
     * @param x
     * @param y
     */
    /* istanbul ignore next */
    /**
     * Gets the value for the main scale of the gauge for a given point within the bounds of the gauge.
     *
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    /* istanbul ignore next */
    IgRadialGaugeComponent.prototype.getValueForPoint = /**
     * Gets the value for the main scale of the gauge for a given point within the bounds of the gauge.
     *
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    /* istanbul ignore next */
    function (x, y) { return; };
    ;
    /**
     * Gets the point on the gauge for a given scale value and extent.
     *
     * @param value
     * @param extent
     */
    /* istanbul ignore next */
    /**
     * Gets the point on the gauge for a given scale value and extent.
     *
     * @param {?} value
     * @param {?} extent
     * @return {?}
     */
    /* istanbul ignore next */
    IgRadialGaugeComponent.prototype.getPointForValue = /**
     * Gets the point on the gauge for a given scale value and extent.
     *
     * @param {?} value
     * @param {?} extent
     * @return {?}
     */
    /* istanbul ignore next */
    function (value, extent) { return; };
    ;
    /**
     * Returns true if the main gauge needle bounding box contains the point provided, otherwise false.
     *
     * @param x
     * @param y
     */
    /* istanbul ignore next */
    /**
     * Returns true if the main gauge needle bounding box contains the point provided, otherwise false.
     *
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    /* istanbul ignore next */
    IgRadialGaugeComponent.prototype.needleContainsPoint = /**
     * Returns true if the main gauge needle bounding box contains the point provided, otherwise false.
     *
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    /* istanbul ignore next */
    function (x, y) { return; };
    ;
    /**
     * Exports the visual data for the radial gauge.
     */
    /* istanbul ignore next */
    /**
     * Exports the visual data for the radial gauge.
     * @return {?}
     */
    /* istanbul ignore next */
    IgRadialGaugeComponent.prototype.exportVisualData = /**
     * Exports the visual data for the radial gauge.
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    /**
     * Flushes the gauge.
     */
    /* istanbul ignore next */
    /**
     * Flushes the gauge.
     * @return {?}
     */
    /* istanbul ignore next */
    IgRadialGaugeComponent.prototype.flush = /**
     * Flushes the gauge.
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    /**
     * Destroys widget.
     */
    /* istanbul ignore next */
    /**
     * Destroys widget.
     * @return {?}
     */
    /* istanbul ignore next */
    IgRadialGaugeComponent.prototype.destroy = /**
     * Destroys widget.
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    /**
     * Returns true if the style was updated for the radial gauge.
     */
    /* istanbul ignore next */
    /**
     * Returns true if the style was updated for the radial gauge.
     * @return {?}
     */
    /* istanbul ignore next */
    IgRadialGaugeComponent.prototype.styleUpdated = /**
     * Returns true if the style was updated for the radial gauge.
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    IgRadialGaugeComponent.decorators = [
        { type: Component, args: [{
                    selector: "ig-radial-gauge",
                    template: "<ng-content></ng-content>",
                    inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "width", "height", "ranges", "rangeBrushes", "rangeOutlines", "minimumValue", "maximumValue", "interval", "centerX", "centerY", "value", "scaleStartAngle", "scaleEndAngle", "scaleSweepDirection", "transitionDuration", "transitionEasingFunction", "needleBrush", "needleOutline", "needleStartExtent", "needleEndExtent", "needleShape", "needleStartWidthRatio", "needleEndWidthRatio", "needleBaseFeatureWidthRatio", "needleBaseFeatureExtent", "needlePointFeatureWidthRatio", "needlePointFeatureExtent", "needlePivotWidthRatio", "needlePivotInnerWidthRatio", "needlePivotShape", "scaleStartExtent", "needlePivotBrush", "needlePivotOutline", "needleStrokeThickness", "needlePivotStrokeThickness", "scaleEndExtent", "labelExtent", "labelInterval", "tickStartExtent", "tickEndExtent", "tickStrokeThickness", "tickBrush", "fontBrush", "minorTickStartExtent", "minorTickEndExtent", "minorTickStrokeThickness", "minorTickBrush", "minorTickCount", "scaleBrush", "backingBrush", "backingOutline", "backingStrokeThickness", "backingOuterExtent", "backingOversweep", "scaleOversweep", "scaleOversweepShape", "backingCornerRadius", "backingInnerExtent", "backingShape", "radiusMultiplier", "duplicateLabelOmissionStrategy", "isNeedleDraggingEnabled", "isNeedleDraggingConstrained", "font", "transitionProgress", "pixelScalingRatio"],
                    outputs: ["formatLabel", "alignLabel", "valueChanged"]
                }] }
    ];
    /** @nocollapse */
    IgRadialGaugeComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer },
        { type: IterableDiffers },
        { type: KeyValueDiffers },
        { type: ChangeDetectorRef }
    ]; };
    return IgRadialGaugeComponent;
}(IgControlBase));
export { IgRadialGaugeComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWdyYWRpYWxnYXVnZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLXdyYXBwZXJzLyIsInNvdXJjZXMiOlsibGliL2lncmFkaWFsZ2F1Z2UvaWdyYWRpYWxnYXVnZS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsZUFBZSxFQUFFLGVBQWUsRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNySCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sZ0NBQWdDLENBQUM7QUFFL0Q7SUFNNEMsa0RBQTRCO0lBQ3BFLGdDQUFZLEVBQWMsRUFBRSxRQUFrQixFQUFFLE9BQXdCLEVBQUUsV0FBNEIsRUFBRSxHQUFzQjtlQUFJLGtCQUFNLEVBQUUsRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLFdBQVcsRUFBRSxHQUFHLENBQUM7SUFBRSxDQUFDO0lBRW5MOztPQUVHO0lBQ0gsMEJBQTBCOzs7Ozs7SUFDbkIsOENBQWE7Ozs7O0lBQXBCLGNBQWlDLE9BQU8sQ0FBQyxDQUFDO0lBQUEsQ0FBQztJQUUzQzs7OztPQUlHO0lBQ0gsMEJBQTBCOzs7Ozs7OztJQUNuQix5Q0FBUTs7Ozs7OztJQUFmLFVBQWdCLEtBQWEsSUFBVSxPQUFPLENBQUMsQ0FBQztJQUFBLENBQUM7SUFFakQ7Ozs7T0FJRztJQUNILDBCQUEwQjs7Ozs7Ozs7SUFDbkIsNENBQVc7Ozs7Ozs7SUFBbEIsVUFBbUIsS0FBYSxJQUFVLE9BQU8sQ0FBQyxDQUFDO0lBQUEsQ0FBQztJQUVwRDs7OztPQUlHO0lBQ0gsMEJBQTBCOzs7Ozs7OztJQUNuQiw0Q0FBVzs7Ozs7OztJQUFsQixVQUFtQixLQUFhLElBQVUsT0FBTyxDQUFDLENBQUM7SUFBQSxDQUFDO0lBRXBEOztPQUVHO0lBQ0gsMEJBQTBCOzs7Ozs7SUFDbkIsNENBQVc7Ozs7O0lBQWxCLGNBQTZC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RSxZQUFZLEVBQUUsY0FBYyxDQUFDO2lCQUN6RDs7OztnQkFSbUIsVUFBVTtnQkFBRSxRQUFRO2dCQUFFLGVBQWU7Z0JBQUUsZUFBZTtnQkFBRSxpQkFBaUI7O0lBa0g3Riw2QkFBQztDQUFBLEFBL0dELENBTTRDLGFBQWEsR0F5R3hEO1NBekdZLHNCQUFzQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiwgUmVuZGVyZXIsIEl0ZXJhYmxlRGlmZmVycywgS2V5VmFsdWVEaWZmZXJzLCBDaGFuZ2VEZXRlY3RvclJlZiB9IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQgeyBJZ0NvbnRyb2xCYXNlIH0gZnJvbSBcIi4uL2lnY29udHJvbGJhc2UvaWdjb250cm9sYmFzZVwiO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogXCJpZy1yYWRpYWwtZ2F1Z2VcIixcbiAgICB0ZW1wbGF0ZTogXCI8bmctY29udGVudD48L25nLWNvbnRlbnQ+XCIsXG4gICAgaW5wdXRzOiBbXCJ3aWRnZXRJZFwiLCBcIm9wdGlvbnNcIiwgXCJjaGFuZ2VEZXRlY3Rpb25JbnRlcnZhbFwiLCBcImRpc2FibGVkXCIsIFwiY3JlYXRlXCIsIFwid2lkdGhcIiwgXCJoZWlnaHRcIiwgXCJyYW5nZXNcIiwgXCJyYW5nZUJydXNoZXNcIiwgXCJyYW5nZU91dGxpbmVzXCIsIFwibWluaW11bVZhbHVlXCIsIFwibWF4aW11bVZhbHVlXCIsIFwiaW50ZXJ2YWxcIiwgXCJjZW50ZXJYXCIsIFwiY2VudGVyWVwiLCBcInZhbHVlXCIsIFwic2NhbGVTdGFydEFuZ2xlXCIsIFwic2NhbGVFbmRBbmdsZVwiLCBcInNjYWxlU3dlZXBEaXJlY3Rpb25cIiwgXCJ0cmFuc2l0aW9uRHVyYXRpb25cIiwgXCJ0cmFuc2l0aW9uRWFzaW5nRnVuY3Rpb25cIiwgXCJuZWVkbGVCcnVzaFwiLCBcIm5lZWRsZU91dGxpbmVcIiwgXCJuZWVkbGVTdGFydEV4dGVudFwiLCBcIm5lZWRsZUVuZEV4dGVudFwiLCBcIm5lZWRsZVNoYXBlXCIsIFwibmVlZGxlU3RhcnRXaWR0aFJhdGlvXCIsIFwibmVlZGxlRW5kV2lkdGhSYXRpb1wiLCBcIm5lZWRsZUJhc2VGZWF0dXJlV2lkdGhSYXRpb1wiLCBcIm5lZWRsZUJhc2VGZWF0dXJlRXh0ZW50XCIsIFwibmVlZGxlUG9pbnRGZWF0dXJlV2lkdGhSYXRpb1wiLCBcIm5lZWRsZVBvaW50RmVhdHVyZUV4dGVudFwiLCBcIm5lZWRsZVBpdm90V2lkdGhSYXRpb1wiLCBcIm5lZWRsZVBpdm90SW5uZXJXaWR0aFJhdGlvXCIsIFwibmVlZGxlUGl2b3RTaGFwZVwiLCBcInNjYWxlU3RhcnRFeHRlbnRcIiwgXCJuZWVkbGVQaXZvdEJydXNoXCIsIFwibmVlZGxlUGl2b3RPdXRsaW5lXCIsIFwibmVlZGxlU3Ryb2tlVGhpY2tuZXNzXCIsIFwibmVlZGxlUGl2b3RTdHJva2VUaGlja25lc3NcIiwgXCJzY2FsZUVuZEV4dGVudFwiLCBcImxhYmVsRXh0ZW50XCIsIFwibGFiZWxJbnRlcnZhbFwiLCBcInRpY2tTdGFydEV4dGVudFwiLCBcInRpY2tFbmRFeHRlbnRcIiwgXCJ0aWNrU3Ryb2tlVGhpY2tuZXNzXCIsIFwidGlja0JydXNoXCIsIFwiZm9udEJydXNoXCIsIFwibWlub3JUaWNrU3RhcnRFeHRlbnRcIiwgXCJtaW5vclRpY2tFbmRFeHRlbnRcIiwgXCJtaW5vclRpY2tTdHJva2VUaGlja25lc3NcIiwgXCJtaW5vclRpY2tCcnVzaFwiLCBcIm1pbm9yVGlja0NvdW50XCIsIFwic2NhbGVCcnVzaFwiLCBcImJhY2tpbmdCcnVzaFwiLCBcImJhY2tpbmdPdXRsaW5lXCIsIFwiYmFja2luZ1N0cm9rZVRoaWNrbmVzc1wiLCBcImJhY2tpbmdPdXRlckV4dGVudFwiLCBcImJhY2tpbmdPdmVyc3dlZXBcIiwgXCJzY2FsZU92ZXJzd2VlcFwiLCBcInNjYWxlT3ZlcnN3ZWVwU2hhcGVcIiwgXCJiYWNraW5nQ29ybmVyUmFkaXVzXCIsIFwiYmFja2luZ0lubmVyRXh0ZW50XCIsIFwiYmFja2luZ1NoYXBlXCIsIFwicmFkaXVzTXVsdGlwbGllclwiLCBcImR1cGxpY2F0ZUxhYmVsT21pc3Npb25TdHJhdGVneVwiLCBcImlzTmVlZGxlRHJhZ2dpbmdFbmFibGVkXCIsIFwiaXNOZWVkbGVEcmFnZ2luZ0NvbnN0cmFpbmVkXCIsIFwiZm9udFwiLCBcInRyYW5zaXRpb25Qcm9ncmVzc1wiLCBcInBpeGVsU2NhbGluZ1JhdGlvXCJdLFxuICAgIG91dHB1dHM6IFtcImZvcm1hdExhYmVsXCIsIFwiYWxpZ25MYWJlbFwiLCBcInZhbHVlQ2hhbmdlZFwiXVxufSlcbmV4cG9ydCBjbGFzcyBJZ1JhZGlhbEdhdWdlQ29tcG9uZW50IGV4dGVuZHMgSWdDb250cm9sQmFzZTxJZ1JhZGlhbEdhdWdlPiB7XG4gICAgY29uc3RydWN0b3IoZWw6IEVsZW1lbnRSZWYsIHJlbmRlcmVyOiBSZW5kZXJlciwgZGlmZmVyczogSXRlcmFibGVEaWZmZXJzLCBrdmFsRGlmZmVyczogS2V5VmFsdWVEaWZmZXJzLCBjZHI6IENoYW5nZURldGVjdG9yUmVmKSB7IHN1cGVyKGVsLCByZW5kZXJlciwgZGlmZmVycywga3ZhbERpZmZlcnMsIGNkcik7IH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgY29udGFpbmluZyB0aGUgbmFtZXMgb2YgYWxsIHRoZSByYW5nZXMgZGVsaW1pdGVkIHdpdGggYSBcXG4gc3ltYm9sLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGdldFJhbmdlTmFtZXMoKTogc3RyaW5nIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyByYW5nZSB0byB0aGUgcmFkaWFsIGdhdWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIFxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGFkZFJhbmdlKHZhbHVlOiBPYmplY3QpOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHNwZWNpZmllZCByYW5nZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBcbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyByZW1vdmVSYW5nZSh2YWx1ZTogT2JqZWN0KTogdm9pZCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHJhbmdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIFxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIHVwZGF0ZVJhbmdlKHZhbHVlOiBPYmplY3QpOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSByYW5nZXMgaW4gdGhlIHJhZGlhbCBnYXVnZS5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBjbGVhclJhbmdlcygpOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogU2NhbGVzIGEgdmFsdWUgb24gdGhlIGdhdWdlJ3MgbWFpbiBzY2FsZSB0byBhbiBhbmdsZSBhcm91bmQgdGhlIGNlbnRlciBwb2ludCBvZiB0aGUgZ2F1Z2UsIGluIHJhZGlhbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgc2NhbGVWYWx1ZSh2YWx1ZTogT2JqZWN0KTogdm9pZCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFVuc2NhbGVzIGEgdmFsdWUgZnJvbSBhbiBhbmdsZSBpbiByYWRpYW5zIHRvIHRoZSByZXByZXNlbnRlZCB2YWx1ZSBhbG9uZyB0aGUgbWFpbiBzY2FsZSBvZiB0aGUgZ2F1Z2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgdW5zY2FsZVZhbHVlKHZhbHVlOiBPYmplY3QpOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdmFsdWUgZm9yIHRoZSBtYWluIHNjYWxlIG9mIHRoZSBnYXVnZSBmb3IgYSBnaXZlbiBwb2ludCB3aXRoaW4gdGhlIGJvdW5kcyBvZiB0aGUgZ2F1Z2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geCBcbiAgICAgKiBAcGFyYW0geSBcbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBnZXRWYWx1ZUZvclBvaW50KHg6IE9iamVjdCwgeTogT2JqZWN0KTogbnVtYmVyIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcG9pbnQgb24gdGhlIGdhdWdlIGZvciBhIGdpdmVuIHNjYWxlIHZhbHVlIGFuZCBleHRlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgXG4gICAgICogQHBhcmFtIGV4dGVudCBcbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBnZXRQb2ludEZvclZhbHVlKHZhbHVlOiBPYmplY3QsIGV4dGVudDogT2JqZWN0KTogdm9pZCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgbWFpbiBnYXVnZSBuZWVkbGUgYm91bmRpbmcgYm94IGNvbnRhaW5zIHRoZSBwb2ludCBwcm92aWRlZCwgb3RoZXJ3aXNlIGZhbHNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHggXG4gICAgICogQHBhcmFtIHkgXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgbmVlZGxlQ29udGFpbnNQb2ludCh4OiBPYmplY3QsIHk6IE9iamVjdCk6IHZvaWQgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBFeHBvcnRzIHRoZSB2aXN1YWwgZGF0YSBmb3IgdGhlIHJhZGlhbCBnYXVnZS5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBleHBvcnRWaXN1YWxEYXRhKCk6IHZvaWQgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBGbHVzaGVzIHRoZSBnYXVnZS5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBmbHVzaCgpOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgd2lkZ2V0LlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGRlc3Ryb3koKTogdm9pZCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3R5bGUgd2FzIHVwZGF0ZWQgZm9yIHRoZSByYWRpYWwgZ2F1Z2UuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgc3R5bGVVcGRhdGVkKCk6IHZvaWQgeyByZXR1cm47IH07XG59Il19