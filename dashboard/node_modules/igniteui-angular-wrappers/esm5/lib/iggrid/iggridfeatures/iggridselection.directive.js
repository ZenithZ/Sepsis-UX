/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Directive, ElementRef } from "@angular/core";
import { Feature } from "../feature";
var IgGridSelectionFeature = /** @class */ (function (_super) {
    tslib_1.__extends(IgGridSelectionFeature, _super);
    function IgGridSelectionFeature(el) {
        return _super.call(this, el) || this;
    }
    /**
     * Destroys the selection widget.
     */
    /* istanbul ignore next */
    /**
     * Destroys the selection widget.
     * @return {?}
     */
    /* istanbul ignore next */
    IgGridSelectionFeature.prototype.destroy = /**
     * Destroys the selection widget.
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    /**
     * Clears all selected cells, selected rows, active cell and active row. Also updates the UI accordingly
     */
    /* istanbul ignore next */
    /**
     * Clears all selected cells, selected rows, active cell and active row. Also updates the UI accordingly
     * @return {?}
     */
    /* istanbul ignore next */
    IgGridSelectionFeature.prototype.clearSelection = /**
     * Clears all selected cells, selected rows, active cell and active row. Also updates the UI accordingly
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    /**
     * Selects a cell by row/col
     *
     * @param row     Row index
     * @param col     Column index
     * @param isFixed     If the cell is part of the fixed or unfixed area of the grid.
     */
    /* istanbul ignore next */
    /**
     * Selects a cell by row/col
     *
     * @param {?} row     Row index
     * @param {?} col     Column index
     * @param {?=} isFixed     If the cell is part of the fixed or unfixed area of the grid.
     * @return {?}
     */
    /* istanbul ignore next */
    IgGridSelectionFeature.prototype.selectCell = /**
     * Selects a cell by row/col
     *
     * @param {?} row     Row index
     * @param {?} col     Column index
     * @param {?=} isFixed     If the cell is part of the fixed or unfixed area of the grid.
     * @return {?}
     */
    /* istanbul ignore next */
    function (row, col, isFixed) { return; };
    ;
    /**
     * Selects a cell by row id/column key
     *
     * @param id     Row Id
     * @param colKey     Column key
     */
    /* istanbul ignore next */
    /**
     * Selects a cell by row id/column key
     *
     * @param {?} id     Row Id
     * @param {?} colKey     Column key
     * @return {?}
     */
    /* istanbul ignore next */
    IgGridSelectionFeature.prototype.selectCellById = /**
     * Selects a cell by row id/column key
     *
     * @param {?} id     Row Id
     * @param {?} colKey     Column key
     * @return {?}
     */
    /* istanbul ignore next */
    function (id, colKey) { return; };
    ;
    /**
     * Deselects a cell by row/col
     *
     * @param row     Row index
     * @param col     Column index
     * @param isFixed     If the cell is part of the fixed or unfixed area of the grid.
     */
    /* istanbul ignore next */
    /**
     * Deselects a cell by row/col
     *
     * @param {?} row     Row index
     * @param {?} col     Column index
     * @param {?=} isFixed     If the cell is part of the fixed or unfixed area of the grid.
     * @return {?}
     */
    /* istanbul ignore next */
    IgGridSelectionFeature.prototype.deselectCell = /**
     * Deselects a cell by row/col
     *
     * @param {?} row     Row index
     * @param {?} col     Column index
     * @param {?=} isFixed     If the cell is part of the fixed or unfixed area of the grid.
     * @return {?}
     */
    /* istanbul ignore next */
    function (row, col, isFixed) { return; };
    ;
    /**
     * Deselects a cell by row id/column key
     *
     * @param id     Row Id
     * @param colKey     Column key
     */
    /* istanbul ignore next */
    /**
     * Deselects a cell by row id/column key
     *
     * @param {?} id     Row Id
     * @param {?} colKey     Column key
     * @return {?}
     */
    /* istanbul ignore next */
    IgGridSelectionFeature.prototype.deselectCellById = /**
     * Deselects a cell by row id/column key
     *
     * @param {?} id     Row Id
     * @param {?} colKey     Column key
     * @return {?}
     */
    /* istanbul ignore next */
    function (id, colKey) { return; };
    ;
    /**
     * Selects a row by index
     *
     * @param index     Row index
     */
    /* istanbul ignore next */
    /**
     * Selects a row by index
     *
     * @param {?} index     Row index
     * @return {?}
     */
    /* istanbul ignore next */
    IgGridSelectionFeature.prototype.selectRow = /**
     * Selects a row by index
     *
     * @param {?} index     Row index
     * @return {?}
     */
    /* istanbul ignore next */
    function (index) { return; };
    ;
    /**
     * Selects a row by row id
     *
     * @param id     Row Id
     */
    /* istanbul ignore next */
    /**
     * Selects a row by row id
     *
     * @param {?} id     Row Id
     * @return {?}
     */
    /* istanbul ignore next */
    IgGridSelectionFeature.prototype.selectRowById = /**
     * Selects a row by row id
     *
     * @param {?} id     Row Id
     * @return {?}
     */
    /* istanbul ignore next */
    function (id) { return; };
    ;
    /**
     * Deselects a row by index
     *
     * @param index     Row index
     */
    /* istanbul ignore next */
    /**
     * Deselects a row by index
     *
     * @param {?} index     Row index
     * @return {?}
     */
    /* istanbul ignore next */
    IgGridSelectionFeature.prototype.deselectRow = /**
     * Deselects a row by index
     *
     * @param {?} index     Row index
     * @return {?}
     */
    /* istanbul ignore next */
    function (index) { return; };
    ;
    /**
     * Deselects a row by row id
     *
     * @param id     Row Id
     */
    /* istanbul ignore next */
    /**
     * Deselects a row by row id
     *
     * @param {?} id     Row Id
     * @return {?}
     */
    /* istanbul ignore next */
    IgGridSelectionFeature.prototype.deselectRowById = /**
     * Deselects a row by row id
     *
     * @param {?} id     Row Id
     * @return {?}
     */
    /* istanbul ignore next */
    function (id) { return; };
    ;
    /**
     * Returns an array of selected cells in arbitrary order where every objects has the format { element: , row: , index: , rowIndex: , columnKey: } .
     *
     * 				If multiple selection is disabled the function will return null.
     */
    /* istanbul ignore next */
    /**
     * Returns an array of selected cells in arbitrary order where every objects has the format { element: , row: , index: , rowIndex: , columnKey: } .
     *
     * 				If multiple selection is disabled the function will return null.
     * @return {?}
     */
    /* istanbul ignore next */
    IgGridSelectionFeature.prototype.selectedCells = /**
     * Returns an array of selected cells in arbitrary order where every objects has the format { element: , row: , index: , rowIndex: , columnKey: } .
     *
     * 				If multiple selection is disabled the function will return null.
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    /**
     * Returns an array of selected rows in arbitrary order where every object has the format { element: , index: } .
     *
     * 				If multiple selection is disabled the function will return null.
     */
    /* istanbul ignore next */
    /**
     * Returns an array of selected rows in arbitrary order where every object has the format { element: , index: } .
     *
     * 				If multiple selection is disabled the function will return null.
     * @return {?}
     */
    /* istanbul ignore next */
    IgGridSelectionFeature.prototype.selectedRows = /**
     * Returns an array of selected rows in arbitrary order where every object has the format { element: , index: } .
     *
     * 				If multiple selection is disabled the function will return null.
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    /**
     * Returns the currently selected cell that has the format { element: , row: , index: , rowIndex: , columnKey: }, if any.
     *
     * 				If multiple selection is enabled the function will return null.
     */
    /* istanbul ignore next */
    /**
     * Returns the currently selected cell that has the format { element: , row: , index: , rowIndex: , columnKey: }, if any.
     *
     * 				If multiple selection is enabled the function will return null.
     * @return {?}
     */
    /* istanbul ignore next */
    IgGridSelectionFeature.prototype.selectedCell = /**
     * Returns the currently selected cell that has the format { element: , row: , index: , rowIndex: , columnKey: }, if any.
     *
     * 				If multiple selection is enabled the function will return null.
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    /**
     * Returns the currently selected row that has the format { element: , index: }, if any.
     *
     * 				If multiple selection is enabled the function will return null.
     */
    /* istanbul ignore next */
    /**
     * Returns the currently selected row that has the format { element: , index: }, if any.
     *
     * 				If multiple selection is enabled the function will return null.
     * @return {?}
     */
    /* istanbul ignore next */
    IgGridSelectionFeature.prototype.selectedRow = /**
     * Returns the currently selected row that has the format { element: , index: }, if any.
     *
     * 				If multiple selection is enabled the function will return null.
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    /**
     * Returns the currently active (focused) cell that has the format { element: , row: , index: , rowIndex: , columnKey: }, if any.
     */
    /* istanbul ignore next */
    /**
     * Returns the currently active (focused) cell that has the format { element: , row: , index: , rowIndex: , columnKey: }, if any.
     * @return {?}
     */
    /* istanbul ignore next */
    IgGridSelectionFeature.prototype.activeCell = /**
     * Returns the currently active (focused) cell that has the format { element: , row: , index: , rowIndex: , columnKey: }, if any.
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    /**
     * Returns the currently active (focused) row that has the format { element: , index: }, if any.
     */
    /* istanbul ignore next */
    /**
     * Returns the currently active (focused) row that has the format { element: , index: }, if any.
     * @return {?}
     */
    /* istanbul ignore next */
    IgGridSelectionFeature.prototype.activeRow = /**
     * Returns the currently active (focused) row that has the format { element: , index: }, if any.
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    IgGridSelectionFeature.decorators = [
        { type: Directive, args: [{
                    selector: 'selection',
                    inputs: ["disabled", "create", "multipleSelection", "mouseDragSelect", "mode", "activation", "wrapAround", "skipChildren", "multipleCellSelectOnClick", "touchDragSelect", "persist", "allowMultipleRangeSelection"],
                    outputs: ["rowSelectionChanging", "rowSelectionChanged", "cellSelectionChanging", "cellSelectionChanged", "activeCellChanging", "activeCellChanged", "activeRowChanging", "activeRowChanged"]
                },] }
    ];
    /** @nocollapse */
    IgGridSelectionFeature.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    return IgGridSelectionFeature;
}(Feature));
export { IgGridSelectionFeature };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWdncmlkc2VsZWN0aW9uLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXItd3JhcHBlcnMvIiwic291cmNlcyI6WyJsaWIvaWdncmlkL2lnZ3JpZGZlYXR1cmVzL2lnZ3JpZHNlbGVjdGlvbi5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN0RCxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sWUFBWSxDQUFDO0FBRXJDO0lBSzRDLGtEQUF3QjtJQUNoRSxnQ0FBWSxFQUFjO2VBQ3RCLGtCQUFNLEVBQUUsQ0FBQztJQUNiLENBQUM7SUFFRDs7T0FFRztJQUNILDBCQUEwQjs7Ozs7O0lBQ25CLHdDQUFPOzs7OztJQUFkLGNBQXlCLE9BQU8sQ0FBQyxDQUFDO0lBQUEsQ0FBQztJQUVuQzs7T0FFRztJQUNILDBCQUEwQjs7Ozs7O0lBQ25CLCtDQUFjOzs7OztJQUFyQixjQUFnQyxPQUFPLENBQUMsQ0FBQztJQUFBLENBQUM7SUFFMUM7Ozs7OztPQU1HO0lBQ0gsMEJBQTBCOzs7Ozs7Ozs7O0lBQ25CLDJDQUFVOzs7Ozs7Ozs7SUFBakIsVUFBa0IsR0FBVyxFQUFFLEdBQVcsRUFBRSxPQUFpQixJQUFVLE9BQU8sQ0FBQyxDQUFDO0lBQUEsQ0FBQztJQUVqRjs7Ozs7T0FLRztJQUNILDBCQUEwQjs7Ozs7Ozs7O0lBQ25CLCtDQUFjOzs7Ozs7OztJQUFyQixVQUFzQixFQUFVLEVBQUUsTUFBYyxJQUFVLE9BQU8sQ0FBQyxDQUFDO0lBQUEsQ0FBQztJQUVwRTs7Ozs7O09BTUc7SUFDSCwwQkFBMEI7Ozs7Ozs7Ozs7SUFDbkIsNkNBQVk7Ozs7Ozs7OztJQUFuQixVQUFvQixHQUFXLEVBQUUsR0FBVyxFQUFFLE9BQWlCLElBQVUsT0FBTyxDQUFDLENBQUM7SUFBQSxDQUFDO0lBRW5GOzs7OztPQUtHO0lBQ0gsMEJBQTBCOzs7Ozs7Ozs7SUFDbkIsaURBQWdCOzs7Ozs7OztJQUF2QixVQUF3QixFQUFVLEVBQUUsTUFBYyxJQUFVLE9BQU8sQ0FBQyxDQUFDO0lBQUEsQ0FBQztJQUV0RTs7OztPQUlHO0lBQ0gsMEJBQTBCOzs7Ozs7OztJQUNuQiwwQ0FBUzs7Ozs7OztJQUFoQixVQUFpQixLQUFhLElBQVUsT0FBTyxDQUFDLENBQUM7SUFBQSxDQUFDO0lBRWxEOzs7O09BSUc7SUFDSCwwQkFBMEI7Ozs7Ozs7O0lBQ25CLDhDQUFhOzs7Ozs7O0lBQXBCLFVBQXFCLEVBQVUsSUFBVSxPQUFPLENBQUMsQ0FBQztJQUFBLENBQUM7SUFFbkQ7Ozs7T0FJRztJQUNILDBCQUEwQjs7Ozs7Ozs7SUFDbkIsNENBQVc7Ozs7Ozs7SUFBbEIsVUFBbUIsS0FBYSxJQUFVLE9BQU8sQ0FBQyxDQUFDO0lBQUEsQ0FBQztJQUVwRDs7OztPQUlHO0lBQ0gsMEJBQTBCOzs7Ozs7OztJQUNuQixnREFBZTs7Ozs7OztJQUF0QixVQUF1QixFQUFVLElBQVUsT0FBTyxDQUFDLENBQUM7SUFBQSxDQUFDO0lBRXJEOzs7O09BSUc7SUFDSCwwQkFBMEI7Ozs7Ozs7O0lBQ25CLDhDQUFhOzs7Ozs7O0lBQXBCLGNBQWdDLE9BQU8sQ0FBQyxDQUFDO0lBQUEsQ0FBQztJQUUxQzs7OztPQUlHO0lBQ0gsMEJBQTBCOzs7Ozs7OztJQUNuQiw2Q0FBWTs7Ozs7OztJQUFuQixjQUErQixPQUFPLENBQUMsQ0FBQztJQUFBLENBQUM7SUFFekM7Ozs7T0FJRztJQUNILDBCQUEwQjs7Ozs7Ozs7SUFDbkIsNkNBQVk7Ozs7Ozs7SUFBbkIsY0FBZ0MsT0FBTyxDQUFDLENBQUM7SUFBQSxDQUFDO0lBRTFDOzs7O09BSUc7SUFDSCwwQkFBMEI7Ozs7Ozs7O0lBQ25CLDRDQUFXOzs7Ozs7O0lBQWxCLGNBQStCLE9BQU8sQ0FBQyxDQUFDO0lBQUEsQ0FBQztJQUV6Qzs7T0FFRztJQUNILDBCQUEwQjs7Ozs7O0lBQ25CLDJDQUFVOzs7OztJQUFqQixjQUE4QixPQUFPLENBQUMsQ0FBQztJQUFBLENBQUM7SUFFeEM7O09BRUc7SUFDSCwwQkFBMEI7Ozs7OztJQUNuQiwwQ0FBUzs7Ozs7SUFBaEIsY0FBNkIsT0FBTyxDQUFDLENBQUM7SUFBQSxDQUFDOztnQkF0STFDLFNBQVMsU0FBQztvQkFDUCxRQUFRLEVBQUUsV0FBVztvQkFDckIsTUFBTSxFQUFFLENBQUMsVUFBVSxFQUFFLFFBQVEsRUFBRSxtQkFBbUIsRUFBRSxpQkFBaUIsRUFBRSxNQUFNLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxjQUFjLEVBQUUsMkJBQTJCLEVBQUUsaUJBQWlCLEVBQUUsU0FBUyxFQUFFLDZCQUE2QixDQUFDO29CQUNwTixPQUFPLEVBQUUsQ0FBQyxzQkFBc0IsRUFBRSxxQkFBcUIsRUFBRSx1QkFBdUIsRUFBRSxzQkFBc0IsRUFBRSxvQkFBb0IsRUFBRSxtQkFBbUIsRUFBRSxtQkFBbUIsRUFBRSxrQkFBa0IsQ0FBQztpQkFDaE07Ozs7Z0JBUG1CLFVBQVU7O0lBMEk5Qiw2QkFBQztDQUFBLEFBdklELENBSzRDLE9BQU8sR0FrSWxEO1NBbElZLHNCQUFzQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiB9IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQgeyBGZWF0dXJlIH0gZnJvbSBcIi4uL2ZlYXR1cmVcIjtcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdzZWxlY3Rpb24nLFxuICAgIGlucHV0czogW1wiZGlzYWJsZWRcIiwgXCJjcmVhdGVcIiwgXCJtdWx0aXBsZVNlbGVjdGlvblwiLCBcIm1vdXNlRHJhZ1NlbGVjdFwiLCBcIm1vZGVcIiwgXCJhY3RpdmF0aW9uXCIsIFwid3JhcEFyb3VuZFwiLCBcInNraXBDaGlsZHJlblwiLCBcIm11bHRpcGxlQ2VsbFNlbGVjdE9uQ2xpY2tcIiwgXCJ0b3VjaERyYWdTZWxlY3RcIiwgXCJwZXJzaXN0XCIsIFwiYWxsb3dNdWx0aXBsZVJhbmdlU2VsZWN0aW9uXCJdLFxuICAgIG91dHB1dHM6IFtcInJvd1NlbGVjdGlvbkNoYW5naW5nXCIsIFwicm93U2VsZWN0aW9uQ2hhbmdlZFwiLCBcImNlbGxTZWxlY3Rpb25DaGFuZ2luZ1wiLCBcImNlbGxTZWxlY3Rpb25DaGFuZ2VkXCIsIFwiYWN0aXZlQ2VsbENoYW5naW5nXCIsIFwiYWN0aXZlQ2VsbENoYW5nZWRcIiwgXCJhY3RpdmVSb3dDaGFuZ2luZ1wiLCBcImFjdGl2ZVJvd0NoYW5nZWRcIl1cbn0pXG5leHBvcnQgY2xhc3MgSWdHcmlkU2VsZWN0aW9uRmVhdHVyZSBleHRlbmRzIEZlYXR1cmU8SWdHcmlkU2VsZWN0aW9uPiB7XG4gICAgY29uc3RydWN0b3IoZWw6IEVsZW1lbnRSZWYpIHtcbiAgICAgICAgc3VwZXIoZWwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBzZWxlY3Rpb24gd2lkZ2V0LlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGRlc3Ryb3koKTogdm9pZCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgc2VsZWN0ZWQgY2VsbHMsIHNlbGVjdGVkIHJvd3MsIGFjdGl2ZSBjZWxsIGFuZCBhY3RpdmUgcm93LiBBbHNvIHVwZGF0ZXMgdGhlIFVJIGFjY29yZGluZ2x5XG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgY2xlYXJTZWxlY3Rpb24oKTogdm9pZCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgYSBjZWxsIGJ5IHJvdy9jb2xcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb3cgICAgIFJvdyBpbmRleFxuICAgICAqIEBwYXJhbSBjb2wgICAgIENvbHVtbiBpbmRleFxuICAgICAqIEBwYXJhbSBpc0ZpeGVkICAgICBJZiB0aGUgY2VsbCBpcyBwYXJ0IG9mIHRoZSBmaXhlZCBvciB1bmZpeGVkIGFyZWEgb2YgdGhlIGdyaWQuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgc2VsZWN0Q2VsbChyb3c6IG51bWJlciwgY29sOiBudW1iZXIsIGlzRml4ZWQ/OiBib29sZWFuKTogdm9pZCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgYSBjZWxsIGJ5IHJvdyBpZC9jb2x1bW4ga2V5XG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgICAgIFJvdyBJZFxuICAgICAqIEBwYXJhbSBjb2xLZXkgICAgIENvbHVtbiBrZXlcbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBzZWxlY3RDZWxsQnlJZChpZDogT2JqZWN0LCBjb2xLZXk6IHN0cmluZyk6IHZvaWQgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBEZXNlbGVjdHMgYSBjZWxsIGJ5IHJvdy9jb2xcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb3cgICAgIFJvdyBpbmRleFxuICAgICAqIEBwYXJhbSBjb2wgICAgIENvbHVtbiBpbmRleFxuICAgICAqIEBwYXJhbSBpc0ZpeGVkICAgICBJZiB0aGUgY2VsbCBpcyBwYXJ0IG9mIHRoZSBmaXhlZCBvciB1bmZpeGVkIGFyZWEgb2YgdGhlIGdyaWQuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgZGVzZWxlY3RDZWxsKHJvdzogbnVtYmVyLCBjb2w6IG51bWJlciwgaXNGaXhlZD86IGJvb2xlYW4pOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogRGVzZWxlY3RzIGEgY2VsbCBieSByb3cgaWQvY29sdW1uIGtleVxuICAgICAqXG4gICAgICogQHBhcmFtIGlkICAgICBSb3cgSWRcbiAgICAgKiBAcGFyYW0gY29sS2V5ICAgICBDb2x1bW4ga2V5XG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgZGVzZWxlY3RDZWxsQnlJZChpZDogT2JqZWN0LCBjb2xLZXk6IHN0cmluZyk6IHZvaWQgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIGEgcm93IGJ5IGluZGV4XG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kZXggICAgIFJvdyBpbmRleFxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIHNlbGVjdFJvdyhpbmRleDogbnVtYmVyKTogdm9pZCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgYSByb3cgYnkgcm93IGlkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgICAgIFJvdyBJZFxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIHNlbGVjdFJvd0J5SWQoaWQ6IE9iamVjdCk6IHZvaWQgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBEZXNlbGVjdHMgYSByb3cgYnkgaW5kZXhcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmRleCAgICAgUm93IGluZGV4XG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgZGVzZWxlY3RSb3coaW5kZXg6IG51bWJlcik6IHZvaWQgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBEZXNlbGVjdHMgYSByb3cgYnkgcm93IGlkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgICAgIFJvdyBJZFxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGRlc2VsZWN0Um93QnlJZChpZDogT2JqZWN0KTogdm9pZCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2Ygc2VsZWN0ZWQgY2VsbHMgaW4gYXJiaXRyYXJ5IG9yZGVyIHdoZXJlIGV2ZXJ5IG9iamVjdHMgaGFzIHRoZSBmb3JtYXQgeyBlbGVtZW50OiAsIHJvdzogLCBpbmRleDogLCByb3dJbmRleDogLCBjb2x1bW5LZXk6IH0gLlxuICAgICAqIFx0XHRcdFxuICAgICAqIFx0XHRcdFx0SWYgbXVsdGlwbGUgc2VsZWN0aW9uIGlzIGRpc2FibGVkIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiBudWxsLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIHNlbGVjdGVkQ2VsbHMoKTogYW55W10geyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHNlbGVjdGVkIHJvd3MgaW4gYXJiaXRyYXJ5IG9yZGVyIHdoZXJlIGV2ZXJ5IG9iamVjdCBoYXMgdGhlIGZvcm1hdCB7IGVsZW1lbnQ6ICwgaW5kZXg6IH0gLlxuICAgICAqIFx0XHRcdFxuICAgICAqIFx0XHRcdFx0SWYgbXVsdGlwbGUgc2VsZWN0aW9uIGlzIGRpc2FibGVkIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiBudWxsLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIHNlbGVjdGVkUm93cygpOiBhbnlbXSB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBjZWxsIHRoYXQgaGFzIHRoZSBmb3JtYXQgeyBlbGVtZW50OiAsIHJvdzogLCBpbmRleDogLCByb3dJbmRleDogLCBjb2x1bW5LZXk6IH0sIGlmIGFueS5cbiAgICAgKiBcdFx0XHRcbiAgICAgKiBcdFx0XHRcdElmIG11bHRpcGxlIHNlbGVjdGlvbiBpcyBlbmFibGVkIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiBudWxsLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIHNlbGVjdGVkQ2VsbCgpOiBPYmplY3QgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgcm93IHRoYXQgaGFzIHRoZSBmb3JtYXQgeyBlbGVtZW50OiAsIGluZGV4OiB9LCBpZiBhbnkuXG4gICAgICogXHRcdFx0XG4gICAgICogXHRcdFx0XHRJZiBtdWx0aXBsZSBzZWxlY3Rpb24gaXMgZW5hYmxlZCB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gbnVsbC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBzZWxlY3RlZFJvdygpOiBPYmplY3QgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50bHkgYWN0aXZlIChmb2N1c2VkKSBjZWxsIHRoYXQgaGFzIHRoZSBmb3JtYXQgeyBlbGVtZW50OiAsIHJvdzogLCBpbmRleDogLCByb3dJbmRleDogLCBjb2x1bW5LZXk6IH0sIGlmIGFueS5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBhY3RpdmVDZWxsKCk6IE9iamVjdCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnRseSBhY3RpdmUgKGZvY3VzZWQpIHJvdyB0aGF0IGhhcyB0aGUgZm9ybWF0IHsgZWxlbWVudDogLCBpbmRleDogfSwgaWYgYW55LlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGFjdGl2ZVJvdygpOiBPYmplY3QgeyByZXR1cm47IH07XG59Il19