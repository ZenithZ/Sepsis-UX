/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { ElementRef, Directive } from "@angular/core";
import { Feature } from "../feature";
var IgGridColumnFixingFeature = /** @class */ (function (_super) {
    tslib_1.__extends(IgGridColumnFixingFeature, _super);
    function IgGridColumnFixingFeature(el) {
        return _super.call(this, el) || this;
    }
    /**
     * Unfixes a column by specified column identifier - column key or column index.
     *
     * @param colIdentifier    An identifier of the column to be unfixed - column index or column key.
     * @param target    Key of the column where the unfixed column should move to.
     * @param after    Specifies where the unfixed column should be rendered after or before the target column. This parameter is disregarded if there is no target column specified.
     */
    /* istanbul ignore next */
    /**
     * Unfixes a column by specified column identifier - column key or column index.
     *
     * @param {?} colIdentifier    An identifier of the column to be unfixed - column index or column key.
     * @param {?=} target    Key of the column where the unfixed column should move to.
     * @param {?=} after    Specifies where the unfixed column should be rendered after or before the target column. This parameter is disregarded if there is no target column specified.
     * @return {?}
     */
    /* istanbul ignore next */
    IgGridColumnFixingFeature.prototype.unfixColumn = /**
     * Unfixes a column by specified column identifier - column key or column index.
     *
     * @param {?} colIdentifier    An identifier of the column to be unfixed - column index or column key.
     * @param {?=} target    Key of the column where the unfixed column should move to.
     * @param {?=} after    Specifies where the unfixed column should be rendered after or before the target column. This parameter is disregarded if there is no target column specified.
     * @return {?}
     */
    /* istanbul ignore next */
    function (colIdentifier, target, after) { return; };
    ;
    /**
     * Checks whether the heights of fixed and unfixed tables are equal - if not sync them. Similar check is made for heights of table rows.
     */
    /* istanbul ignore next */
    /**
     * Checks whether the heights of fixed and unfixed tables are equal - if not sync them. Similar check is made for heights of table rows.
     * @return {?}
     */
    /* istanbul ignore next */
    IgGridColumnFixingFeature.prototype.checkAndSyncHeights = /**
     * Checks whether the heights of fixed and unfixed tables are equal - if not sync them. Similar check is made for heights of table rows.
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    /**
     * If the 'check' argument is set to true, checks whether the heights of fixed and unfixed tables are equal, if not sync them. Similar check is made for heights of table rows. If the clearRowsHeights argument is set to true, clears rows heights before syncing them.
     *
     * @param check    If set to true, checks whether the heights of fixed and unfixed tables are equal, if not sync them. If this argument is set to false sync is performed regardless of the current heights.
     * @param clearRowsHeights    Clears row heigths for all visible rows.
     */
    /* istanbul ignore next */
    /**
     * If the 'check' argument is set to true, checks whether the heights of fixed and unfixed tables are equal, if not sync them. Similar check is made for heights of table rows. If the clearRowsHeights argument is set to true, clears rows heights before syncing them.
     *
     * @param {?=} check    If set to true, checks whether the heights of fixed and unfixed tables are equal, if not sync them. If this argument is set to false sync is performed regardless of the current heights.
     * @param {?=} clearRowsHeights    Clears row heigths for all visible rows.
     * @return {?}
     */
    /* istanbul ignore next */
    IgGridColumnFixingFeature.prototype.syncHeights = /**
     * If the 'check' argument is set to true, checks whether the heights of fixed and unfixed tables are equal, if not sync them. Similar check is made for heights of table rows. If the clearRowsHeights argument is set to true, clears rows heights before syncing them.
     *
     * @param {?=} check    If set to true, checks whether the heights of fixed and unfixed tables are equal, if not sync them. If this argument is set to false sync is performed regardless of the current heights.
     * @param {?=} clearRowsHeights    Clears row heigths for all visible rows.
     * @return {?}
     */
    /* istanbul ignore next */
    function (check, clearRowsHeights) { return; };
    ;
    /**
     * Returns whether the column with the specified key is a column group header, when the [multi-column headers](http://www.igniteui.com/help/iggrid-multicolumnheaders-landingpage) feature is used.
     *
     * @param colKey    The key of the column to perform the check for.
     */
    /* istanbul ignore next */
    /**
     * Returns whether the column with the specified key is a column group header, when the [multi-column headers](http://www.igniteui.com/help/iggrid-multicolumnheaders-landingpage) feature is used.
     *
     * @param {?} colKey    The key of the column to perform the check for.
     * @return {?}
     */
    /* istanbul ignore next */
    IgGridColumnFixingFeature.prototype.isGroupHeader = /**
     * Returns whether the column with the specified key is a column group header, when the [multi-column headers](http://www.igniteui.com/help/iggrid-multicolumnheaders-landingpage) feature is used.
     *
     * @param {?} colKey    The key of the column to perform the check for.
     * @return {?}
     */
    /* istanbul ignore next */
    function (colKey) { return; };
    ;
    /**
     * Checks whether column fixing is allowed for the specified columns. It should not be allowed if there is only one visible column in the unfixed area.
     *
     * @param columns    Array of columns and/or column identifiers - could be column indexes, column keys, column object or mixed.
     */
    /* istanbul ignore next */
    /**
     * Checks whether column fixing is allowed for the specified columns. It should not be allowed if there is only one visible column in the unfixed area.
     *
     * @param {?} columns    Array of columns and/or column identifiers - could be column indexes, column keys, column object or mixed.
     * @return {?}
     */
    /* istanbul ignore next */
    IgGridColumnFixingFeature.prototype.checkFixingAllowed = /**
     * Checks whether column fixing is allowed for the specified columns. It should not be allowed if there is only one visible column in the unfixed area.
     *
     * @param {?} columns    Array of columns and/or column identifiers - could be column indexes, column keys, column object or mixed.
     * @return {?}
     */
    /* istanbul ignore next */
    function (columns) { return; };
    ;
    /**
     * Checks whether unfixing is allowed for the specified columns. It should not be allowed if there is only one visible column in the fixed area.
     *
     * @param columns    Array of columns and/or column identifiers - could be column indexes, column keys, column object or mixed.
     */
    /* istanbul ignore next */
    /**
     * Checks whether unfixing is allowed for the specified columns. It should not be allowed if there is only one visible column in the fixed area.
     *
     * @param {?} columns    Array of columns and/or column identifiers - could be column indexes, column keys, column object or mixed.
     * @return {?}
     */
    /* istanbul ignore next */
    IgGridColumnFixingFeature.prototype.checkUnfixingAllowed = /**
     * Checks whether unfixing is allowed for the specified columns. It should not be allowed if there is only one visible column in the fixed area.
     *
     * @param {?} columns    Array of columns and/or column identifiers - could be column indexes, column keys, column object or mixed.
     * @return {?}
     */
    /* istanbul ignore next */
    function (columns) { return; };
    ;
    /**
     * Fixes non-data columns (such as the row numbering column of row selectors) if any and if [fixingDirection](ui.iggridcolumnfixing#options:fixingDirection) is left. Does nothing if the non-data columns are already fixed.
     */
    /* istanbul ignore next */
    /**
     * Fixes non-data columns (such as the row numbering column of row selectors) if any and if [fixingDirection](ui.iggridcolumnfixing#options:fixingDirection) is left. Does nothing if the non-data columns are already fixed.
     * @return {?}
     */
    /* istanbul ignore next */
    IgGridColumnFixingFeature.prototype.fixNonDataColumns = /**
     * Fixes non-data columns (such as the row numbering column of row selectors) if any and if [fixingDirection](ui.iggridcolumnfixing#options:fixingDirection) is left. Does nothing if the non-data columns are already fixed.
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    /**
     * This function is deprecated - use function fixNonDataColumns.
     */
    /* istanbul ignore next */
    /**
     * This function is deprecated - use function fixNonDataColumns.
     * @return {?}
     */
    /* istanbul ignore next */
    IgGridColumnFixingFeature.prototype.fixDataSkippedColumns = /**
     * This function is deprecated - use function fixNonDataColumns.
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    /**
     * Unfixes non-data columns (such as the row numbering column of row selectors) if any and if [fixingDirection](ui.iggridcolumnfixing#options:fixingDirection) is left. Does nothing if the non-data columns are already fixed.
     */
    /* istanbul ignore next */
    /**
     * Unfixes non-data columns (such as the row numbering column of row selectors) if any and if [fixingDirection](ui.iggridcolumnfixing#options:fixingDirection) is left. Does nothing if the non-data columns are already fixed.
     * @return {?}
     */
    /* istanbul ignore next */
    IgGridColumnFixingFeature.prototype.unfixNonDataColumns = /**
     * Unfixes non-data columns (such as the row numbering column of row selectors) if any and if [fixingDirection](ui.iggridcolumnfixing#options:fixingDirection) is left. Does nothing if the non-data columns are already fixed.
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    /**
     * This function is deprecated - use function unfixNonDataColumns.
     */
    /* istanbul ignore next */
    /**
     * This function is deprecated - use function unfixNonDataColumns.
     * @return {?}
     */
    /* istanbul ignore next */
    IgGridColumnFixingFeature.prototype.unfixDataSkippedColumns = /**
     * This function is deprecated - use function unfixNonDataColumns.
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    /**
     * Unfixes all fixed columns.
     */
    /* istanbul ignore next */
    /**
     * Unfixes all fixed columns.
     * @return {?}
     */
    /* istanbul ignore next */
    IgGridColumnFixingFeature.prototype.unfixAllColumns = /**
     * Unfixes all fixed columns.
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    /**
     * Syncs rows heights between two collections of rows.
     *
     * @param $trs    An array of rows of the first(fixed/unfixed) container.
     * @param $anotherRows    An array of rows of the second(fixed/unfixed) container.
     */
    /* istanbul ignore next */
    /**
     * Syncs rows heights between two collections of rows.
     *
     * @param {?} $trs    An array of rows of the first(fixed/unfixed) container.
     * @param {?} $anotherRows    An array of rows of the second(fixed/unfixed) container.
     * @return {?}
     */
    /* istanbul ignore next */
    IgGridColumnFixingFeature.prototype.syncRowsHeights = /**
     * Syncs rows heights between two collections of rows.
     *
     * @param {?} $trs    An array of rows of the first(fixed/unfixed) container.
     * @param {?} $anotherRows    An array of rows of the second(fixed/unfixed) container.
     * @return {?}
     */
    /* istanbul ignore next */
    function ($trs, $anotherRows) { return; };
    ;
    /**
     * Calculates widths of the fixed columns.
     *
     * @param fCols    Array of grid columns. If not set then the total width of the fixed columns are returned.
     * @param excludeNonDataColumns    If set to true do not calculate the width of non-data fixed columns (like the row selector row numbering column).
     * @param includeHidden    If set to true calculates width of the hidden fixed columns (their initial width before hiding).
     */
    /* istanbul ignore next */
    /**
     * Calculates widths of the fixed columns.
     *
     * @param {?=} fCols    Array of grid columns. If not set then the total width of the fixed columns are returned.
     * @param {?=} excludeNonDataColumns    If set to true do not calculate the width of non-data fixed columns (like the row selector row numbering column).
     * @param {?=} includeHidden    If set to true calculates width of the hidden fixed columns (their initial width before hiding).
     * @return {?}
     */
    /* istanbul ignore next */
    IgGridColumnFixingFeature.prototype.getWidthOfFixedColumns = /**
     * Calculates widths of the fixed columns.
     *
     * @param {?=} fCols    Array of grid columns. If not set then the total width of the fixed columns are returned.
     * @param {?=} excludeNonDataColumns    If set to true do not calculate the width of non-data fixed columns (like the row selector row numbering column).
     * @param {?=} includeHidden    If set to true calculates width of the hidden fixed columns (their initial width before hiding).
     * @return {?}
     */
    /* istanbul ignore next */
    function (fCols, excludeNonDataColumns, includeHidden) { return; };
    ;
    /**
     * Destroys the column fixing widget
     */
    /* istanbul ignore next */
    /**
     * Destroys the column fixing widget
     * @return {?}
     */
    /* istanbul ignore next */
    IgGridColumnFixingFeature.prototype.destroy = /**
     * Destroys the column fixing widget
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    IgGridColumnFixingFeature.decorators = [
        { type: Directive, args: [{
                    selector: 'column-fixing',
                    inputs: ["disabled", "create", "headerFixButtonText", "headerUnfixButtonText", "showFixButtons", "syncRowHeights", "scrollDelta", "fixingDirection", "columnSettings", "featureChooserTextFixedColumn", "featureChooserTextUnfixedColumn", "minimalVisibleAreaWidth", "fixNondataColumns", "populateDataRowsAttributes"],
                    outputs: ["columnFixing", "columnFixed", "columnUnfixing", "columnUnfixed", "columnFixingRefused", "columnUnfixingRefused"]
                },] }
    ];
    /** @nocollapse */
    IgGridColumnFixingFeature.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    return IgGridColumnFixingFeature;
}(Feature));
export { IgGridColumnFixingFeature };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWdncmlkY29sdW1uZml4aW5nLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXItd3JhcHBlcnMvIiwic291cmNlcyI6WyJsaWIvaWdncmlkL2lnZ3JpZGZlYXR1cmVzL2lnZ3JpZGNvbHVtbmZpeGluZy5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLFNBQVMsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN0RCxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sWUFBWSxDQUFDO0FBR3JDO0lBSytDLHFEQUEyQjtJQUN0RSxtQ0FBWSxFQUFjO2VBQ3RCLGtCQUFNLEVBQUUsQ0FBQztJQUNiLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSCwwQkFBMEI7Ozs7Ozs7Ozs7SUFDbkIsK0NBQVc7Ozs7Ozs7OztJQUFsQixVQUFtQixhQUFxQixFQUFFLE1BQWUsRUFBRSxLQUFlLElBQVksT0FBTyxDQUFDLENBQUM7SUFBQSxDQUFDO0lBRWhHOztPQUVHO0lBQ0gsMEJBQTBCOzs7Ozs7SUFDbkIsdURBQW1COzs7OztJQUExQixjQUFxQyxPQUFPLENBQUMsQ0FBQztJQUFBLENBQUM7SUFFL0M7Ozs7O09BS0c7SUFDSCwwQkFBMEI7Ozs7Ozs7OztJQUNuQiwrQ0FBVzs7Ozs7Ozs7SUFBbEIsVUFBbUIsS0FBZSxFQUFFLGdCQUEwQixJQUFVLE9BQU8sQ0FBQyxDQUFDO0lBQUEsQ0FBQztJQUVsRjs7OztPQUlHO0lBQ0gsMEJBQTBCOzs7Ozs7OztJQUNuQixpREFBYTs7Ozs7OztJQUFwQixVQUFxQixNQUFjLElBQWEsT0FBTyxDQUFDLENBQUM7SUFBQSxDQUFDO0lBRTFEOzs7O09BSUc7SUFDSCwwQkFBMEI7Ozs7Ozs7O0lBQ25CLHNEQUFrQjs7Ozs7OztJQUF6QixVQUEwQixPQUFjLElBQWEsT0FBTyxDQUFDLENBQUM7SUFBQSxDQUFDO0lBRS9EOzs7O09BSUc7SUFDSCwwQkFBMEI7Ozs7Ozs7O0lBQ25CLHdEQUFvQjs7Ozs7OztJQUEzQixVQUE0QixPQUFjLElBQWEsT0FBTyxDQUFDLENBQUM7SUFBQSxDQUFDO0lBRWpFOztPQUVHO0lBQ0gsMEJBQTBCOzs7Ozs7SUFDbkIscURBQWlCOzs7OztJQUF4QixjQUFtQyxPQUFPLENBQUMsQ0FBQztJQUFBLENBQUM7SUFFN0M7O09BRUc7SUFDSCwwQkFBMEI7Ozs7OztJQUNuQix5REFBcUI7Ozs7O0lBQTVCLGNBQXVDLE9BQU8sQ0FBQyxDQUFDO0lBQUEsQ0FBQztJQUVqRDs7T0FFRztJQUNILDBCQUEwQjs7Ozs7O0lBQ25CLHVEQUFtQjs7Ozs7SUFBMUIsY0FBcUMsT0FBTyxDQUFDLENBQUM7SUFBQSxDQUFDO0lBRS9DOztPQUVHO0lBQ0gsMEJBQTBCOzs7Ozs7SUFDbkIsMkRBQXVCOzs7OztJQUE5QixjQUF5QyxPQUFPLENBQUMsQ0FBQztJQUFBLENBQUM7SUFFbkQ7O09BRUc7SUFDSCwwQkFBMEI7Ozs7OztJQUNuQixtREFBZTs7Ozs7SUFBdEIsY0FBaUMsT0FBTyxDQUFDLENBQUM7SUFBQSxDQUFDO0lBRTNDOzs7OztPQUtHO0lBQ0gsMEJBQTBCOzs7Ozs7Ozs7SUFDbkIsbURBQWU7Ozs7Ozs7O0lBQXRCLFVBQXVCLElBQVcsRUFBRSxZQUFtQixJQUFVLE9BQU8sQ0FBQyxDQUFDO0lBQUEsQ0FBQztJQUUzRTs7Ozs7O09BTUc7SUFDSCwwQkFBMEI7Ozs7Ozs7Ozs7SUFDbkIsMERBQXNCOzs7Ozs7Ozs7SUFBN0IsVUFBOEIsS0FBYSxFQUFFLHFCQUErQixFQUFFLGFBQXVCLElBQVksT0FBTyxDQUFDLENBQUM7SUFBQSxDQUFDO0lBRTNIOztPQUVHO0lBQ0gsMEJBQTBCOzs7Ozs7SUFDbkIsMkNBQU87Ozs7O0lBQWQsY0FBeUIsT0FBTyxDQUFDLENBQUM7SUFBQSxDQUFDOztnQkFoSHRDLFNBQVMsU0FBQztvQkFDUCxRQUFRLEVBQUUsZUFBZTtvQkFDekIsTUFBTSxFQUFFLENBQUMsVUFBVSxFQUFFLFFBQVEsRUFBRSxxQkFBcUIsRUFBRSx1QkFBdUIsRUFBRSxnQkFBZ0IsRUFBRSxnQkFBZ0IsRUFBRSxhQUFhLEVBQUUsaUJBQWlCLEVBQUUsZ0JBQWdCLEVBQUUsK0JBQStCLEVBQUUsaUNBQWlDLEVBQUUseUJBQXlCLEVBQUUsbUJBQW1CLEVBQUUsNEJBQTRCLENBQUM7b0JBQ3hULE9BQU8sRUFBRSxDQUFDLGNBQWMsRUFBRSxhQUFhLEVBQUUsZ0JBQWdCLEVBQUUsZUFBZSxFQUFFLHFCQUFxQixFQUFFLHVCQUF1QixDQUFDO2lCQUM5SDs7OztnQkFSUSxVQUFVOztJQXFIbkIsZ0NBQUM7Q0FBQSxBQWpIRCxDQUsrQyxPQUFPLEdBNEdyRDtTQTVHWSx5QkFBeUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFbGVtZW50UmVmLCBEaXJlY3RpdmUgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgRmVhdHVyZSB9IGZyb20gXCIuLi9mZWF0dXJlXCI7XG5cblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdjb2x1bW4tZml4aW5nJyxcbiAgICBpbnB1dHM6IFtcImRpc2FibGVkXCIsIFwiY3JlYXRlXCIsIFwiaGVhZGVyRml4QnV0dG9uVGV4dFwiLCBcImhlYWRlclVuZml4QnV0dG9uVGV4dFwiLCBcInNob3dGaXhCdXR0b25zXCIsIFwic3luY1Jvd0hlaWdodHNcIiwgXCJzY3JvbGxEZWx0YVwiLCBcImZpeGluZ0RpcmVjdGlvblwiLCBcImNvbHVtblNldHRpbmdzXCIsIFwiZmVhdHVyZUNob29zZXJUZXh0Rml4ZWRDb2x1bW5cIiwgXCJmZWF0dXJlQ2hvb3NlclRleHRVbmZpeGVkQ29sdW1uXCIsIFwibWluaW1hbFZpc2libGVBcmVhV2lkdGhcIiwgXCJmaXhOb25kYXRhQ29sdW1uc1wiLCBcInBvcHVsYXRlRGF0YVJvd3NBdHRyaWJ1dGVzXCJdLFxuICAgIG91dHB1dHM6IFtcImNvbHVtbkZpeGluZ1wiLCBcImNvbHVtbkZpeGVkXCIsIFwiY29sdW1uVW5maXhpbmdcIiwgXCJjb2x1bW5VbmZpeGVkXCIsIFwiY29sdW1uRml4aW5nUmVmdXNlZFwiLCBcImNvbHVtblVuZml4aW5nUmVmdXNlZFwiXVxufSlcbmV4cG9ydCBjbGFzcyBJZ0dyaWRDb2x1bW5GaXhpbmdGZWF0dXJlIGV4dGVuZHMgRmVhdHVyZTxJZ0dyaWRDb2x1bW5GaXhpbmc+IHtcbiAgICBjb25zdHJ1Y3RvcihlbDogRWxlbWVudFJlZikge1xuICAgICAgICBzdXBlcihlbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5maXhlcyBhIGNvbHVtbiBieSBzcGVjaWZpZWQgY29sdW1uIGlkZW50aWZpZXIgLSBjb2x1bW4ga2V5IG9yIGNvbHVtbiBpbmRleC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2xJZGVudGlmaWVyICAgIEFuIGlkZW50aWZpZXIgb2YgdGhlIGNvbHVtbiB0byBiZSB1bmZpeGVkIC0gY29sdW1uIGluZGV4IG9yIGNvbHVtbiBrZXkuXG4gICAgICogQHBhcmFtIHRhcmdldCAgICBLZXkgb2YgdGhlIGNvbHVtbiB3aGVyZSB0aGUgdW5maXhlZCBjb2x1bW4gc2hvdWxkIG1vdmUgdG8uXG4gICAgICogQHBhcmFtIGFmdGVyICAgIFNwZWNpZmllcyB3aGVyZSB0aGUgdW5maXhlZCBjb2x1bW4gc2hvdWxkIGJlIHJlbmRlcmVkIGFmdGVyIG9yIGJlZm9yZSB0aGUgdGFyZ2V0IGNvbHVtbi4gVGhpcyBwYXJhbWV0ZXIgaXMgZGlzcmVnYXJkZWQgaWYgdGhlcmUgaXMgbm8gdGFyZ2V0IGNvbHVtbiBzcGVjaWZpZWQuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgdW5maXhDb2x1bW4oY29sSWRlbnRpZmllcjogT2JqZWN0LCB0YXJnZXQ/OiBzdHJpbmcsIGFmdGVyPzogYm9vbGVhbik6IE9iamVjdCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBoZWlnaHRzIG9mIGZpeGVkIGFuZCB1bmZpeGVkIHRhYmxlcyBhcmUgZXF1YWwgLSBpZiBub3Qgc3luYyB0aGVtLiBTaW1pbGFyIGNoZWNrIGlzIG1hZGUgZm9yIGhlaWdodHMgb2YgdGFibGUgcm93cy5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBjaGVja0FuZFN5bmNIZWlnaHRzKCk6IHZvaWQgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgJ2NoZWNrJyBhcmd1bWVudCBpcyBzZXQgdG8gdHJ1ZSwgY2hlY2tzIHdoZXRoZXIgdGhlIGhlaWdodHMgb2YgZml4ZWQgYW5kIHVuZml4ZWQgdGFibGVzIGFyZSBlcXVhbCwgaWYgbm90IHN5bmMgdGhlbS4gU2ltaWxhciBjaGVjayBpcyBtYWRlIGZvciBoZWlnaHRzIG9mIHRhYmxlIHJvd3MuIElmIHRoZSBjbGVhclJvd3NIZWlnaHRzIGFyZ3VtZW50IGlzIHNldCB0byB0cnVlLCBjbGVhcnMgcm93cyBoZWlnaHRzIGJlZm9yZSBzeW5jaW5nIHRoZW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hlY2sgICAgSWYgc2V0IHRvIHRydWUsIGNoZWNrcyB3aGV0aGVyIHRoZSBoZWlnaHRzIG9mIGZpeGVkIGFuZCB1bmZpeGVkIHRhYmxlcyBhcmUgZXF1YWwsIGlmIG5vdCBzeW5jIHRoZW0uIElmIHRoaXMgYXJndW1lbnQgaXMgc2V0IHRvIGZhbHNlIHN5bmMgaXMgcGVyZm9ybWVkIHJlZ2FyZGxlc3Mgb2YgdGhlIGN1cnJlbnQgaGVpZ2h0cy5cbiAgICAgKiBAcGFyYW0gY2xlYXJSb3dzSGVpZ2h0cyAgICBDbGVhcnMgcm93IGhlaWd0aHMgZm9yIGFsbCB2aXNpYmxlIHJvd3MuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgc3luY0hlaWdodHMoY2hlY2s/OiBib29sZWFuLCBjbGVhclJvd3NIZWlnaHRzPzogYm9vbGVhbik6IHZvaWQgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGNvbHVtbiB3aXRoIHRoZSBzcGVjaWZpZWQga2V5IGlzIGEgY29sdW1uIGdyb3VwIGhlYWRlciwgd2hlbiB0aGUgW211bHRpLWNvbHVtbiBoZWFkZXJzXShodHRwOi8vd3d3Lmlnbml0ZXVpLmNvbS9oZWxwL2lnZ3JpZC1tdWx0aWNvbHVtbmhlYWRlcnMtbGFuZGluZ3BhZ2UpIGZlYXR1cmUgaXMgdXNlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2xLZXkgICAgVGhlIGtleSBvZiB0aGUgY29sdW1uIHRvIHBlcmZvcm0gdGhlIGNoZWNrIGZvci5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBpc0dyb3VwSGVhZGVyKGNvbEtleTogc3RyaW5nKTogYm9vbGVhbiB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIGNvbHVtbiBmaXhpbmcgaXMgYWxsb3dlZCBmb3IgdGhlIHNwZWNpZmllZCBjb2x1bW5zLiBJdCBzaG91bGQgbm90IGJlIGFsbG93ZWQgaWYgdGhlcmUgaXMgb25seSBvbmUgdmlzaWJsZSBjb2x1bW4gaW4gdGhlIHVuZml4ZWQgYXJlYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW5zICAgIEFycmF5IG9mIGNvbHVtbnMgYW5kL29yIGNvbHVtbiBpZGVudGlmaWVycyAtIGNvdWxkIGJlIGNvbHVtbiBpbmRleGVzLCBjb2x1bW4ga2V5cywgY29sdW1uIG9iamVjdCBvciBtaXhlZC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBjaGVja0ZpeGluZ0FsbG93ZWQoY29sdW1uczogYW55W10pOiBib29sZWFuIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdW5maXhpbmcgaXMgYWxsb3dlZCBmb3IgdGhlIHNwZWNpZmllZCBjb2x1bW5zLiBJdCBzaG91bGQgbm90IGJlIGFsbG93ZWQgaWYgdGhlcmUgaXMgb25seSBvbmUgdmlzaWJsZSBjb2x1bW4gaW4gdGhlIGZpeGVkIGFyZWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1ucyAgICBBcnJheSBvZiBjb2x1bW5zIGFuZC9vciBjb2x1bW4gaWRlbnRpZmllcnMgLSBjb3VsZCBiZSBjb2x1bW4gaW5kZXhlcywgY29sdW1uIGtleXMsIGNvbHVtbiBvYmplY3Qgb3IgbWl4ZWQuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgY2hlY2tVbmZpeGluZ0FsbG93ZWQoY29sdW1uczogYW55W10pOiBib29sZWFuIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogRml4ZXMgbm9uLWRhdGEgY29sdW1ucyAoc3VjaCBhcyB0aGUgcm93IG51bWJlcmluZyBjb2x1bW4gb2Ygcm93IHNlbGVjdG9ycykgaWYgYW55IGFuZCBpZiBbZml4aW5nRGlyZWN0aW9uXSh1aS5pZ2dyaWRjb2x1bW5maXhpbmcjb3B0aW9uczpmaXhpbmdEaXJlY3Rpb24pIGlzIGxlZnQuIERvZXMgbm90aGluZyBpZiB0aGUgbm9uLWRhdGEgY29sdW1ucyBhcmUgYWxyZWFkeSBmaXhlZC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBmaXhOb25EYXRhQ29sdW1ucygpOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBkZXByZWNhdGVkIC0gdXNlIGZ1bmN0aW9uIGZpeE5vbkRhdGFDb2x1bW5zLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGZpeERhdGFTa2lwcGVkQ29sdW1ucygpOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogVW5maXhlcyBub24tZGF0YSBjb2x1bW5zIChzdWNoIGFzIHRoZSByb3cgbnVtYmVyaW5nIGNvbHVtbiBvZiByb3cgc2VsZWN0b3JzKSBpZiBhbnkgYW5kIGlmIFtmaXhpbmdEaXJlY3Rpb25dKHVpLmlnZ3JpZGNvbHVtbmZpeGluZyNvcHRpb25zOmZpeGluZ0RpcmVjdGlvbikgaXMgbGVmdC4gRG9lcyBub3RoaW5nIGlmIHRoZSBub24tZGF0YSBjb2x1bW5zIGFyZSBhbHJlYWR5IGZpeGVkLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIHVuZml4Tm9uRGF0YUNvbHVtbnMoKTogdm9pZCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgZGVwcmVjYXRlZCAtIHVzZSBmdW5jdGlvbiB1bmZpeE5vbkRhdGFDb2x1bW5zLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIHVuZml4RGF0YVNraXBwZWRDb2x1bW5zKCk6IHZvaWQgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBVbmZpeGVzIGFsbCBmaXhlZCBjb2x1bW5zLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIHVuZml4QWxsQ29sdW1ucygpOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogU3luY3Mgcm93cyBoZWlnaHRzIGJldHdlZW4gdHdvIGNvbGxlY3Rpb25zIG9mIHJvd3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gJHRycyAgICBBbiBhcnJheSBvZiByb3dzIG9mIHRoZSBmaXJzdChmaXhlZC91bmZpeGVkKSBjb250YWluZXIuXG4gICAgICogQHBhcmFtICRhbm90aGVyUm93cyAgICBBbiBhcnJheSBvZiByb3dzIG9mIHRoZSBzZWNvbmQoZml4ZWQvdW5maXhlZCkgY29udGFpbmVyLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIHN5bmNSb3dzSGVpZ2h0cygkdHJzOiBhbnlbXSwgJGFub3RoZXJSb3dzOiBhbnlbXSk6IHZvaWQgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHdpZHRocyBvZiB0aGUgZml4ZWQgY29sdW1ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmQ29scyAgICBBcnJheSBvZiBncmlkIGNvbHVtbnMuIElmIG5vdCBzZXQgdGhlbiB0aGUgdG90YWwgd2lkdGggb2YgdGhlIGZpeGVkIGNvbHVtbnMgYXJlIHJldHVybmVkLlxuICAgICAqIEBwYXJhbSBleGNsdWRlTm9uRGF0YUNvbHVtbnMgICAgSWYgc2V0IHRvIHRydWUgZG8gbm90IGNhbGN1bGF0ZSB0aGUgd2lkdGggb2Ygbm9uLWRhdGEgZml4ZWQgY29sdW1ucyAobGlrZSB0aGUgcm93IHNlbGVjdG9yIHJvdyBudW1iZXJpbmcgY29sdW1uKS5cbiAgICAgKiBAcGFyYW0gaW5jbHVkZUhpZGRlbiAgICBJZiBzZXQgdG8gdHJ1ZSBjYWxjdWxhdGVzIHdpZHRoIG9mIHRoZSBoaWRkZW4gZml4ZWQgY29sdW1ucyAodGhlaXIgaW5pdGlhbCB3aWR0aCBiZWZvcmUgaGlkaW5nKS5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBnZXRXaWR0aE9mRml4ZWRDb2x1bW5zKGZDb2xzPzogYW55W10sIGV4Y2x1ZGVOb25EYXRhQ29sdW1ucz86IGJvb2xlYW4sIGluY2x1ZGVIaWRkZW4/OiBib29sZWFuKTogbnVtYmVyIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhlIGNvbHVtbiBmaXhpbmcgd2lkZ2V0XG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgZGVzdHJveSgpOiB2b2lkIHsgcmV0dXJuOyB9O1xufSJdfQ==