/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Directive, ElementRef } from "@angular/core";
import { Feature } from "../feature";
var IgGridColumnMovingFeature = /** @class */ (function (_super) {
    tslib_1.__extends(IgGridColumnMovingFeature, _super);
    function IgGridColumnMovingFeature(el) {
        return _super.call(this, el) || this;
    }
    /**
     * Restoring overwritten functions
     */
    /* istanbul ignore next */
    /**
     * Restoring overwritten functions
     * @return {?}
     */
    /* istanbul ignore next */
    IgGridColumnMovingFeature.prototype.destroy = /**
     * Restoring overwritten functions
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    /**
     * Moves a visible column at a specified place, in front or behind a target column or at a target index
     * 			Note: This method is asynchronous which means that it returns immediately and any subsequent code will execute in parallel. This may lead to runtime errors. To avoid them put the subsequent code in the callback parameter provided by the method.
     *
     * @param column    An identifier of the column to be moved. It can be a key, a Multi-Column Header identificator, or an index in a number format. The latter is not supported when the grid contains multi-column headers.
     * @param target    An identifier of a column where the moved column should move to or an index at which the moved column should be moved to. In the case of a column identifier the column will be moved after it by default.
     * @param after    Specifies whether the column moved should be moved after or before the target column.
     * @param inDom    Specifies whether the column moving will be enacted through DOM manipulation or through rerendering of the grid.
     * @param callback    Specifies a custom function to be called when the column is moved.
     */
    /* istanbul ignore next */
    /**
     * Moves a visible column at a specified place, in front or behind a target column or at a target index
     * 			Note: This method is asynchronous which means that it returns immediately and any subsequent code will execute in parallel. This may lead to runtime errors. To avoid them put the subsequent code in the callback parameter provided by the method.
     *
     * @param {?} column    An identifier of the column to be moved. It can be a key, a Multi-Column Header identificator, or an index in a number format. The latter is not supported when the grid contains multi-column headers.
     * @param {?} target    An identifier of a column where the moved column should move to or an index at which the moved column should be moved to. In the case of a column identifier the column will be moved after it by default.
     * @param {?=} after    Specifies whether the column moved should be moved after or before the target column.
     * @param {?=} inDom    Specifies whether the column moving will be enacted through DOM manipulation or through rerendering of the grid.
     * @param {?=} callback    Specifies a custom function to be called when the column is moved.
     * @return {?}
     */
    /* istanbul ignore next */
    IgGridColumnMovingFeature.prototype.moveColumn = /**
     * Moves a visible column at a specified place, in front or behind a target column or at a target index
     * 			Note: This method is asynchronous which means that it returns immediately and any subsequent code will execute in parallel. This may lead to runtime errors. To avoid them put the subsequent code in the callback parameter provided by the method.
     *
     * @param {?} column    An identifier of the column to be moved. It can be a key, a Multi-Column Header identificator, or an index in a number format. The latter is not supported when the grid contains multi-column headers.
     * @param {?} target    An identifier of a column where the moved column should move to or an index at which the moved column should be moved to. In the case of a column identifier the column will be moved after it by default.
     * @param {?=} after    Specifies whether the column moved should be moved after or before the target column.
     * @param {?=} inDom    Specifies whether the column moving will be enacted through DOM manipulation or through rerendering of the grid.
     * @param {?=} callback    Specifies a custom function to be called when the column is moved.
     * @return {?}
     */
    /* istanbul ignore next */
    function (column, target, after, inDom, callback) { return; };
    ;
    IgGridColumnMovingFeature.decorators = [
        { type: Directive, args: [{
                    selector: 'column-moving',
                    inputs: ["disabled", "create", "columnSettings", "mode", "moveType", "addMovingDropdown", "movingDialogWidth", "movingDialogHeight", "movingDialogAnimationDuration", "movingAcceptanceTolerance", "movingScrollTolerance", "scrollSpeedMultiplier", "scrollDelta", "hideHeaderContentsDuringDrag", "dragHelperOpacity", "movingDialogCaptionButtonDesc", "movingDialogCaptionButtonAsc", "movingDialogCaptionText", "movingDialogDisplayText", "movingDialogDropTooltipText", "movingDialogDropTooltipMarkup", "dropDownMoveLeftText", "dropDownMoveRightText", "dropDownMoveFirstText", "dropDownMoveLastText", "movingToolTipMove", "featureChooserSubmenuText", "columnMovingDialogContainment", "dialogWidget", "inherit"],
                    outputs: ["columnDragStart", "columnDragEnd", "columnDragCanceled", "columnMoving", "columnMoved", "movingDialogOpening", "movingDialogOpened", "movingDialogDragged", "movingDialogClosing", "movingDialogClosed", "movingDialogContentsRendering", "movingDialogContentsRendered", "movingDialogMoveUpButtonPressed", "movingDialogMoveDownButtonPressed", "movingDialogDragColumnMoving", "movingDialogDragColumnMoved"]
                },] }
    ];
    /** @nocollapse */
    IgGridColumnMovingFeature.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    return IgGridColumnMovingFeature;
}(Feature));
export { IgGridColumnMovingFeature };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWdncmlkY29sdW1ubW92aW5nLmpzIiwic291cmNlUm9vdCI6Im5nOi8vaWduaXRldWktYW5ndWxhci13cmFwcGVycy8iLCJzb3VyY2VzIjpbImxpYi9pZ2dyaWQvaWdncmlkZmVhdHVyZXMvaWdncmlkY29sdW1ubW92aW5nLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDdEQsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLFlBQVksQ0FBQztBQUVyQztJQUsrQyxxREFBMkI7SUFDdEUsbUNBQVksRUFBYztlQUN0QixrQkFBTSxFQUFFLENBQUM7SUFDYixDQUFDO0lBRUQ7O09BRUc7SUFDSCwwQkFBMEI7Ozs7OztJQUNuQiwyQ0FBTzs7Ozs7SUFBZCxjQUF5QixPQUFPLENBQUMsQ0FBQztJQUFDLENBQUM7SUFFcEM7Ozs7Ozs7OztPQVNHO0lBQ0gsMEJBQTBCOzs7Ozs7Ozs7Ozs7O0lBQ25CLDhDQUFVOzs7Ozs7Ozs7Ozs7SUFBakIsVUFBa0IsTUFBYyxFQUFFLE1BQWMsRUFBRSxLQUFlLEVBQUUsS0FBZSxFQUFFLFFBQW1CLElBQVUsT0FBTyxDQUFDLENBQUM7SUFBQyxDQUFDOztnQkEzQi9ILFNBQVMsU0FBQztvQkFDUCxRQUFRLEVBQUUsZUFBZTtvQkFDekIsTUFBTSxFQUFFLENBQUMsVUFBVSxFQUFDLFFBQVEsRUFBQyxnQkFBZ0IsRUFBQyxNQUFNLEVBQUMsVUFBVSxFQUFDLG1CQUFtQixFQUFDLG1CQUFtQixFQUFDLG9CQUFvQixFQUFDLCtCQUErQixFQUFDLDJCQUEyQixFQUFDLHVCQUF1QixFQUFDLHVCQUF1QixFQUFDLGFBQWEsRUFBQyw4QkFBOEIsRUFBQyxtQkFBbUIsRUFBQywrQkFBK0IsRUFBQyw4QkFBOEIsRUFBQyx5QkFBeUIsRUFBQyx5QkFBeUIsRUFBQyw2QkFBNkIsRUFBQywrQkFBK0IsRUFBQyxzQkFBc0IsRUFBQyx1QkFBdUIsRUFBQyx1QkFBdUIsRUFBQyxzQkFBc0IsRUFBQyxtQkFBbUIsRUFBQywyQkFBMkIsRUFBQywrQkFBK0IsRUFBQyxjQUFjLEVBQUMsU0FBUyxDQUFDO29CQUNscUIsT0FBTyxFQUFFLENBQUMsaUJBQWlCLEVBQUMsZUFBZSxFQUFDLG9CQUFvQixFQUFDLGNBQWMsRUFBQyxhQUFhLEVBQUMscUJBQXFCLEVBQUMsb0JBQW9CLEVBQUMscUJBQXFCLEVBQUMscUJBQXFCLEVBQUMsb0JBQW9CLEVBQUMsK0JBQStCLEVBQUMsOEJBQThCLEVBQUMsaUNBQWlDLEVBQUMsbUNBQW1DLEVBQUMsOEJBQThCLEVBQUMsNkJBQTZCLENBQUM7aUJBQy9ZOzs7O2dCQVBtQixVQUFVOztJQStCOUIsZ0NBQUM7Q0FBQSxBQTVCRCxDQUsrQyxPQUFPLEdBdUJyRDtTQXZCWSx5QkFBeUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgRmVhdHVyZSB9IGZyb20gXCIuLi9mZWF0dXJlXCI7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnY29sdW1uLW1vdmluZycsXG4gICAgaW5wdXRzOiBbXCJkaXNhYmxlZFwiLFwiY3JlYXRlXCIsXCJjb2x1bW5TZXR0aW5nc1wiLFwibW9kZVwiLFwibW92ZVR5cGVcIixcImFkZE1vdmluZ0Ryb3Bkb3duXCIsXCJtb3ZpbmdEaWFsb2dXaWR0aFwiLFwibW92aW5nRGlhbG9nSGVpZ2h0XCIsXCJtb3ZpbmdEaWFsb2dBbmltYXRpb25EdXJhdGlvblwiLFwibW92aW5nQWNjZXB0YW5jZVRvbGVyYW5jZVwiLFwibW92aW5nU2Nyb2xsVG9sZXJhbmNlXCIsXCJzY3JvbGxTcGVlZE11bHRpcGxpZXJcIixcInNjcm9sbERlbHRhXCIsXCJoaWRlSGVhZGVyQ29udGVudHNEdXJpbmdEcmFnXCIsXCJkcmFnSGVscGVyT3BhY2l0eVwiLFwibW92aW5nRGlhbG9nQ2FwdGlvbkJ1dHRvbkRlc2NcIixcIm1vdmluZ0RpYWxvZ0NhcHRpb25CdXR0b25Bc2NcIixcIm1vdmluZ0RpYWxvZ0NhcHRpb25UZXh0XCIsXCJtb3ZpbmdEaWFsb2dEaXNwbGF5VGV4dFwiLFwibW92aW5nRGlhbG9nRHJvcFRvb2x0aXBUZXh0XCIsXCJtb3ZpbmdEaWFsb2dEcm9wVG9vbHRpcE1hcmt1cFwiLFwiZHJvcERvd25Nb3ZlTGVmdFRleHRcIixcImRyb3BEb3duTW92ZVJpZ2h0VGV4dFwiLFwiZHJvcERvd25Nb3ZlRmlyc3RUZXh0XCIsXCJkcm9wRG93bk1vdmVMYXN0VGV4dFwiLFwibW92aW5nVG9vbFRpcE1vdmVcIixcImZlYXR1cmVDaG9vc2VyU3VibWVudVRleHRcIixcImNvbHVtbk1vdmluZ0RpYWxvZ0NvbnRhaW5tZW50XCIsXCJkaWFsb2dXaWRnZXRcIixcImluaGVyaXRcIl0sXG4gICAgb3V0cHV0czogW1wiY29sdW1uRHJhZ1N0YXJ0XCIsXCJjb2x1bW5EcmFnRW5kXCIsXCJjb2x1bW5EcmFnQ2FuY2VsZWRcIixcImNvbHVtbk1vdmluZ1wiLFwiY29sdW1uTW92ZWRcIixcIm1vdmluZ0RpYWxvZ09wZW5pbmdcIixcIm1vdmluZ0RpYWxvZ09wZW5lZFwiLFwibW92aW5nRGlhbG9nRHJhZ2dlZFwiLFwibW92aW5nRGlhbG9nQ2xvc2luZ1wiLFwibW92aW5nRGlhbG9nQ2xvc2VkXCIsXCJtb3ZpbmdEaWFsb2dDb250ZW50c1JlbmRlcmluZ1wiLFwibW92aW5nRGlhbG9nQ29udGVudHNSZW5kZXJlZFwiLFwibW92aW5nRGlhbG9nTW92ZVVwQnV0dG9uUHJlc3NlZFwiLFwibW92aW5nRGlhbG9nTW92ZURvd25CdXR0b25QcmVzc2VkXCIsXCJtb3ZpbmdEaWFsb2dEcmFnQ29sdW1uTW92aW5nXCIsXCJtb3ZpbmdEaWFsb2dEcmFnQ29sdW1uTW92ZWRcIl1cbn0pXG5leHBvcnQgY2xhc3MgSWdHcmlkQ29sdW1uTW92aW5nRmVhdHVyZSBleHRlbmRzIEZlYXR1cmU8SWdHcmlkQ29sdW1uTW92aW5nPiB7XHRcbiAgICBjb25zdHJ1Y3RvcihlbDogRWxlbWVudFJlZikge1xuICAgICAgICBzdXBlcihlbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzdG9yaW5nIG92ZXJ3cml0dGVuIGZ1bmN0aW9uc1xuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGRlc3Ryb3koKTogdm9pZCB7IHJldHVybjsgfSA7XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhIHZpc2libGUgY29sdW1uIGF0IGEgc3BlY2lmaWVkIHBsYWNlLCBpbiBmcm9udCBvciBiZWhpbmQgYSB0YXJnZXQgY29sdW1uIG9yIGF0IGEgdGFyZ2V0IGluZGV4XG4gICAgICogXHRcdFx0Tm90ZTogVGhpcyBtZXRob2QgaXMgYXN5bmNocm9ub3VzIHdoaWNoIG1lYW5zIHRoYXQgaXQgcmV0dXJucyBpbW1lZGlhdGVseSBhbmQgYW55IHN1YnNlcXVlbnQgY29kZSB3aWxsIGV4ZWN1dGUgaW4gcGFyYWxsZWwuIFRoaXMgbWF5IGxlYWQgdG8gcnVudGltZSBlcnJvcnMuIFRvIGF2b2lkIHRoZW0gcHV0IHRoZSBzdWJzZXF1ZW50IGNvZGUgaW4gdGhlIGNhbGxiYWNrIHBhcmFtZXRlciBwcm92aWRlZCBieSB0aGUgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAgICBBbiBpZGVudGlmaWVyIG9mIHRoZSBjb2x1bW4gdG8gYmUgbW92ZWQuIEl0IGNhbiBiZSBhIGtleSwgYSBNdWx0aS1Db2x1bW4gSGVhZGVyIGlkZW50aWZpY2F0b3IsIG9yIGFuIGluZGV4IGluIGEgbnVtYmVyIGZvcm1hdC4gVGhlIGxhdHRlciBpcyBub3Qgc3VwcG9ydGVkIHdoZW4gdGhlIGdyaWQgY29udGFpbnMgbXVsdGktY29sdW1uIGhlYWRlcnMuXG4gICAgICogQHBhcmFtIHRhcmdldCAgICBBbiBpZGVudGlmaWVyIG9mIGEgY29sdW1uIHdoZXJlIHRoZSBtb3ZlZCBjb2x1bW4gc2hvdWxkIG1vdmUgdG8gb3IgYW4gaW5kZXggYXQgd2hpY2ggdGhlIG1vdmVkIGNvbHVtbiBzaG91bGQgYmUgbW92ZWQgdG8uIEluIHRoZSBjYXNlIG9mIGEgY29sdW1uIGlkZW50aWZpZXIgdGhlIGNvbHVtbiB3aWxsIGJlIG1vdmVkIGFmdGVyIGl0IGJ5IGRlZmF1bHQuXG4gICAgICogQHBhcmFtIGFmdGVyICAgIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBjb2x1bW4gbW92ZWQgc2hvdWxkIGJlIG1vdmVkIGFmdGVyIG9yIGJlZm9yZSB0aGUgdGFyZ2V0IGNvbHVtbi5cbiAgICAgKiBAcGFyYW0gaW5Eb20gICAgU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGNvbHVtbiBtb3Zpbmcgd2lsbCBiZSBlbmFjdGVkIHRocm91Z2ggRE9NIG1hbmlwdWxhdGlvbiBvciB0aHJvdWdoIHJlcmVuZGVyaW5nIG9mIHRoZSBncmlkLlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAgICBTcGVjaWZpZXMgYSBjdXN0b20gZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGNvbHVtbiBpcyBtb3ZlZC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBtb3ZlQ29sdW1uKGNvbHVtbjogT2JqZWN0LCB0YXJnZXQ6IE9iamVjdCwgYWZ0ZXI/OiBib29sZWFuLCBpbkRvbT86IGJvb2xlYW4sIGNhbGxiYWNrPzogRnVuY3Rpb24pOiB2b2lkIHsgcmV0dXJuOyB9IDtcbn0iXX0=