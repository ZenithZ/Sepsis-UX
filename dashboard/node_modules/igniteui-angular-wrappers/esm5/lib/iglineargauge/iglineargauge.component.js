/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Component, ElementRef, Renderer, IterableDiffers, KeyValueDiffers, ChangeDetectorRef } from "@angular/core";
import { IgControlBase } from "../igcontrolbase/igcontrolbase";
var IgLinearGaugeComponent = /** @class */ (function (_super) {
    tslib_1.__extends(IgLinearGaugeComponent, _super);
    function IgLinearGaugeComponent(el, renderer, differs, kvalDiffers, cdr) {
        return _super.call(this, el, renderer, differs, kvalDiffers, cdr) || this;
    }
    /**
     * Returns a string containing the names of all the ranges delimited with a \n symbol.
     */
    /* istanbul ignore next */
    /**
     * Returns a string containing the names of all the ranges delimited with a \n symbol.
     * @return {?}
     */
    /* istanbul ignore next */
    IgLinearGaugeComponent.prototype.getRangeNames = /**
     * Returns a string containing the names of all the ranges delimited with a \n symbol.
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    /**
     * Adds a new range to the linear gauge.
     *
     * @param value     The range object to be added.
     */
    /* istanbul ignore next */
    /**
     * Adds a new range to the linear gauge.
     *
     * @param {?} value     The range object to be added.
     * @return {?}
     */
    /* istanbul ignore next */
    IgLinearGaugeComponent.prototype.addRange = /**
     * Adds a new range to the linear gauge.
     *
     * @param {?} value     The range object to be added.
     * @return {?}
     */
    /* istanbul ignore next */
    function (value) { return; };
    ;
    /**
     * Removes a range from the linear gauge.
     *
     * @param value     A JS object with properties set as follows: name: nameOfTheRangeToRemove, remove: true
     */
    /* istanbul ignore next */
    /**
     * Removes a range from the linear gauge.
     *
     * @param {?} value     A JS object with properties set as follows: name: nameOfTheRangeToRemove, remove: true
     * @return {?}
     */
    /* istanbul ignore next */
    IgLinearGaugeComponent.prototype.removeRange = /**
     * Removes a range from the linear gauge.
     *
     * @param {?} value     A JS object with properties set as follows: name: nameOfTheRangeToRemove, remove: true
     * @return {?}
     */
    /* istanbul ignore next */
    function (value) { return; };
    ;
    /**
     * Updates the specified range of the linear gauge.
     *
     * @param value     The range object to be updated.
     */
    /* istanbul ignore next */
    /**
     * Updates the specified range of the linear gauge.
     *
     * @param {?} value     The range object to be updated.
     * @return {?}
     */
    /* istanbul ignore next */
    IgLinearGaugeComponent.prototype.updateRange = /**
     * Updates the specified range of the linear gauge.
     *
     * @param {?} value     The range object to be updated.
     * @return {?}
     */
    /* istanbul ignore next */
    function (value) { return; };
    ;
    /**
     * Gets the value for the main scale of the gauge for a given point within the bounds of the gauge.
     *
     * @param x
     * @param y
     */
    /* istanbul ignore next */
    /**
     * Gets the value for the main scale of the gauge for a given point within the bounds of the gauge.
     *
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    /* istanbul ignore next */
    IgLinearGaugeComponent.prototype.getValueForPoint = /**
     * Gets the value for the main scale of the gauge for a given point within the bounds of the gauge.
     *
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    /* istanbul ignore next */
    function (x, y) { return; };
    ;
    /**
     * Returns true if the main gauge needle bounding box contains the point provided, otherwise false.
     *
     * @param x The x coordinate of the point.
     * @param y The y coordinate of the point.
     */
    /* istanbul ignore next */
    /**
     * Returns true if the main gauge needle bounding box contains the point provided, otherwise false.
     *
     * @param {?} x The x coordinate of the point.
     * @param {?} y The y coordinate of the point.
     * @return {?}
     */
    /* istanbul ignore next */
    IgLinearGaugeComponent.prototype.needleContainsPoint = /**
     * Returns true if the main gauge needle bounding box contains the point provided, otherwise false.
     *
     * @param {?} x The x coordinate of the point.
     * @param {?} y The y coordinate of the point.
     * @return {?}
     */
    /* istanbul ignore next */
    function (x, y) { return; };
    ;
    /**
     * Returns information about how the linear gauge is rendered.
     */
    /* istanbul ignore next */
    /**
     * Returns information about how the linear gauge is rendered.
     * @return {?}
     */
    /* istanbul ignore next */
    IgLinearGaugeComponent.prototype.exportVisualData = /**
     * Returns information about how the linear gauge is rendered.
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    /**
     * Causes all pending changes of the linear gauge e.g. by changed property values to be rendered immediately.
     */
    /* istanbul ignore next */
    /**
     * Causes all pending changes of the linear gauge e.g. by changed property values to be rendered immediately.
     * @return {?}
     */
    /* istanbul ignore next */
    IgLinearGaugeComponent.prototype.flush = /**
     * Causes all pending changes of the linear gauge e.g. by changed property values to be rendered immediately.
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    /**
     * Destroys widget.
     */
    /* istanbul ignore next */
    /**
     * Destroys widget.
     * @return {?}
     */
    /* istanbul ignore next */
    IgLinearGaugeComponent.prototype.destroy = /**
     * Destroys widget.
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    /**
     * Re-polls the css styles for the widget. Use this method when the css styles have been modified.
     */
    /* istanbul ignore next */
    /**
     * Re-polls the css styles for the widget. Use this method when the css styles have been modified.
     * @return {?}
     */
    /* istanbul ignore next */
    IgLinearGaugeComponent.prototype.styleUpdated = /**
     * Re-polls the css styles for the widget. Use this method when the css styles have been modified.
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    IgLinearGaugeComponent.decorators = [
        { type: Component, args: [{
                    selector: "ig-linear-gauge",
                    template: "<ng-content></ng-content>",
                    inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "width", "height", "ranges", "rangeToolTipTemplate", "needleToolTipTemplate", "orientation", "rangeBrushes", "rangeOutlines", "minimumValue", "maximumValue", "value", "needleShape", "needleName", "rangeInnerExtent", "scaleInnerExtent", "rangeOuterExtent", "scaleOuterExtent", "needleInnerExtent", "needleOuterExtent", "needleInnerBaseWidth", "needleOuterBaseWidth", "needleInnerPointWidth", "needleOuterPointWidth", "needleInnerPointExtent", "needleOuterPointExtent", "interval", "ticksPostInitial", "ticksPreTerminal", "labelInterval", "labelExtent", "labelsPostInitial", "labelsPreTerminal", "minorTickCount", "tickStartExtent", "tickEndExtent", "tickStrokeThickness", "tickBrush", "fontBrush", "needleBreadth", "needleBrush", "needleOutline", "needleStrokeThickness", "minorTickStartExtent", "minorTickEndExtent", "minorTickStrokeThickness", "minorTickBrush", "isScaleInverted", "backingBrush", "backingOutline", "backingStrokeThickness", "backingInnerExtent", "backingOuterExtent", "scaleStartExtent", "scaleEndExtent", "scaleBrush", "scaleOutline", "scaleStrokeThickness", "isNeedleDraggingEnabled", "transitionDuration", "showToolTipTimeout", "showToolTip", "font", "pixelScalingRatio"],
                    outputs: ["formatLabel", "alignLabel", "valueChanged"]
                }] }
    ];
    /** @nocollapse */
    IgLinearGaugeComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer },
        { type: IterableDiffers },
        { type: KeyValueDiffers },
        { type: ChangeDetectorRef }
    ]; };
    return IgLinearGaugeComponent;
}(IgControlBase));
export { IgLinearGaugeComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWdsaW5lYXJnYXVnZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLXdyYXBwZXJzLyIsInNvdXJjZXMiOlsibGliL2lnbGluZWFyZ2F1Z2UvaWdsaW5lYXJnYXVnZS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsZUFBZSxFQUFFLGVBQWUsRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNySCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sZ0NBQWdDLENBQUM7QUFFL0Q7SUFNNEMsa0RBQTRCO0lBQ3BFLGdDQUFZLEVBQWMsRUFBRSxRQUFrQixFQUFFLE9BQXdCLEVBQUUsV0FBNEIsRUFBRSxHQUFzQjtlQUFJLGtCQUFNLEVBQUUsRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLFdBQVcsRUFBRSxHQUFHLENBQUM7SUFBRSxDQUFDO0lBRW5MOztPQUVHO0lBQ0gsMEJBQTBCOzs7Ozs7SUFDbkIsOENBQWE7Ozs7O0lBQXBCLGNBQWlDLE9BQU8sQ0FBQyxDQUFDO0lBQUEsQ0FBQztJQUUzQzs7OztPQUlHO0lBQ0gsMEJBQTBCOzs7Ozs7OztJQUNuQix5Q0FBUTs7Ozs7OztJQUFmLFVBQWdCLEtBQWEsSUFBVSxPQUFPLENBQUMsQ0FBQztJQUFBLENBQUM7SUFFakQ7Ozs7T0FJRztJQUNILDBCQUEwQjs7Ozs7Ozs7SUFDbkIsNENBQVc7Ozs7Ozs7SUFBbEIsVUFBbUIsS0FBYSxJQUFVLE9BQU8sQ0FBQyxDQUFDO0lBQUEsQ0FBQztJQUVwRDs7OztPQUlHO0lBQ0gsMEJBQTBCOzs7Ozs7OztJQUNuQiw0Q0FBVzs7Ozs7OztJQUFsQixVQUFtQixLQUFhLElBQVUsT0FBTyxDQUFDLENBQUM7SUFBQSxDQUFDO0lBRXBEOzs7OztPQUtHO0lBQ0gsMEJBQTBCOzs7Ozs7Ozs7SUFDbkIsaURBQWdCOzs7Ozs7OztJQUF2QixVQUF3QixDQUFTLEVBQUUsQ0FBUyxJQUFZLE9BQU8sQ0FBQyxDQUFDO0lBQUEsQ0FBQztJQUVsRTs7Ozs7T0FLRztJQUNILDBCQUEwQjs7Ozs7Ozs7O0lBQ25CLG9EQUFtQjs7Ozs7Ozs7SUFBMUIsVUFBMkIsQ0FBUyxFQUFFLENBQVMsSUFBVSxPQUFPLENBQUMsQ0FBQztJQUFBLENBQUM7SUFFbkU7O09BRUc7SUFDSCwwQkFBMEI7Ozs7OztJQUNuQixpREFBZ0I7Ozs7O0lBQXZCLGNBQW9DLE9BQU8sQ0FBQyxDQUFDO0lBQUEsQ0FBQztJQUU5Qzs7T0FFRztJQUNILDBCQUEwQjs7Ozs7O0lBQ25CLHNDQUFLOzs7OztJQUFaLGNBQXVCLE9BQU8sQ0FBQyxDQUFDO0lBQUEsQ0FBQztJQUVqQzs7T0FFRztJQUNILDBCQUEwQjs7Ozs7O0lBQ25CLHdDQUFPOzs7OztJQUFkLGNBQXlCLE9BQU8sQ0FBQyxDQUFDO0lBQUEsQ0FBQztJQUVuQzs7T0FFRztJQUNILDBCQUEwQjs7Ozs7O0lBQ25CLDZDQUFZOzs7OztJQUFuQixjQUE4QixPQUFPLENBQUMsQ0FBQztJQUFBLENBQUM7O2dCQS9FM0MsU0FBUyxTQUFDO29CQUNQLFFBQVEsRUFBRSxpQkFBaUI7b0JBQzNCLFFBQVEsRUFBRSwyQkFBMkI7b0JBQ3JDLE1BQU0sRUFBRSxDQUFDLFVBQVUsRUFBRSxTQUFTLEVBQUUseUJBQXlCLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxzQkFBc0IsRUFBRSx1QkFBdUIsRUFBRSxhQUFhLEVBQUUsY0FBYyxFQUFFLGVBQWUsRUFBRSxjQUFjLEVBQUUsY0FBYyxFQUFFLE9BQU8sRUFBRSxhQUFhLEVBQUUsWUFBWSxFQUFFLGtCQUFrQixFQUFFLGtCQUFrQixFQUFFLGtCQUFrQixFQUFFLGtCQUFrQixFQUFFLG1CQUFtQixFQUFFLG1CQUFtQixFQUFFLHNCQUFzQixFQUFFLHNCQUFzQixFQUFFLHVCQUF1QixFQUFFLHVCQUF1QixFQUFFLHdCQUF3QixFQUFFLHdCQUF3QixFQUFFLFVBQVUsRUFBRSxrQkFBa0IsRUFBRSxrQkFBa0IsRUFBRSxlQUFlLEVBQUUsYUFBYSxFQUFFLG1CQUFtQixFQUFFLG1CQUFtQixFQUFFLGdCQUFnQixFQUFFLGlCQUFpQixFQUFFLGVBQWUsRUFBRSxxQkFBcUIsRUFBRSxXQUFXLEVBQUUsV0FBVyxFQUFFLGVBQWUsRUFBRSxhQUFhLEVBQUUsZUFBZSxFQUFFLHVCQUF1QixFQUFFLHNCQUFzQixFQUFFLG9CQUFvQixFQUFFLDBCQUEwQixFQUFFLGdCQUFnQixFQUFFLGlCQUFpQixFQUFFLGNBQWMsRUFBRSxnQkFBZ0IsRUFBRSx3QkFBd0IsRUFBRSxvQkFBb0IsRUFBRSxvQkFBb0IsRUFBRSxrQkFBa0IsRUFBRSxnQkFBZ0IsRUFBRSxZQUFZLEVBQUUsY0FBYyxFQUFFLHNCQUFzQixFQUFFLHlCQUF5QixFQUFFLG9CQUFvQixFQUFFLG9CQUFvQixFQUFFLGFBQWEsRUFBRSxNQUFNLEVBQUUsbUJBQW1CLENBQUM7b0JBQ3p2QyxPQUFPLEVBQUUsQ0FBQyxhQUFhLEVBQUUsWUFBWSxFQUFFLGNBQWMsQ0FBQztpQkFDekQ7Ozs7Z0JBUm1CLFVBQVU7Z0JBQUUsUUFBUTtnQkFBRSxlQUFlO2dCQUFFLGVBQWU7Z0JBQUUsaUJBQWlCOztJQW1GN0YsNkJBQUM7Q0FBQSxBQWhGRCxDQU00QyxhQUFhLEdBMEV4RDtTQTFFWSxzQkFBc0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIEVsZW1lbnRSZWYsIFJlbmRlcmVyLCBJdGVyYWJsZURpZmZlcnMsIEtleVZhbHVlRGlmZmVycywgQ2hhbmdlRGV0ZWN0b3JSZWYgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgSWdDb250cm9sQmFzZSB9IGZyb20gXCIuLi9pZ2NvbnRyb2xiYXNlL2lnY29udHJvbGJhc2VcIjtcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6IFwiaWctbGluZWFyLWdhdWdlXCIsXG4gICAgdGVtcGxhdGU6IFwiPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlwiLFxuICAgIGlucHV0czogW1wid2lkZ2V0SWRcIiwgXCJvcHRpb25zXCIsIFwiY2hhbmdlRGV0ZWN0aW9uSW50ZXJ2YWxcIiwgXCJkaXNhYmxlZFwiLCBcImNyZWF0ZVwiLCBcIndpZHRoXCIsIFwiaGVpZ2h0XCIsIFwicmFuZ2VzXCIsIFwicmFuZ2VUb29sVGlwVGVtcGxhdGVcIiwgXCJuZWVkbGVUb29sVGlwVGVtcGxhdGVcIiwgXCJvcmllbnRhdGlvblwiLCBcInJhbmdlQnJ1c2hlc1wiLCBcInJhbmdlT3V0bGluZXNcIiwgXCJtaW5pbXVtVmFsdWVcIiwgXCJtYXhpbXVtVmFsdWVcIiwgXCJ2YWx1ZVwiLCBcIm5lZWRsZVNoYXBlXCIsIFwibmVlZGxlTmFtZVwiLCBcInJhbmdlSW5uZXJFeHRlbnRcIiwgXCJzY2FsZUlubmVyRXh0ZW50XCIsIFwicmFuZ2VPdXRlckV4dGVudFwiLCBcInNjYWxlT3V0ZXJFeHRlbnRcIiwgXCJuZWVkbGVJbm5lckV4dGVudFwiLCBcIm5lZWRsZU91dGVyRXh0ZW50XCIsIFwibmVlZGxlSW5uZXJCYXNlV2lkdGhcIiwgXCJuZWVkbGVPdXRlckJhc2VXaWR0aFwiLCBcIm5lZWRsZUlubmVyUG9pbnRXaWR0aFwiLCBcIm5lZWRsZU91dGVyUG9pbnRXaWR0aFwiLCBcIm5lZWRsZUlubmVyUG9pbnRFeHRlbnRcIiwgXCJuZWVkbGVPdXRlclBvaW50RXh0ZW50XCIsIFwiaW50ZXJ2YWxcIiwgXCJ0aWNrc1Bvc3RJbml0aWFsXCIsIFwidGlja3NQcmVUZXJtaW5hbFwiLCBcImxhYmVsSW50ZXJ2YWxcIiwgXCJsYWJlbEV4dGVudFwiLCBcImxhYmVsc1Bvc3RJbml0aWFsXCIsIFwibGFiZWxzUHJlVGVybWluYWxcIiwgXCJtaW5vclRpY2tDb3VudFwiLCBcInRpY2tTdGFydEV4dGVudFwiLCBcInRpY2tFbmRFeHRlbnRcIiwgXCJ0aWNrU3Ryb2tlVGhpY2tuZXNzXCIsIFwidGlja0JydXNoXCIsIFwiZm9udEJydXNoXCIsIFwibmVlZGxlQnJlYWR0aFwiLCBcIm5lZWRsZUJydXNoXCIsIFwibmVlZGxlT3V0bGluZVwiLCBcIm5lZWRsZVN0cm9rZVRoaWNrbmVzc1wiLCBcIm1pbm9yVGlja1N0YXJ0RXh0ZW50XCIsIFwibWlub3JUaWNrRW5kRXh0ZW50XCIsIFwibWlub3JUaWNrU3Ryb2tlVGhpY2tuZXNzXCIsIFwibWlub3JUaWNrQnJ1c2hcIiwgXCJpc1NjYWxlSW52ZXJ0ZWRcIiwgXCJiYWNraW5nQnJ1c2hcIiwgXCJiYWNraW5nT3V0bGluZVwiLCBcImJhY2tpbmdTdHJva2VUaGlja25lc3NcIiwgXCJiYWNraW5nSW5uZXJFeHRlbnRcIiwgXCJiYWNraW5nT3V0ZXJFeHRlbnRcIiwgXCJzY2FsZVN0YXJ0RXh0ZW50XCIsIFwic2NhbGVFbmRFeHRlbnRcIiwgXCJzY2FsZUJydXNoXCIsIFwic2NhbGVPdXRsaW5lXCIsIFwic2NhbGVTdHJva2VUaGlja25lc3NcIiwgXCJpc05lZWRsZURyYWdnaW5nRW5hYmxlZFwiLCBcInRyYW5zaXRpb25EdXJhdGlvblwiLCBcInNob3dUb29sVGlwVGltZW91dFwiLCBcInNob3dUb29sVGlwXCIsIFwiZm9udFwiLCBcInBpeGVsU2NhbGluZ1JhdGlvXCJdLFxuICAgIG91dHB1dHM6IFtcImZvcm1hdExhYmVsXCIsIFwiYWxpZ25MYWJlbFwiLCBcInZhbHVlQ2hhbmdlZFwiXVxufSlcbmV4cG9ydCBjbGFzcyBJZ0xpbmVhckdhdWdlQ29tcG9uZW50IGV4dGVuZHMgSWdDb250cm9sQmFzZTxJZ0xpbmVhckdhdWdlPiB7XG4gICAgY29uc3RydWN0b3IoZWw6IEVsZW1lbnRSZWYsIHJlbmRlcmVyOiBSZW5kZXJlciwgZGlmZmVyczogSXRlcmFibGVEaWZmZXJzLCBrdmFsRGlmZmVyczogS2V5VmFsdWVEaWZmZXJzLCBjZHI6IENoYW5nZURldGVjdG9yUmVmKSB7IHN1cGVyKGVsLCByZW5kZXJlciwgZGlmZmVycywga3ZhbERpZmZlcnMsIGNkcik7IH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgY29udGFpbmluZyB0aGUgbmFtZXMgb2YgYWxsIHRoZSByYW5nZXMgZGVsaW1pdGVkIHdpdGggYSBcXG4gc3ltYm9sLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGdldFJhbmdlTmFtZXMoKTogc3RyaW5nIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyByYW5nZSB0byB0aGUgbGluZWFyIGdhdWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlICAgICBUaGUgcmFuZ2Ugb2JqZWN0IHRvIGJlIGFkZGVkLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGFkZFJhbmdlKHZhbHVlOiBPYmplY3QpOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHJhbmdlIGZyb20gdGhlIGxpbmVhciBnYXVnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAgICAgQSBKUyBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIHNldCBhcyBmb2xsb3dzOiBuYW1lOiBuYW1lT2ZUaGVSYW5nZVRvUmVtb3ZlLCByZW1vdmU6IHRydWVcbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyByZW1vdmVSYW5nZSh2YWx1ZTogT2JqZWN0KTogdm9pZCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHNwZWNpZmllZCByYW5nZSBvZiB0aGUgbGluZWFyIGdhdWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlICAgICBUaGUgcmFuZ2Ugb2JqZWN0IHRvIGJlIHVwZGF0ZWQuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgdXBkYXRlUmFuZ2UodmFsdWU6IE9iamVjdCk6IHZvaWQgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBmb3IgdGhlIG1haW4gc2NhbGUgb2YgdGhlIGdhdWdlIGZvciBhIGdpdmVuIHBvaW50IHdpdGhpbiB0aGUgYm91bmRzIG9mIHRoZSBnYXVnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB4IFxuICAgICAqIEBwYXJhbSB5IFxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGdldFZhbHVlRm9yUG9pbnQoeDogT2JqZWN0LCB5OiBPYmplY3QpOiBudW1iZXIgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIG1haW4gZ2F1Z2UgbmVlZGxlIGJvdW5kaW5nIGJveCBjb250YWlucyB0aGUgcG9pbnQgcHJvdmlkZWQsIG90aGVyd2lzZSBmYWxzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB4IFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50LlxuICAgICAqIEBwYXJhbSB5IFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50LlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIG5lZWRsZUNvbnRhaW5zUG9pbnQoeDogbnVtYmVyLCB5OiBudW1iZXIpOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCBob3cgdGhlIGxpbmVhciBnYXVnZSBpcyByZW5kZXJlZC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBleHBvcnRWaXN1YWxEYXRhKCk6IE9iamVjdCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIENhdXNlcyBhbGwgcGVuZGluZyBjaGFuZ2VzIG9mIHRoZSBsaW5lYXIgZ2F1Z2UgZS5nLiBieSBjaGFuZ2VkIHByb3BlcnR5IHZhbHVlcyB0byBiZSByZW5kZXJlZCBpbW1lZGlhdGVseS5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBmbHVzaCgpOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgd2lkZ2V0LlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGRlc3Ryb3koKTogdm9pZCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFJlLXBvbGxzIHRoZSBjc3Mgc3R5bGVzIGZvciB0aGUgd2lkZ2V0LiBVc2UgdGhpcyBtZXRob2Qgd2hlbiB0aGUgY3NzIHN0eWxlcyBoYXZlIGJlZW4gbW9kaWZpZWQuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgc3R5bGVVcGRhdGVkKCk6IHZvaWQgeyByZXR1cm47IH07XG59Il19