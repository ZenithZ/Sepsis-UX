/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Component, Renderer, ElementRef, IterableDiffers, KeyValueDiffers, ChangeDetectorRef, Input } from "@angular/core";
import { IgControlBase } from "../igcontrolbase/igcontrolbase";
var IgPivotGridComponent = /** @class */ (function (_super) {
    tslib_1.__extends(IgPivotGridComponent, _super);
    function IgPivotGridComponent(el, renderer, differs, kvalDiffers, cdr) {
        return _super.call(this, el, renderer, differs, kvalDiffers, cdr) || this;
    }
    /**
     * @return {?}
     */
    IgPivotGridComponent.prototype.option = /**
     * @return {?}
     */
    function () { return; };
    ;
    Object.defineProperty(IgPivotGridComponent.prototype, "dataSource", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._dataSource = value;
            /** @type {?} */
            var widget = jQuery(this._el).data(this._widgetName);
            if (widget) {
                jQuery(this._el)[this._widgetName]("option", "dataSource", this._dataSource);
            }
        },
        enumerable: true,
        configurable: true
    });
    ;
    /**
     * @return {?}
     */
    IgPivotGridComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this._dataSource === null || this._dataSource === undefined) {
            this._dataSource = this.options["dataSource"];
        }
        if (!this.options["dataSource"] && this._dataSource) {
            this.options["dataSource"] = this._dataSource;
        }
        _super.prototype.ngOnInit.call(this);
    };
    /**
     * Returns the igGrid instance used to render the OLAP data.
     */
    /* istanbul ignore next */
    /**
     * Returns the igGrid instance used to render the OLAP data.
     * @return {?}
     */
    /* istanbul ignore next */
    IgPivotGridComponent.prototype.grid = /**
     * Returns the igGrid instance used to render the OLAP data.
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    /**
     * Triggers an update on the data source and the igPivotGrid.
     */
    /* istanbul ignore next */
    /**
     * Triggers an update on the data source and the igPivotGrid.
     * @return {?}
     */
    /* istanbul ignore next */
    IgPivotGridComponent.prototype.updateGrid = /**
     * Triggers an update on the data source and the igPivotGrid.
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    /**
     * Expands a member from the data source and returns true if the expand succeeds. If the data source has a pending update, the method will return false. Note that igPivotGrid to will display the expanded result after the data source is updated.
     *
     * @param tupleLocation The name of the parent axis - 'columnAxis' or 'rowAxis'.
     * @param tupleIndex The index of the containing tuple. This index should correspond to the position of the tuple in the original unsorted result of the data source.
     * @param memberIndex The index of the member in the tuple. This index should correspond to the position of the member in the original unsorted result of the data source.
     * @param shouldUpdate A flag indicating whether the data source should be updated after the expand.
     */
    /* istanbul ignore next */
    /**
     * Expands a member from the data source and returns true if the expand succeeds. If the data source has a pending update, the method will return false. Note that igPivotGrid to will display the expanded result after the data source is updated.
     *
     * @param {?} tupleLocation The name of the parent axis - 'columnAxis' or 'rowAxis'.
     * @param {?} tupleIndex The index of the containing tuple. This index should correspond to the position of the tuple in the original unsorted result of the data source.
     * @param {?} memberIndex The index of the member in the tuple. This index should correspond to the position of the member in the original unsorted result of the data source.
     * @param {?=} shouldUpdate A flag indicating whether the data source should be updated after the expand.
     * @return {?}
     */
    /* istanbul ignore next */
    IgPivotGridComponent.prototype.expandTupleMember = /**
     * Expands a member from the data source and returns true if the expand succeeds. If the data source has a pending update, the method will return false. Note that igPivotGrid to will display the expanded result after the data source is updated.
     *
     * @param {?} tupleLocation The name of the parent axis - 'columnAxis' or 'rowAxis'.
     * @param {?} tupleIndex The index of the containing tuple. This index should correspond to the position of the tuple in the original unsorted result of the data source.
     * @param {?} memberIndex The index of the member in the tuple. This index should correspond to the position of the member in the original unsorted result of the data source.
     * @param {?=} shouldUpdate A flag indicating whether the data source should be updated after the expand.
     * @return {?}
     */
    /* istanbul ignore next */
    function (tupleLocation, tupleIndex, memberIndex, shouldUpdate) { return; };
    ;
    /**
     * Collapses a member from the data source and returns true if the collapse succeeds. If the data source has a pending update, the method will return false. Note that igPivotGrid to will display the expanded result after the data source is updated.
     *
     * @param tupleLocation The name of the parent axis - 'columnAxis' or 'rowAxis'.
     * @param tupleIndex The index of the containing tuple. This index should correspond to the position of the tuple in the original unsorted result of the data source.
     * @param memberIndex The index of the member in the tuple. This index should correspond to the position of the member in the original unsorted result of the data source.
     * @param shouldUpdate A flag indicating whether the data source should be updated after the expand.
     */
    /* istanbul ignore next */
    /**
     * Collapses a member from the data source and returns true if the collapse succeeds. If the data source has a pending update, the method will return false. Note that igPivotGrid to will display the expanded result after the data source is updated.
     *
     * @param {?} tupleLocation The name of the parent axis - 'columnAxis' or 'rowAxis'.
     * @param {?} tupleIndex The index of the containing tuple. This index should correspond to the position of the tuple in the original unsorted result of the data source.
     * @param {?} memberIndex The index of the member in the tuple. This index should correspond to the position of the member in the original unsorted result of the data source.
     * @param {?=} shouldUpdate A flag indicating whether the data source should be updated after the expand.
     * @return {?}
     */
    /* istanbul ignore next */
    IgPivotGridComponent.prototype.collapseTupleMember = /**
     * Collapses a member from the data source and returns true if the collapse succeeds. If the data source has a pending update, the method will return false. Note that igPivotGrid to will display the expanded result after the data source is updated.
     *
     * @param {?} tupleLocation The name of the parent axis - 'columnAxis' or 'rowAxis'.
     * @param {?} tupleIndex The index of the containing tuple. This index should correspond to the position of the tuple in the original unsorted result of the data source.
     * @param {?} memberIndex The index of the member in the tuple. This index should correspond to the position of the member in the original unsorted result of the data source.
     * @param {?=} shouldUpdate A flag indicating whether the data source should be updated after the expand.
     * @return {?}
     */
    /* istanbul ignore next */
    function (tupleLocation, tupleIndex, memberIndex, shouldUpdate) { return; };
    ;
    /**
     * Returns an array with the applied sort directions on the igPivotGrid's columns. The returned array contains objects with the following properties:
     *             memberNames: The names of the members in the tuple.
     *             tupleIndex: The index of the tuple on the column axis in the original unsorted result.
     *             sortDirection: The direction of the sort - ascending or descending.
     */
    /* istanbul ignore next */
    /**
     * Returns an array with the applied sort directions on the igPivotGrid's columns. The returned array contains objects with the following properties:
     *             memberNames: The names of the members in the tuple.
     *             tupleIndex: The index of the tuple on the column axis in the original unsorted result.
     *             sortDirection: The direction of the sort - ascending or descending.
     * @return {?}
     */
    /* istanbul ignore next */
    IgPivotGridComponent.prototype.appliedColumnSortDirections = /**
     * Returns an array with the applied sort directions on the igPivotGrid's columns. The returned array contains objects with the following properties:
     *             memberNames: The names of the members in the tuple.
     *             tupleIndex: The index of the tuple on the column axis in the original unsorted result.
     *             sortDirection: The direction of the sort - ascending or descending.
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    /**
     * Returns an array with the applied level sort direction items, which were used for the sorting of the header cells. The returned array contains objects with the following properties:
     *             levelUniqueName: Specifies the unique name of the level, which was sorted.
     *             sortDirection: The direction of the header sort - ascending or descending.
     */
    /* istanbul ignore next */
    /**
     * Returns an array with the applied level sort direction items, which were used for the sorting of the header cells. The returned array contains objects with the following properties:
     *             levelUniqueName: Specifies the unique name of the level, which was sorted.
     *             sortDirection: The direction of the header sort - ascending or descending.
     * @return {?}
     */
    /* istanbul ignore next */
    IgPivotGridComponent.prototype.appliedLevelSortDirections = /**
     * Returns an array with the applied level sort direction items, which were used for the sorting of the header cells. The returned array contains objects with the following properties:
     *             levelUniqueName: Specifies the unique name of the level, which was sorted.
     *             sortDirection: The direction of the header sort - ascending or descending.
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    /**
     * Destroy is part of the jQuery UI widget API and does the following:
     *             1. Remove custom CSS classes that were added.
     *             2. Unwrap any wrapping elements such as scrolling divs and other containers.
     *             3. Unbind all events that were bound.
     */
    /* istanbul ignore next */
    /**
     * Destroy is part of the jQuery UI widget API and does the following:
     *             1. Remove custom CSS classes that were added.
     *             2. Unwrap any wrapping elements such as scrolling divs and other containers.
     *             3. Unbind all events that were bound.
     * @return {?}
     */
    /* istanbul ignore next */
    IgPivotGridComponent.prototype.destroy = /**
     * Destroy is part of the jQuery UI widget API and does the following:
     *             1. Remove custom CSS classes that were added.
     *             2. Unwrap any wrapping elements such as scrolling divs and other containers.
     *             3. Unbind all events that were bound.
     * @return {?}
     */
    /* istanbul ignore next */
    function () { return; };
    ;
    IgPivotGridComponent.decorators = [
        { type: Component, args: [{
                    selector: "ig-pivot-grid",
                    template: "<ng-content></ng-content>",
                    inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "width", "height", "dataSource", "dataSourceOptions", "deferUpdate", "isParentInFrontForColumns", "isParentInFrontForRows", "compactColumnHeaders", "compactRowHeaders", "rowHeadersLayout", "compactColumnHeaderIndentation", "compactRowHeaderIndentation", "rowHeaderLinkGroupIndentation", "treeRowHeaderIndentation", "defaultRowHeaderWidth", "allowSorting", "firstSortDirection", "allowHeaderRowsSorting", "allowHeaderColumnsSorting", "levelSortDirections", "defaultLevelSortBehavior", "firstLevelSortDirection", "gridOptions", "dragAndDropSettings", "dropDownParent", "disableRowsDropArea", "disableColumnsDropArea", "disableMeasuresDropArea", "disableFiltersDropArea", "hideRowsDropArea", "hideColumnsDropArea", "hideMeasuresDropArea", "hideFiltersDropArea", "customMoveValidation"],
                    outputs: ["dataSourceInitialized", "dataSourceUpdated", "pivotGridHeadersRendered", "pivotGridRendered", "tupleMemberExpanding", "tupleMemberExpanded", "tupleMemberCollapsing", "tupleMemberCollapsed", "sorting", "sorted", "headersSorting", "headersSorted", "dragStart", "drag", "dragStop", "metadataDropping", "metadataDropped", "metadataRemoving", "metadataRemoved", "filterDropDownOpening", "filterDropDownOpened", "filterMembersLoaded", "filterDropDownOk", "filterDropDownClosing", "filterDropDownClosed"]
                }] }
    ];
    /** @nocollapse */
    IgPivotGridComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer },
        { type: IterableDiffers },
        { type: KeyValueDiffers },
        { type: ChangeDetectorRef }
    ]; };
    IgPivotGridComponent.propDecorators = {
        dataSource: [{ type: Input }]
    };
    return IgPivotGridComponent;
}(IgControlBase));
export { IgPivotGridComponent };
if (false) {
    /**
     * @type {?}
     * @private
     */
    IgPivotGridComponent.prototype._dataSource;
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWdwaXZvdGdyaWQuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vaWduaXRldWktYW5ndWxhci13cmFwcGVycy8iLCJzb3VyY2VzIjpbImxpYi9pZ3Bpdm90Z3JpZC9pZ3Bpdm90Z3JpZC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBRSxVQUFVLEVBQUUsZUFBZSxFQUFFLGVBQWUsRUFBRSxpQkFBaUIsRUFBRSxLQUFLLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDNUgsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBRS9EO0lBTTBDLGdEQUEwQjtJQUNoRSw4QkFBWSxFQUFjLEVBQUUsUUFBa0IsRUFBRSxPQUF3QixFQUFFLFdBQTRCLEVBQUUsR0FBc0I7ZUFBSSxrQkFBTSxFQUFFLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxXQUFXLEVBQUUsR0FBRyxDQUFDO0lBQUUsQ0FBQzs7OztJQUFRLHFDQUFNOzs7SUFBYixjQUF3QixPQUFPLENBQUMsQ0FBQztJQUFBLENBQUM7SUFFdE4sc0JBQ1csNENBQVU7Ozs7O1FBRHJCLFVBQ3NCLEtBQVU7WUFDNUIsSUFBSSxDQUFDLFdBQVcsR0FBRyxLQUFLLENBQUM7O2dCQUNuQixNQUFNLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQztZQUN0RCxJQUFJLE1BQU0sRUFBRTtnQkFDUixNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxRQUFRLEVBQUUsWUFBWSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQzthQUNoRjtRQUNMLENBQUM7OztPQUFBO0lBQUEsQ0FBQzs7OztJQUlGLHVDQUFROzs7SUFBUjtRQUNJLElBQUksSUFBSSxDQUFDLFdBQVcsS0FBSyxJ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LEVBQUUsa0JBQWtCLEVBQUUsdUJBQXVCLEVBQUUsc0JBQXNCLENBQUM7aUJBQy9mOzs7O2dCQVI2QixVQUFVO2dCQUFwQixRQUFRO2dCQUFjLGVBQWU7Z0JBQUUsZUFBZTtnQkFBRSxpQkFBaUI7Ozs2QkFZeEYsS0FBSzs7SUFnRlYsMkJBQUM7Q0FBQSxBQXpGRCxDQU0wQyxhQUFhLEdBbUZ0RDtTQW5GWSxvQkFBb0I7Ozs7OztJQVk3QiwyQ0FBeUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIFJlbmRlcmVyLCBFbGVtZW50UmVmLCBJdGVyYWJsZURpZmZlcnMsIEtleVZhbHVlRGlmZmVycywgQ2hhbmdlRGV0ZWN0b3JSZWYsIElucHV0IH0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7IElnQ29udHJvbEJhc2UgfSBmcm9tIFwiLi4vaWdjb250cm9sYmFzZS9pZ2NvbnRyb2xiYXNlXCI7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiBcImlnLXBpdm90LWdyaWRcIixcbiAgICB0ZW1wbGF0ZTogXCI8bmctY29udGVudD48L25nLWNvbnRlbnQ+XCIsXG4gICAgaW5wdXRzOiBbXCJ3aWRnZXRJZFwiLCBcIm9wdGlvbnNcIiwgXCJjaGFuZ2VEZXRlY3Rpb25JbnRlcnZhbFwiLCBcImRpc2FibGVkXCIsIFwiY3JlYXRlXCIsIFwid2lkdGhcIiwgXCJoZWlnaHRcIiwgXCJkYXRhU291cmNlXCIsIFwiZGF0YVNvdXJjZU9wdGlvbnNcIiwgXCJkZWZlclVwZGF0ZVwiLCBcImlzUGFyZW50SW5Gcm9udEZvckNvbHVtbnNcIiwgXCJpc1BhcmVudEluRnJvbnRGb3JSb3dzXCIsIFwiY29tcGFjdENvbHVtbkhlYWRlcnNcIiwgXCJjb21wYWN0Um93SGVhZGVyc1wiLCBcInJvd0hlYWRlcnNMYXlvdXRcIiwgXCJjb21wYWN0Q29sdW1uSGVhZGVySW5kZW50YXRpb25cIiwgXCJjb21wYWN0Um93SGVhZGVySW5kZW50YXRpb25cIiwgXCJyb3dIZWFkZXJMaW5rR3JvdXBJbmRlbnRhdGlvblwiLCBcInRyZWVSb3dIZWFkZXJJbmRlbnRhdGlvblwiLCBcImRlZmF1bHRSb3dIZWFkZXJXaWR0aFwiLCBcImFsbG93U29ydGluZ1wiLCBcImZpcnN0U29ydERpcmVjdGlvblwiLCBcImFsbG93SGVhZGVyUm93c1NvcnRpbmdcIiwgXCJhbGxvd0hlYWRlckNvbHVtbnNTb3J0aW5nXCIsIFwibGV2ZWxTb3J0RGlyZWN0aW9uc1wiLCBcImRlZmF1bHRMZXZlbFNvcnRCZWhhdmlvclwiLCBcImZpcnN0TGV2ZWxTb3J0RGlyZWN0aW9uXCIsIFwiZ3JpZE9wdGlvbnNcIiwgXCJkcmFnQW5kRHJvcFNldHRpbmdzXCIsIFwiZHJvcERvd25QYXJlbnRcIiwgXCJkaXNhYmxlUm93c0Ryb3BBcmVhXCIsIFwiZGlzYWJsZUNvbHVtbnNEcm9wQXJlYVwiLCBcImRpc2FibGVNZWFzdXJlc0Ryb3BBcmVhXCIsIFwiZGlzYWJsZUZpbHRlcnNEcm9wQXJlYVwiLCBcImhpZGVSb3dzRHJvcEFyZWFcIiwgXCJoaWRlQ29sdW1uc0Ryb3BBcmVhXCIsIFwiaGlkZU1lYXN1cmVzRHJvcEFyZWFcIiwgXCJoaWRlRmlsdGVyc0Ryb3BBcmVhXCIsIFwiY3VzdG9tTW92ZVZhbGlkYXRpb25cIl0sXG4gICAgb3V0cHV0czogW1wiZGF0YVNvdXJjZUluaXRpYWxpemVkXCIsIFwiZGF0YVNvdXJjZVVwZGF0ZWRcIiwgXCJwaXZvdEdyaWRIZWFkZXJzUmVuZGVyZWRcIiwgXCJwaXZvdEdyaWRSZW5kZXJlZFwiLCBcInR1cGxlTWVtYmVyRXhwYW5kaW5nXCIsIFwidHVwbGVNZW1iZXJFeHBhbmRlZFwiLCBcInR1cGxlTWVtYmVyQ29sbGFwc2luZ1wiLCBcInR1cGxlTWVtYmVyQ29sbGFwc2VkXCIsIFwic29ydGluZ1wiLCBcInNvcnRlZFwiLCBcImhlYWRlcnNTb3J0aW5nXCIsIFwiaGVhZGVyc1NvcnRlZFwiLCBcImRyYWdTdGFydFwiLCBcImRyYWdcIiwgXCJkcmFnU3RvcFwiLCBcIm1ldGFkYXRhRHJvcHBpbmdcIiwgXCJtZXRhZGF0YURyb3BwZWRcIiwgXCJtZXRhZGF0YVJlbW92aW5nXCIsIFwibWV0YWRhdGFSZW1vdmVkXCIsIFwiZmlsdGVyRHJvcERvd25PcGVuaW5nXCIsIFwiZmlsdGVyRHJvcERvd25PcGVuZWRcIiwgXCJmaWx0ZXJNZW1iZXJzTG9hZGVkXCIsIFwiZmlsdGVyRHJvcERvd25Pa1wiLCBcImZpbHRlckRyb3BEb3duQ2xvc2luZ1wiLCBcImZpbHRlckRyb3BEb3duQ2xvc2VkXCJdXG59KVxuZXhwb3J0IGNsYXNzIElnUGl2b3RHcmlkQ29tcG9uZW50IGV4dGVuZHMgSWdDb250cm9sQmFzZTxJZ1Bpdm90R3JpZD4ge1xuICAgIGNvbnN0cnVjdG9yKGVsOiBFbGVtZW50UmVmLCByZW5kZXJlcjogUmVuZGVyZXIsIGRpZmZlcnM6IEl0ZXJhYmxlRGlmZmVycywga3ZhbERpZmZlcnM6IEtleVZhbHVlRGlmZmVycywgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZikgeyBzdXBlcihlbCwgcmVuZGVyZXIsIGRpZmZlcnMsIGt2YWxEaWZmZXJzLCBjZHIpOyB9IHB1YmxpYyBvcHRpb24oKTogdm9pZCB7IHJldHVybjsgfTtcblxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNldCBkYXRhU291cmNlKHZhbHVlOiBhbnkpIHtcbiAgICAgICAgdGhpcy5fZGF0YVNvdXJjZSA9IHZhbHVlO1xuICAgICAgICBjb25zdCB3aWRnZXQgPSBqUXVlcnkodGhpcy5fZWwpLmRhdGEodGhpcy5fd2lkZ2V0TmFtZSk7XG4gICAgICAgIGlmICh3aWRnZXQpIHtcbiAgICAgICAgICAgIGpRdWVyeSh0aGlzLl9lbClbdGhpcy5fd2lkZ2V0TmFtZV0oXCJvcHRpb25cIiwgXCJkYXRhU291cmNlXCIsIHRoaXMuX2RhdGFTb3VyY2UpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByaXZhdGUgX2RhdGFTb3VyY2U6IGFueTtcblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBpZiAodGhpcy5fZGF0YVNvdXJjZSA9PT0gbnVsbCB8fCB0aGlzLl9kYXRhU291cmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGFTb3VyY2UgPSB0aGlzLm9wdGlvbnNbXCJkYXRhU291cmNlXCJdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zW1wiZGF0YVNvdXJjZVwiXSAmJiB0aGlzLl9kYXRhU291cmNlKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNbXCJkYXRhU291cmNlXCJdID0gdGhpcy5fZGF0YVNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGlnR3JpZCBpbnN0YW5jZSB1c2VkIHRvIHJlbmRlciB0aGUgT0xBUCBkYXRhLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGdyaWQoKTogT2JqZWN0IHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcnMgYW4gdXBkYXRlIG9uIHRoZSBkYXRhIHNvdXJjZSBhbmQgdGhlIGlnUGl2b3RHcmlkLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIHVwZGF0ZUdyaWQoKTogdm9pZCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIEV4cGFuZHMgYSBtZW1iZXIgZnJvbSB0aGUgZGF0YSBzb3VyY2UgYW5kIHJldHVybnMgdHJ1ZSBpZiB0aGUgZXhwYW5kIHN1Y2NlZWRzLiBJZiB0aGUgZGF0YSBzb3VyY2UgaGFzIGEgcGVuZGluZyB1cGRhdGUsIHRoZSBtZXRob2Qgd2lsbCByZXR1cm4gZmFsc2UuIE5vdGUgdGhhdCBpZ1Bpdm90R3JpZCB0byB3aWxsIGRpc3BsYXkgdGhlIGV4cGFuZGVkIHJlc3VsdCBhZnRlciB0aGUgZGF0YSBzb3VyY2UgaXMgdXBkYXRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0dXBsZUxvY2F0aW9uIFRoZSBuYW1lIG9mIHRoZSBwYXJlbnQgYXhpcyAtICdjb2x1bW5BeGlzJyBvciAncm93QXhpcycuXG4gICAgICogQHBhcmFtIHR1cGxlSW5kZXggVGhlIGluZGV4IG9mIHRoZSBjb250YWluaW5nIHR1cGxlLiBUaGlzIGluZGV4IHNob3VsZCBjb3JyZXNwb25kIHRvIHRoZSBwb3NpdGlvbiBvZiB0aGUgdHVwbGUgaW4gdGhlIG9yaWdpbmFsIHVuc29ydGVkIHJlc3VsdCBvZiB0aGUgZGF0YSBzb3VyY2UuXG4gICAgICogQHBhcmFtIG1lbWJlckluZGV4IFRoZSBpbmRleCBvZiB0aGUgbWVtYmVyIGluIHRoZSB0dXBsZS4gVGhpcyBpbmRleCBzaG91bGQgY29ycmVzcG9uZCB0byB0aGUgcG9zaXRpb24gb2YgdGhlIG1lbWJlciBpbiB0aGUgb3JpZ2luYWwgdW5zb3J0ZWQgcmVzdWx0IG9mIHRoZSBkYXRhIHNvdXJjZS5cbiAgICAgKiBAcGFyYW0gc2hvdWxkVXBkYXRlIEEgZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRhdGEgc291cmNlIHNob3VsZCBiZSB1cGRhdGVkIGFmdGVyIHRoZSBleHBhbmQuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgZXhwYW5kVHVwbGVNZW1iZXIodHVwbGVMb2NhdGlvbjogc3RyaW5nLCB0dXBsZUluZGV4OiBudW1iZXIsIG1lbWJlckluZGV4OiBudW1iZXIsIHNob3VsZFVwZGF0ZT86IGJvb2xlYW4pOiBib29sZWFuIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogQ29sbGFwc2VzIGEgbWVtYmVyIGZyb20gdGhlIGRhdGEgc291cmNlIGFuZCByZXR1cm5zIHRydWUgaWYgdGhlIGNvbGxhcHNlIHN1Y2NlZWRzLiBJZiB0aGUgZGF0YSBzb3VyY2UgaGFzIGEgcGVuZGluZyB1cGRhdGUsIHRoZSBtZXRob2Qgd2lsbCByZXR1cm4gZmFsc2UuIE5vdGUgdGhhdCBpZ1Bpdm90R3JpZCB0byB3aWxsIGRpc3BsYXkgdGhlIGV4cGFuZGVkIHJlc3VsdCBhZnRlciB0aGUgZGF0YSBzb3VyY2UgaXMgdXBkYXRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0dXBsZUxvY2F0aW9uIFRoZSBuYW1lIG9mIHRoZSBwYXJlbnQgYXhpcyAtICdjb2x1bW5BeGlzJyBvciAncm93QXhpcycuXG4gICAgICogQHBhcmFtIHR1cGxlSW5kZXggVGhlIGluZGV4IG9mIHRoZSBjb250YWluaW5nIHR1cGxlLiBUaGlzIGluZGV4IHNob3VsZCBjb3JyZXNwb25kIHRvIHRoZSBwb3NpdGlvbiBvZiB0aGUgdHVwbGUgaW4gdGhlIG9yaWdpbmFsIHVuc29ydGVkIHJlc3VsdCBvZiB0aGUgZGF0YSBzb3VyY2UuXG4gICAgICogQHBhcmFtIG1lbWJlckluZGV4IFRoZSBpbmRleCBvZiB0aGUgbWVtYmVyIGluIHRoZSB0dXBsZS4gVGhpcyBpbmRleCBzaG91bGQgY29ycmVzcG9uZCB0byB0aGUgcG9zaXRpb24gb2YgdGhlIG1lbWJlciBpbiB0aGUgb3JpZ2luYWwgdW5zb3J0ZWQgcmVzdWx0IG9mIHRoZSBkYXRhIHNvdXJjZS5cbiAgICAgKiBAcGFyYW0gc2hvdWxkVXBkYXRlIEEgZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRhdGEgc291cmNlIHNob3VsZCBiZSB1cGRhdGVkIGFmdGVyIHRoZSBleHBhbmQuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgY29sbGFwc2VUdXBsZU1lbWJlcih0dXBsZUxvY2F0aW9uOiBzdHJpbmcsIHR1cGxlSW5kZXg6IG51bWJlciwgbWVtYmVySW5kZXg6IG51bWJlciwgc2hvdWxkVXBkYXRlPzogYm9vbGVhbik6IGJvb2xlYW4geyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IHdpdGggdGhlIGFwcGxpZWQgc29ydCBkaXJlY3Rpb25zIG9uIHRoZSBpZ1Bpdm90R3JpZCdzIGNvbHVtbnMuIFRoZSByZXR1cm5lZCBhcnJheSBjb250YWlucyBvYmplY3RzIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAqICAgICAgICAgICAgIG1lbWJlck5hbWVzOiBUaGUgbmFtZXMgb2YgdGhlIG1lbWJlcnMgaW4gdGhlIHR1cGxlLlxuICAgICAqICAgICAgICAgICAgIHR1cGxlSW5kZXg6IFRoZSBpbmRleCBvZiB0aGUgdHVwbGUgb24gdGhlIGNvbHVtbiBheGlzIGluIHRoZSBvcmlnaW5hbCB1bnNvcnRlZCByZXN1bHQuXG4gICAgICogICAgICAgICAgICAgc29ydERpcmVjdGlvbjogVGhlIGRpcmVjdGlvbiBvZiB0aGUgc29ydCAtIGFzY2VuZGluZyBvciBkZXNjZW5kaW5nLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGFwcGxpZWRDb2x1bW5Tb3J0RGlyZWN0aW9ucygpOiBhbnlbXSB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgd2l0aCB0aGUgYXBwbGllZCBsZXZlbCBzb3J0IGRpcmVjdGlvbiBpdGVtcywgd2hpY2ggd2VyZSB1c2VkIGZvciB0aGUgc29ydGluZyBvZiB0aGUgaGVhZGVyIGNlbGxzLiBUaGUgcmV0dXJuZWQgYXJyYXkgY29udGFpbnMgb2JqZWN0cyB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgKiAgICAgICAgICAgICBsZXZlbFVuaXF1ZU5hbWU6IFNwZWNpZmllcyB0aGUgdW5pcXVlIG5hbWUgb2YgdGhlIGxldmVsLCB3aGljaCB3YXMgc29ydGVkLlxuICAgICAqICAgICAgICAgICAgIHNvcnREaXJlY3Rpb246IFRoZSBkaXJlY3Rpb24gb2YgdGhlIGhlYWRlciBzb3J0IC0gYXNjZW5kaW5nIG9yIGRlc2NlbmRpbmcuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgYXBwbGllZExldmVsU29ydERpcmVjdGlvbnMoKTogYW55W10geyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95IGlzIHBhcnQgb2YgdGhlIGpRdWVyeSBVSSB3aWRnZXQgQVBJIGFuZCBkb2VzIHRoZSBmb2xsb3dpbmc6XG4gICAgICogICAgICAgICAgICAgMS4gUmVtb3ZlIGN1c3RvbSBDU1MgY2xhc3NlcyB0aGF0IHdlcmUgYWRkZWQuXG4gICAgICogICAgICAgICAgICAgMi4gVW53cmFwIGFueSB3cmFwcGluZyBlbGVtZW50cyBzdWNoIGFzIHNjcm9sbGluZyBkaXZzIGFuZCBvdGhlciBjb250YWluZXJzLlxuICAgICAqICAgICAgICAgICAgIDMuIFVuYmluZCBhbGwgZXZlbnRzIHRoYXQgd2VyZSBib3VuZC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBkZXN0cm95KCk6IHZvaWQgeyByZXR1cm47IH07XG59XG4iXX0=