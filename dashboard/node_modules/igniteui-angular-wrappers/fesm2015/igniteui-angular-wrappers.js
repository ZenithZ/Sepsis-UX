import { Directive, ElementRef, EventEmitter, ContentChild, Input, ContentChildren, Component, ChangeDetectionStrategy, Renderer, IterableDiffers, KeyValueDiffers, ChangeDetectorRef, Optional, NgZone, NgModule } from '@angular/core';
import { NgModel } from '@angular/forms';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Column {
    /**
     * @param {?} el
     */
    constructor(el) {
        this._settings = {};
        this._el = el;
        /** @type {?} */
        let self = this;
        /** @type {?} */
        let i;
        /** @type {?} */
        let settings = ['headerText', 'key', 'formatter', 'format', 'dataType', 'width', 'hidden', 'template', 'unbound', 'group', 'rowspan', 'formula', 'unboundValues', 'unboundValuesUpdateMode', 'headerCssClass', 'columnCssClass'];
        for (i = 0; i < settings.length; i++) {
            Object.defineProperty(self, settings[i], {
                set: self.createColumnsSetter(settings[i]),
                get: self.createColumnsGetter(settings[i]),
                enumerable: true,
                configurable: true
            });
        }
    }
    /**
     * @param {?} name
     * @return {?}
     */
    createColumnsSetter(name) {
        return (/**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            let grid = jQuery(this._el.nativeElement.parentElement).find("table[role='grid']");
            /** @type {?} */
            let columns = grid["igGrid"]("option", "columns");
            this._settings[name] = value;
            if (jQuery.ui["igGrid"] &&
                jQuery.ui["igGrid"].prototype.options &&
                jQuery.ui["igGrid"].prototype.options.hasOwnProperty("columns") &&
                grid.data("igGrid")) {
                //reapply all column settings when a column setting is changed
                grid["igGrid"]("option", "columns", columns);
            }
        });
    }
    /**
     * @param {?} name
     * @return {?}
     */
    createColumnsGetter(name) {
        return (/**
         * @return {?}
         */
        function () {
            return this._settings[name];
        });
    }
}
Column.decorators = [
    { type: Directive, args: [{
                selector: 'column',
                inputs: ['headerText', 'key', 'formatter', 'format', 'dataType', 'width', 'hidden', 'template', 'unbound', 'group', 'rowspan', 'formula', 'unboundValues', 'unboundValuesUpdateMode', 'headerCssClass', 'columnCssClass']
            },] }
];
/** @nocollapse */
Column.ctorParameters = () => [
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template Model
 */
class Feature {
    /**
     * @param {?} el
     */
    constructor(el) {
        this._settings = {};
        this._el = el;
        this.name = this.normalizeName(el.nativeElement.nodeName.toLowerCase());
        this.featureName = "igGrid" + this.name;
        for (var propt in jQuery.ui["igGrid" + this.name].prototype.events) {
            this[propt] = new EventEmitter();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        let self = this;
        this.initSettings = jQuery.extend(true, {}, this);
        /** @type {?} */
        let evtName;
        this._events = new Map();
        /** @type {?} */
        let grid = jQuery(this._el.nativeElement).closest("ig-grid").find("table");
        //event binding for features
        for (var propt in jQuery.ui[this.featureName].prototype.events) {
            evtName = this.featureName.toLowerCase() + propt.toLowerCase();
            this._events[evtName] = propt;
            jQuery(grid).on(evtName, (/**
             * @param {?} evt
             * @param {?} ui
             * @return {?}
             */
            function (evt, ui) {
                self[self._events[evt.type]].emit({ event: evt, ui: ui });
            }));
        }
        for (var setting in jQuery.ui[this.featureName].prototype.options) {
            Object.defineProperty(self, setting, {
                set: self.createFeatureSetter(setting),
                get: self.createFeatureGetter(setting),
                enumerable: true,
                configurable: true
            });
        }
        /** @type {?} */
        var propNames = Object.getOwnPropertyNames(jQuery.ui[this.featureName].prototype);
        for (var i = 0; i < propNames.length; i++) {
            /** @type {?} */
            var name = propNames[i];
            if (name.indexOf("_") !== 0 && typeof jQuery.ui[this.featureName].prototype[name] === "function") {
                Object.defineProperty(self, name, {
                    get: self.createMethodGetter(name)
                });
            }
        }
    }
    /**
     * @param {?} name
     * @return {?}
     */
    createFeatureSetter(name) {
        return (/**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            let grid = jQuery(this._el.nativeElement).closest("ig-grid").find("table[role='grid']");
            this._settings[name] = value;
            if (jQuery.ui[this.featureName] &&
                jQuery.ui[this.featureName].prototype.options &&
                jQuery.ui[this.featureName].prototype.options.hasOwnProperty(name) &&
                grid.data(this.featureName)) {
                grid[this.featureName]("option", name, value);
            }
        });
    }
    /**
     * @param {?} name
     * @return {?}
     */
    createFeatureGetter(name) {
        return (/**
         * @return {?}
         */
        function () {
            return this._settings[name];
        });
    }
    /**
     * @param {?} name
     * @return {?}
     */
    createMethodGetter(name) {
        return (/**
         * @return {?}
         */
        function () {
            /** @type {?} */
            let grid = jQuery(this._el.nativeElement).closest("ig-grid").find("table[role='grid']");
            if (grid.length === 0) {
                grid = jQuery(this._el.nativeElement).closest("ig-hierarchical-grid").find("table[role='grid']");
            }
            /** @type {?} */
            var feature = grid.data(this.featureName);
            return jQuery.proxy(feature[name], feature);
        });
    }
    /**
     * @param {?} str
     * @return {?}
     */
    normalizeName(str) {
        //convert hyphen to camelCase
        /** @type {?} */
        let name = str.replace(/-([a-z])/g, (/**
         * @param {?} group
         * @return {?}
         */
        function (group) {
            return group[1].toUpperCase();
        }));
        return name.charAt(0).toUpperCase() + name.slice(1);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgGridMultiColumnHeadersFeature extends Feature {
    /**
     * @param {?} el
     */
    constructor(el) {
        super(el);
    }
    /**
     * Destroys the widget
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
    /**
     * Collapses an expanded group. If the group is collapsed, the method does nothing.
     * Note: This method is asynchronous which means that it returns immediately and any subsequent code will execute in parallel. This may lead to runtime errors. To avoid them put the subsequent code in the callback parameter provided by the method.
     * @param {?} groupKey
     * @param {?=} callback
     * @return {?}
     */
    /* istanbul ignore next */
    collapseGroup(groupKey, callback) { return; }
    ;
    /**
     * Expands a collapsed group. If the group is expanded, the method does nothing.
     * Note: This method is asynchronous which means that it returns immediately and any subsequent code will execute in parallel. This may lead to runtime errors. To avoid them put the subsequent code in the callback parameter provided by the method.
     * @param {?} groupKey
     * @param {?=} callback
     * @return {?}
     */
    /* istanbul ignore next */
    expandGroup(groupKey, callback) { return; }
    ;
    /**
     * Returns multicolumn headers array. if there aren"t multicolumn headers returns undefined.
     * @return {?}
     */
    /* istanbul ignore next */
    getMultiColumnHeaders() { return; }
    ;
    /**
     * Toggles a collapsible group.
     * Note: This method is asynchronous which means that it returns immediately and any subsequent code will execute in parallel. This may lead to runtime errors. To avoid them put the subsequent code in the callback parameter provided by the method.
     * @param {?} groupKey
     * @param {?=} callback
     * @return {?}
     */
    /* istanbul ignore next */
    toggleGroup(groupKey, callback) { return; }
    ;
}
IgGridMultiColumnHeadersFeature.decorators = [
    { type: Directive, args: [{
                selector: 'multi-column-headers',
                inputs: ["inherit"],
                outputs: ["groupCollapsing", "groupCollapsed", "groupExpanding", "groupExpanded"]
            },] }
];
/** @nocollapse */
IgGridMultiColumnHeadersFeature.ctorParameters = () => [
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgGridSortingFeature extends Feature {
    /**
     * @param {?} el
     */
    constructor(el) {
        super(el);
    }
    /**
     * Sorts the data in a grid column  and updates the UI.
     *
     * @param {?} index     Column key (string) or index (number) - for multi-row grid only column key can be used. Specifies the column which we want to sort. If the mode is multiple, previous sorting states are not cleared.
     * @param {?} direction     Specifies sorting direction (ascending or descending)
     * @param {?} header
     * @return {?}
     */
    /* istanbul ignore next */
    sortColumn(index, direction, header) { return; }
    ;
    /**
     * Sorts the data in grid columns and updates the UI.\
     * @return {?}
     */
    /* istanbul ignore next */
    sortMultiple() { return; }
    ;
    /**
     * Removes current sorting(for all sorted columns) and updates the UI.
     * @return {?}
     */
    /* istanbul ignore next */
    clearSorting() { return; }
    ;
    /**
     * Removes sorting for the grid column with the specified columnKey/columnIndex and updates the UI.
     *
     * @param {?} index     Column key (string) or index (number) - for multi-row grid only column key can be used. Specifies the column for which we want to remove sorting. If the mode is multiple, previous sorting states are not cleared.
     * @param {?} header     - if specified client events should be fired
     * @return {?}
     */
    /* istanbul ignore next */
    unsortColumn(index, header) { return; }
    ;
    /**
     * Destroys the sorting feature. Unbinds events, removes added sorting elements, etc.
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
    /**
     * Opens the multiple sorting dialog.
     * @return {?}
     */
    /* istanbul ignore next */
    openMultipleSortingDialog() { return; }
    ;
    /**
     * Closes the multiple sorting dialog.
     * @return {?}
     */
    /* istanbul ignore next */
    closeMultipleSortingDialog() { return; }
    ;
    /**
     * Renders content of multiple sorting dialog - sorted and unsorted columns.
     *
     * @param {?} isToCallEvents
     * @return {?}
     */
    /* istanbul ignore next */
    renderMultipleSortingDialogContent(isToCallEvents) { return; }
    ;
    /**
     * Remove clear button for multiple sorting dialog
     * @return {?}
     */
    /* istanbul ignore next */
    removeDialogClearButton() { return; }
    ;
}
IgGridSortingFeature.decorators = [
    { type: Directive, args: [{
                selector: 'sorting',
                inputs: ["disabled", "create", "type", "caseSensitive", "applySortedColumnCss", "sortUrlKey", "sortUrlKeyAscValue", "sortUrlKeyDescValue", "mode", "customSortFunction", "firstSortDirection", "sortedColumnTooltip", "modalDialogSortOnClick", "modalDialogSortByButtonText", "modalDialogResetButtonLabel", "modalDialogCaptionButtonDesc", "modalDialogCaptionButtonAsc", "modalDialogCaptionButtonUnsort", "modalDialogWidth", "modalDialogHeight", "modalDialogAnimationDuration", "featureChooserText", "unsortedColumnTooltip", "columnSettings", "modalDialogCaptionText", "modalDialogButtonApplyText", "modalDialogButtonCancelText", "featureChooserSortAsc", "featureChooserSortDesc", "persist", "sortingDialogContainment", "dialogWidget", "inherit"],
                outputs: ["columnSorting", "columnSorted", "modalDialogOpening", "modalDialogOpened", "modalDialogMoving", "modalDialogClosing", "modalDialogClosed", "modalDialogContentsRendering", "modalDialogContentsRendered", "modalDialogSortingChanged", "modalDialogButtonUnsortClick", "modalDialogSortClick", "modalDialogButtonApplyClick", "modalDialogButtonResetClick"]
            },] }
];
/** @nocollapse */
IgGridSortingFeature.ctorParameters = () => [
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgGridFilteringFeature extends Feature {
    /**
     * @param {?} el
     */
    constructor(el) {
        super(el);
    }
    /**
     * Destroys the filtering widget - remove fitler row, unbinds events, returns the grid to its previous state.
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
    /**
     * Returns the count of data records that match filtering conditions
     * @return {?}
     */
    /* istanbul ignore next */
    getFilteringMatchesCount() { return; }
    ;
    /**
     * Toggle filter row when mode is simple or [advancedModeEditorsVisible](ui.iggridfiltering#options:advancedModeEditorsVisible) is true. Otherwise show/hide advanced dialog.
     *
     * @param {?} event     Column key
     * @return {?}
     */
    /* istanbul ignore next */
    toggleFilterRowByFeatureChooser(event) { return; }
    ;
    /**
     * Applies filtering programmatically and updates the UI by default.
     *
     * @param {?} expressions     An array of filtering expressions, each one having the format {fieldName: , expr: , cond: , logic: } where  fieldName is the key of the column, expr is the actual expression string with which we would like to filter, logic is 'AND' or 'OR', and cond is one of the following strings: "equals", "doesNotEqual", "contains", "doesNotContain", "greaterThan", "lessThan", "greaterThanOrEqualTo", "lessThanOrEqualTo", "true", "false", "null", "notNull", "empty", "notEmpty", "startsWith", "endsWith", "today", "yesterday", "on", "notOn", "thisMonth", "lastMonth", "nextMonth", "before", "after", "thisYear", "lastYear", "nextYear". The difference between the empty and null filtering conditions is that empty includes null, NaN, and undefined, as well as the empty string.
     * @param {?=} updateUI     specifies whether the filter row should be also updated once the grid is filtered
     * @param {?=} addedFromAdvanced
     * @return {?}
     */
    /* istanbul ignore next */
    filter(expressions, updateUI, addedFromAdvanced) { return; }
    ;
    /**
     * Check whether filterCondition requires or not filtering expression - e.g. if filterCondition is "lastMonth", "thisMonth", "null", "notNull", "true", "false", etc. then filtering expression is NOT required
     *
     * @param {?} filterCondition    filtering condition - e.g. "true", "false",  "yesterday", "empty", "null", etc.
     * @return {?}
     */
    /* istanbul ignore next */
    requiresFilteringExpression(filterCondition) { return; }
    ;
}
IgGridFilteringFeature.decorators = [
    { type: Directive, args: [{
                selector: 'filtering',
                inputs: ["disabled", "create", "caseSensitive", "filterSummaryAlwaysVisible", "renderFC", "filterSummaryTemplate", "filterDropDownAnimations", "filterDropDownAnimationDuration", "filterDropDownWidth", "filterDropDownHeight", "filterExprUrlKey", "filterDropDownItemIcons", "columnSettings", "type", "filterDelay", "mode", "advancedModeEditorsVisible", "advancedModeHeaderButtonLocation", "filterDialogWidth", "filterDialogHeight", "filterDialogFilterDropDownDefaultWidth", "filterDialogExprInputDefaultWidth", "filterDialogColumnDropDownDefaultWidth", "renderFilterButton", "filterButtonLocation", "nullTexts", "labels", "tooltipTemplate", "filterDialogAddConditionTemplate", "filterDialogAddConditionDropDownTemplate", "filterDialogFilterTemplate", "filterDialogFilterConditionTemplate", "filterDialogAddButtonWidth", "filterDialogOkCancelButtonWidth", "filterDialogMaxFilterCount", "filterDialogContainment", "showEmptyConditions", "showNullConditions", "featureChooserText", "featureChooserTextHide", "featureChooserTextAdvancedFilter", "dialogWidget", "persist", "inherit"],
                outputs: ["dataFiltering", "dataFiltered", "dropDownOpening", "dropDownOpened", "dropDownClosing", "dropDownClosed", "filterDialogOpening", "filterDialogOpened", "filterDialogMoving", "filterDialogFilterAdding", "filterDialogFilterAdded", "filterDialogClosing", "filterDialogClosed", "filterDialogContentsRendering", "filterDialogContentsRendered", "filterDialogFiltering"]
            },] }
];
/** @nocollapse */
IgGridFilteringFeature.ctorParameters = () => [
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgGridPagingFeature extends Feature {
    /**
     * @param {?} el
     */
    constructor(el) {
        super(el);
    }
    /**
     * Gets/Sets the current page index, delegates data binding and paging to [$.ig.DataSource](ig.datasource).
     *
     * @param {?=} index     The page index to go to.
     * @return {?}
     */
    /* istanbul ignore next */
    pageIndex(index) { return; }
    ;
    /**
     * Gets/Sets the page size. If no parameter is specified, just returns the current page size.
     *
     * @param {?=} size     The new page size.
     * @return {?}
     */
    /* istanbul ignore next */
    pageSize(size) { return; }
    ;
    /**
     * Destroys the igGridPaging feature by removing all elements in the pager area, unbinding events, and resetting data to discard data filtering on paging.
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
}
IgGridPagingFeature.decorators = [
    { type: Directive, args: [{
                selector: 'paging',
                inputs: ["disabled", "create", "pageSize", "recordCountKey", "pageSizeUrlKey", "pageIndexUrlKey", "currentPageIndex", "type", "showPageSizeDropDown", "pageSizeDropDownLabel", "pageSizeDropDownTrailingLabel", "pageSizeDropDownLocation", "showPagerRecordsLabel", "pagerRecordsLabelTemplate", "nextPageLabelText", "prevPageLabelText", "firstPageLabelText", "lastPageLabelText", "showFirstLastPages", "showPrevNextPages", "currentPageDropDownLeadingLabel", "currentPageDropDownTrailingLabel", "currentPageDropDownTooltip", "pageSizeDropDownTooltip", "pagerRecordsLabelTooltip", "prevPageTooltip", "nextPageTooltip", "firstPageTooltip", "lastPageTooltip", "pageTooltipFormat", "pageSizeList", "pageCountLimit", "visiblePageCount", "defaultDropDownWidth", "delayOnPageChanged", "persist", "inherit"],
                outputs: ["pageIndexChanging", "pageIndexChanged", "pageSizeChanging", "pageSizeChanged", "pagerRendering", "pagerRendered"]
            },] }
];
/** @nocollapse */
IgGridPagingFeature.ctorParameters = () => [
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgGridUpdatingFeature extends Feature {
    /**
     * @param {?} el
     */
    constructor(el) {
        super(el);
    }
    /**
     * Sets a cell value for the specified cell. It also creates a transaction and updates the UI.
     * 			If the specified cell is currently in edit mode, the function will set the desired value in the cell's editor instead.
     *
     * @param {?} rowId    The primary key of the row the cell is a child of.
     * @param {?} colKey    The column key of the cell.
     * @param {?} value    The new value for the cell.
     * @return {?}
     */
    /* istanbul ignore next */
    setCellValue(rowId, colKey, value) { return; }
    ;
    /**
     * Sets values for specified cells in a row. It also creates a transaction and updates the UI.
     * 			If the specified row is currently in edit mode, the function will set the desired values in the row's editors instead.
     *
     * @param {?} rowId    The primary key of the row to update.
     * @param {?} values    Pairs of values in the format { column1Key: value1, column2Key: value2, ... } .
     * @return {?}
     */
    /* istanbul ignore next */
    updateRow(rowId, values) { return; }
    ;
    /**
     * Adds a new row to the grid. It also creates a transaction and updates the UI.
     *
     * @param {?} values    Pairs of values in the format { column1Key: value1, column2Key: value2, ... } .
     * @return {?}
     */
    /* istanbul ignore next */
    addRow(values) { return; }
    ;
    /**
     * Deletes a row from the grid. It also creates a transaction and updates the UI.
     *
     * @param {?} rowId    The primary key of the row to delete.
     * @return {?}
     */
    /* istanbul ignore next */
    deleteRow(rowId) { return; }
    ;
    /**
     * Starts editing for the row or cell specified (depending on the [editMode](ui.iggridupdating#options:editMode)).
     *
     * @param {?} rowId    The row id.
     * @param {?} column    The column key or index.
     * @param {?=} raiseEvents    Specifies whether or not updating events should be raised for this operation.
     * @return {?}
     */
    /* istanbul ignore next */
    startEdit(rowId, column, raiseEvents) { return; }
    ;
    /**
     * Starts editing for adding a new row.
     *
     * @param {?=} raiseEvents    Specifies whether or not updating events should be raised for this operation.
     * @return {?}
     */
    /* istanbul ignore next */
    startAddRowEdit(raiseEvents) { return; }
    ;
    /**
     * Ends the currently active edit mode.
     *
     * @param {?=} update    Specifies if the edit process should accept the current changes. Default is 'false'.
     * @param {?=} raiseEvents    Specifies whether or not updating events should be raised for this operation.
     * @return {?}
     */
    /* istanbul ignore next */
    endEdit(update, raiseEvents) { return; }
    ;
    /**
     * Finds and returns the key of the first column the editor for which has invalid value.
     * @return {?}
     */
    /* istanbul ignore next */
    findInvalid() { return; }
    ;
    /**
     * Checks if the grid is in edit mode.
     * @return {?}
     */
    /* istanbul ignore next */
    isEditing() { return; }
    ;
    /**
     * Gets the editor for a column by the column key. That method can be used only after the editor has been created.
     *
     * @param {?} key    The key of the column.
     * @return {?}
     */
    /* istanbul ignore next */
    editorForKey(key) { return; }
    ;
    /**
     * Gets the editor for a column by the cell it resides in. If allowed the function can create the editor if it has not been created yet.
     *
     * @param {?} cell    Reference to the jQuery-wrapped TD object of the grid that the editor belongs to.
     * @param {?=} create    Requests to create the editor if it has not been created yet.
     * @return {?}
     */
    /* istanbul ignore next */
    editorForCell(cell, create) { return; }
    ;
    /**
     * Destroys igGridUpdating.
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
    /**
     * Shows the delete button for specific row.
     *
     * @param {?} row    A jQuery object of the targeted row.
     * @return {?}
     */
    /* istanbul ignore next */
    showDeleteButtonFor(row) { return; }
    ;
    /**
     * Hides the delete button.
     * @return {?}
     */
    /* istanbul ignore next */
    hideDeleteButton() { return; }
    ;
}
IgGridUpdatingFeature.decorators = [
    { type: Directive, args: [{
                selector: 'updating',
                inputs: ["disabled", "create", "columnSettings", "editMode", "enableDeleteRow", "enableAddRow", "validation", "doneLabel", "doneTooltip", "cancelLabel", "cancelTooltip", "addRowLabel", "addRowTooltip", "deleteRowLabel", "deleteRowTooltip", "showDoneCancelButtons", "enableDataDirtyException", "startEditTriggers", "horizontalMoveOnEnter", "excelNavigationMode", "saveChangesSuccessHandler", "saveChangesErrorHandler", "swipeDistance", "wrapAround", "rowEditDialogOptions", "dialogWidget", "inherit"],
                outputs: ["editRowStarting", "editRowStarted", "editRowEnding", "editRowEnded", "editCellStarting", "editCellStarted", "editCellEnding", "editCellEnded", "rowAdding", "rowAdded", "rowDeleting", "rowDeleted", "dataDirty", "generatePrimaryKeyValue", "rowEditDialogBeforeOpen", "rowEditDialogAfterOpen", "rowEditDialogBeforeClose", "rowEditDialogAfterClose", "rowEditDialogContentsRendered"]
            },] }
];
/** @nocollapse */
IgGridUpdatingFeature.ctorParameters = () => [
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgGridGroupByFeature extends Feature {
    /**
     * @param {?} el
     */
    constructor(el) {
        super(el);
    }
    /**
     * Open groupby modal dialog
     * @return {?}
     */
    /* istanbul ignore next */
    openGroupByDialog() { return; }
    ;
    /**
     * Close groupby modal dialog
     * @return {?}
     */
    /* istanbul ignore next */
    closeGroupByDialog() { return; }
    ;
    /**
     * Render groupby modal dialog and its content
     * @return {?}
     */
    /* istanbul ignore next */
    renderGroupByModalDialog() { return; }
    ;
    /**
     * Open layouts dropdown
     * @return {?}
     */
    /* istanbul ignore next */
    openDropDown() { return; }
    ;
    /**
     * Close layouts dropdown
     * @return {?}
     */
    /* istanbul ignore next */
    closeDropDown() { return; }
    ;
    /**
     * Check whether column with specified key and layout is grouped
     *
     * @param {?} key    key of the column
     * @param {?} layout    layout name
     * @return {?}
     */
    /* istanbul ignore next */
    checkColumnIsGrouped(key, layout) { return; }
    ;
    /**
     * Get grouped data by value for the specific column. NOTE: Before calling this function the data(that is passed as an argument) should be sorted by colKey.
     *
     * @param {?} data    data (sorted by colKey) that is used to get the records from.
     * @param {?} colKey    key of the column for which grouping will be applied.
     * @param {?=} idval    value of the column by which grouping will be applied.
     * @return {?}
     */
    /* istanbul ignore next */
    getGroupedData(data, colKey, idval) { return; }
    ;
    /**
     * Adds a column to the group by columns list, executes the group by operation and updates the view.
     * @return {?}
     */
    /* istanbul ignore next */
    groupByColumns() { return; }
    ;
    /**
     * Groups by a column
     *
     * @param {?} key    Column Key - group by the column with the specified key
     * @param {?=} layout    layout is an optional parameter. if set it means the grouped column is not in the root level but is a child layout column
     * @param {?=} sortingDirection    if not set it is taken from option defaultSortingDirection
     * @return {?}
     */
    /* istanbul ignore next */
    groupByColumn(key, layout, sortingDirection) { return; }
    ;
    /**
     * Removes the specified column from the group by columns list, executes the group by operation and updates the view.
     *
     * @param {?} key    Column Key - ungroup by the column with the specified key
     * @param {?=} layout    Layout is an optional parameter. If set it means the grouped column is not in the root level but is a child layout column.
     * @return {?}
     */
    /* istanbul ignore next */
    ungroupByColumn(key, layout) { return; }
    ;
    /**
     * Expand group row with specified id
     *
     * @param {?} rowId    data-id attribute of the group row in the DOM
     * @return {?}
     */
    /* istanbul ignore next */
    expand(rowId) { return; }
    ;
    /**
     * Expand group row with specified id
     *
     * @param {?} rowId    data-id attribute of the group row in the DOM
     * @return {?}
     */
    /* istanbul ignore next */
    collapse(rowId) { return; }
    ;
    /**
     * Clears the group by columns list and updates the view.
     * @return {?}
     */
    /* istanbul ignore next */
    ungroupAll() { return; }
    ;
    /**
     * Destroys the group by feature object.
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
}
IgGridGroupByFeature.decorators = [
    { type: Directive, args: [{
                selector: 'group-by',
                inputs: ["disabled", "create", "groupByAreaVisibility", "initialExpand", "emptyGroupByAreaContent", "emptyGroupByAreaContentSelectColumns", "expansionIndicatorVisibility", "groupByLabelWidth", "labelDragHelperOpacity", "indentation", "defaultSortingDirection", "groupedColumns", "resultResponseKey", "groupedRowTextTemplate", "type", "groupByUrlKey", "groupByUrlKeyAscValue", "groupByUrlKeyDescValue", "summarySettings", "columnSettings", "expandTooltip", "collapseTooltip", "removeButtonTooltip", "modalDialogGroupByOnClick", "modalDialogGroupByButtonText", "modalDialogCaptionButtonDesc", "modalDialogCaptionButtonAsc", "modalDialogCaptionButtonUngroup", "modalDialogCaptionText", "modalDialogDropDownLabel", "modalDialogRootLevelHierarchicalGrid", "modalDialogDropDownButtonCaption", "modalDialogClearAllButtonLabel", "emptyGroupByAreaContentSelectColumnsCaption", "modalDialogDropDownWidth", "modalDialogDropDownAreaWidth", "modalDialogAnimationDuration", "modalDialogWidth", "modalDialogHeight", "modalDialogButtonApplyText", "modalDialogButtonCancelText", "useGridColumnFormatter", "persist", "groupByDialogContainment", "dialogWidget", "inherit"],
                outputs: ["groupedColumnsChanging", "groupedColumnsChanged", "modalDialogMoving", "modalDialogClosing", "modalDialogClosed", "modalDialogOpening", "modalDialogOpened", "modalDialogContentsRendering", "modalDialogContentsRendered", "modalDialogButtonApplyClick", "modalDialogButtonResetClick", "modalDialogGroupingColumn", "modalDialogGroupColumn", "modalDialogUngroupingColumn", "modalDialogUngroupColumn", "modalDialogSortGroupedColumn"]
            },] }
];
/** @nocollapse */
IgGridGroupByFeature.ctorParameters = () => [
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgGridColumnMovingFeature extends Feature {
    /**
     * @param {?} el
     */
    constructor(el) {
        super(el);
    }
    /**
     * Restoring overwritten functions
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
    /**
     * Moves a visible column at a specified place, in front or behind a target column or at a target index
     * 			Note: This method is asynchronous which means that it returns immediately and any subsequent code will execute in parallel. This may lead to runtime errors. To avoid them put the subsequent code in the callback parameter provided by the method.
     *
     * @param {?} column    An identifier of the column to be moved. It can be a key, a Multi-Column Header identificator, or an index in a number format. The latter is not supported when the grid contains multi-column headers.
     * @param {?} target    An identifier of a column where the moved column should move to or an index at which the moved column should be moved to. In the case of a column identifier the column will be moved after it by default.
     * @param {?=} after    Specifies whether the column moved should be moved after or before the target column.
     * @param {?=} inDom    Specifies whether the column moving will be enacted through DOM manipulation or through rerendering of the grid.
     * @param {?=} callback    Specifies a custom function to be called when the column is moved.
     * @return {?}
     */
    /* istanbul ignore next */
    moveColumn(column, target, after, inDom, callback) { return; }
    ;
}
IgGridColumnMovingFeature.decorators = [
    { type: Directive, args: [{
                selector: 'column-moving',
                inputs: ["disabled", "create", "columnSettings", "mode", "moveType", "addMovingDropdown", "movingDialogWidth", "movingDialogHeight", "movingDialogAnimationDuration", "movingAcceptanceTolerance", "movingScrollTolerance", "scrollSpeedMultiplier", "scrollDelta", "hideHeaderContentsDuringDrag", "dragHelperOpacity", "movingDialogCaptionButtonDesc", "movingDialogCaptionButtonAsc", "movingDialogCaptionText", "movingDialogDisplayText", "movingDialogDropTooltipText", "movingDialogDropTooltipMarkup", "dropDownMoveLeftText", "dropDownMoveRightText", "dropDownMoveFirstText", "dropDownMoveLastText", "movingToolTipMove", "featureChooserSubmenuText", "columnMovingDialogContainment", "dialogWidget", "inherit"],
                outputs: ["columnDragStart", "columnDragEnd", "columnDragCanceled", "columnMoving", "columnMoved", "movingDialogOpening", "movingDialogOpened", "movingDialogDragged", "movingDialogClosing", "movingDialogClosed", "movingDialogContentsRendering", "movingDialogContentsRendered", "movingDialogMoveUpButtonPressed", "movingDialogMoveDownButtonPressed", "movingDialogDragColumnMoving", "movingDialogDragColumnMoved"]
            },] }
];
/** @nocollapse */
IgGridColumnMovingFeature.ctorParameters = () => [
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgGridHidingFeature extends Feature {
    /**
     * @param {?} el
     */
    constructor(el) {
        super(el);
    }
    /**
     * Destroys the hiding widget
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
    /**
     * Shows the Column Chooser dialog. If it is visible the method does nothing.
     * @return {?}
     */
    /* istanbul ignore next */
    showColumnChooser() { return; }
    ;
    /**
     * Hides the Column Chooser dialog. If it is not visible the method does nothing.
     * @return {?}
     */
    /* istanbul ignore next */
    hideColumnChooser() { return; }
    ;
    /**
     * Shows a hidden column. If the column is not hidden the method does nothing.
     * 			Note: This method is asynchronous which means that it returns immediately and any subsequent code will execute in parallel. This may lead to runtime errors. To avoid them put the subsequent code in the callback parameter provided by the method.
     *
     * @param {?} column    An identifier for the column. If a number is provided it will be used as a column index else if a strings is provided it will be used as a column key.
     * @param {?=} isMultiColumnHeader    If it is true then the column is of type multicolumnheader. An identifier for the column should be of type string.
     * @param {?=} callback    Specifies a custom function to be called when the column(s) is shown(optional)
     * @return {?}
     */
    /* istanbul ignore next */
    showColumn(column, isMultiColumnHeader, callback) { return; }
    ;
    /**
     * Hides a visible column. If the column is hidden the method does nothing.
     * 			Note: This method is asynchronous which means that it returns immediately and any subsequent code will execute in parallel. This may lead to runtime errors. To avoid them put the subsequent code in the callback parameter provided by the method.
     *
     * @param {?} column    An identifier for the column. If a number is provided it will be used as a column index else if a strings is provided it will be used as a column key.
     * @param {?=} isMultiColumnHeader    If it is true then the column is of type multicolumnheader. An identifier for the column should be of type string.
     * @param {?=} callback    Specifies a custom function to be called when the column is hidden(optional)
     * @return {?}
     */
    /* istanbul ignore next */
    hideColumn(column, isMultiColumnHeader, callback) { return; }
    ;
    /**
     * Hides visible columns specified by the array. If the column is hidden the method does nothing.
     * 			Note: This method is asynchronous which means that it returns immediately and any subsequent code will execute in parallel. This may lead to runtime errors. To avoid them put the subsequent code in the callback parameter provided by the method.
     *
     * @param {?} columns    An array of identifiers for the columns. If a number is provided it will be used as a column index else if a strings is provided it will be used as a column key.
     * @param {?=} callback    Specifies a custom function to be called when all columns are hidden(optional)
     * @return {?}
     */
    /* istanbul ignore next */
    hideMultiColumns(columns, callback) { return; }
    ;
    /**
     * Show visible columns specified by the array. If the column is shown the method does nothing.
     * 			Note: This method is asynchronous which means that it returns immediately and any subsequent code will execute in parallel. This may lead to runtime errors. To avoid them put the subsequent code in the callback parameter provided by the method.
     *
     * @param {?} columns    An array of identifiers for the columns. If a number is provided it will be used as a column index else if a strings is provided it will be used as a column key.
     * @param {?=} callback    Specifies a custom function to be called when all columns are shown(optional)
     * @return {?}
     */
    /* istanbul ignore next */
    showMultiColumns(columns, callback) { return; }
    ;
    /**
     * Gets whether the reset button in the column chooser dialog is to be rendered or not.
     * @return {?}
     */
    /* istanbul ignore next */
    isToRenderButtonReset() { return; }
    ;
    /**
     * Reset hidden/shown column to initial state of dialog(when it is opened)
     * @return {?}
     */
    /* istanbul ignore next */
    resetHidingColumnChooser() { return; }
    ;
    /**
     * Renders the Reset button in the Column Chooser dialog.
     * @return {?}
     */
    /* istanbul ignore next */
    renderColumnChooserResetButton() { return; }
    ;
    /**
     * Remove Reset button in column chooser modal dialog
     * @return {?}
     */
    /* istanbul ignore next */
    removeColumnChooserResetButton() { return; }
    ;
}
IgGridHidingFeature.decorators = [
    { type: Directive, args: [{
                selector: 'hiding',
                inputs: ["disabled", "create", "columnSettings", "hiddenColumnIndicatorHeaderWidth", "columnChooserContainment", "columnChooserWidth", "columnChooserHeight", "dropDownAnimationDuration", "columnChooserCaptionText", "columnChooserDisplayText", "hiddenColumnIndicatorTooltipText", "columnHideText", "columnChooserShowText", "columnChooserHideText", "columnChooserHideOnClick", "columnChooserResetButtonLabel", "columnChooserAnimationDuration", "columnChooserButtonApplyText", "columnChooserButtonCancelText", "dialogWidget", "inherit"],
                outputs: ["columnHiding", "columnHidingRefused", "columnShowingRefused", "multiColumnHiding", "columnHidden", "columnShowing", "columnShown", "columnChooserOpening", "columnChooserOpened", "columnChooserMoving", "columnChooserClosing", "columnChooserClosed", "columnChooserContentsRendering", "columnChooserContentsRendered", "columnChooserButtonApplyClick", "columnChooserButtonResetClick"]
            },] }
];
/** @nocollapse */
IgGridHidingFeature.ctorParameters = () => [
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgGridCellMergingFeature extends Feature {
    /**
     * @param {?} el
     */
    constructor(el) {
        super(el);
    }
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    destroy() { return; }
    ;
}
IgGridCellMergingFeature.decorators = [
    { type: Directive, args: [{
                selector: 'cell-merging',
                inputs: ["disabled", "create", "initialState", "inherit"],
                outputs: ["cellsMerging", "cellsMerged"]
            },] }
];
/** @nocollapse */
IgGridCellMergingFeature.ctorParameters = () => [
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgGridResponsiveFeature extends Feature {
    /**
     * @param {?} el
     */
    constructor(el) {
        super(el);
    }
    /**
     * Destroys the responsive widget.
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
    /**
     * Returns the currently active responsive mode.
     * @return {?}
     */
    /* istanbul ignore next */
    getCurrentResponsiveMode() { return; }
    ;
}
IgGridResponsiveFeature.decorators = [
    { type: Directive, args: [{
                selector: 'responsive',
                inputs: ["disabled", "create", "columnSettings", "reactOnContainerWidthChanges", "forceResponsiveGridWidth", "responsiveSensitivity", "responsiveModes", "enableVerticalRendering", "windowWidthToRenderVertically", "propertiesColumnWidth", "valuesColumnWidth", "allowedColumnWidthPerType", "singleColumnTemplate", "inherit"],
                outputs: ["responsiveColumnHiding", "responsiveColumnHidden", "responsiveColumnShowing", "responsiveColumnShown", "responsiveModeChanged"]
            },] }
];
/** @nocollapse */
IgGridResponsiveFeature.ctorParameters = () => [
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgGridResizingFeature extends Feature {
    /**
     * @param {?} el
     */
    constructor(el) {
        super(el);
    }
    /**
     * Destroys the resizing widget
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
    /**
     * Resizes a column to a specified width in pixels, percents or auto if no width is specified.
     *
     * @param {?} column    An identifier for the column. If a number is provided it will be used as a columnIndex else if a strings is provided it will be used as a columnKey.
     * @param {?=} width    Width of the column in pixels or percents. If no width or "*" is specified the column will be auto-sized to the width of the data in it (including header and footer cells).
     * @return {?}
     */
    /* istanbul ignore next */
    resize(column, width) { return; }
    ;
}
IgGridResizingFeature.decorators = [
    { type: Directive, args: [{
                selector: 'resizing',
                inputs: ["disabled", "create", "allowDoubleClickToResize", "deferredResizing", "columnSettings", "handleThreshold", "inherit"],
                outputs: ["columnResizing", "columnResizingRefused", "columnResized"]
            },] }
];
/** @nocollapse */
IgGridResizingFeature.ctorParameters = () => [
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgGridSelectionFeature extends Feature {
    /**
     * @param {?} el
     */
    constructor(el) {
        super(el);
    }
    /**
     * Destroys the selection widget.
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
    /**
     * Clears all selected cells, selected rows, active cell and active row. Also updates the UI accordingly
     * @return {?}
     */
    /* istanbul ignore next */
    clearSelection() { return; }
    ;
    /**
     * Selects a cell by row/col
     *
     * @param {?} row     Row index
     * @param {?} col     Column index
     * @param {?=} isFixed     If the cell is part of the fixed or unfixed area of the grid.
     * @return {?}
     */
    /* istanbul ignore next */
    selectCell(row, col, isFixed) { return; }
    ;
    /**
     * Selects a cell by row id/column key
     *
     * @param {?} id     Row Id
     * @param {?} colKey     Column key
     * @return {?}
     */
    /* istanbul ignore next */
    selectCellById(id, colKey) { return; }
    ;
    /**
     * Deselects a cell by row/col
     *
     * @param {?} row     Row index
     * @param {?} col     Column index
     * @param {?=} isFixed     If the cell is part of the fixed or unfixed area of the grid.
     * @return {?}
     */
    /* istanbul ignore next */
    deselectCell(row, col, isFixed) { return; }
    ;
    /**
     * Deselects a cell by row id/column key
     *
     * @param {?} id     Row Id
     * @param {?} colKey     Column key
     * @return {?}
     */
    /* istanbul ignore next */
    deselectCellById(id, colKey) { return; }
    ;
    /**
     * Selects a row by index
     *
     * @param {?} index     Row index
     * @return {?}
     */
    /* istanbul ignore next */
    selectRow(index) { return; }
    ;
    /**
     * Selects a row by row id
     *
     * @param {?} id     Row Id
     * @return {?}
     */
    /* istanbul ignore next */
    selectRowById(id) { return; }
    ;
    /**
     * Deselects a row by index
     *
     * @param {?} index     Row index
     * @return {?}
     */
    /* istanbul ignore next */
    deselectRow(index) { return; }
    ;
    /**
     * Deselects a row by row id
     *
     * @param {?} id     Row Id
     * @return {?}
     */
    /* istanbul ignore next */
    deselectRowById(id) { return; }
    ;
    /**
     * Returns an array of selected cells in arbitrary order where every objects has the format { element: , row: , index: , rowIndex: , columnKey: } .
     *
     * 				If multiple selection is disabled the function will return null.
     * @return {?}
     */
    /* istanbul ignore next */
    selectedCells() { return; }
    ;
    /**
     * Returns an array of selected rows in arbitrary order where every object has the format { element: , index: } .
     *
     * 				If multiple selection is disabled the function will return null.
     * @return {?}
     */
    /* istanbul ignore next */
    selectedRows() { return; }
    ;
    /**
     * Returns the currently selected cell that has the format { element: , row: , index: , rowIndex: , columnKey: }, if any.
     *
     * 				If multiple selection is enabled the function will return null.
     * @return {?}
     */
    /* istanbul ignore next */
    selectedCell() { return; }
    ;
    /**
     * Returns the currently selected row that has the format { element: , index: }, if any.
     *
     * 				If multiple selection is enabled the function will return null.
     * @return {?}
     */
    /* istanbul ignore next */
    selectedRow() { return; }
    ;
    /**
     * Returns the currently active (focused) cell that has the format { element: , row: , index: , rowIndex: , columnKey: }, if any.
     * @return {?}
     */
    /* istanbul ignore next */
    activeCell() { return; }
    ;
    /**
     * Returns the currently active (focused) row that has the format { element: , index: }, if any.
     * @return {?}
     */
    /* istanbul ignore next */
    activeRow() { return; }
    ;
}
IgGridSelectionFeature.decorators = [
    { type: Directive, args: [{
                selector: 'selection',
                inputs: ["disabled", "create", "multipleSelection", "mouseDragSelect", "mode", "activation", "wrapAround", "skipChildren", "multipleCellSelectOnClick", "touchDragSelect", "persist", "allowMultipleRangeSelection"],
                outputs: ["rowSelectionChanging", "rowSelectionChanged", "cellSelectionChanging", "cellSelectionChanged", "activeCellChanging", "activeCellChanged", "activeRowChanging", "activeRowChanged"]
            },] }
];
/** @nocollapse */
IgGridSelectionFeature.ctorParameters = () => [
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgGridRowSelectorsFeature extends Feature {
    /**
     * @param {?} el
     */
    constructor(el) {
        super(el);
    }
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    destroy() { return; }
    ;
}
IgGridRowSelectorsFeature.decorators = [
    { type: Directive, args: [{
                selector: 'row-selectors',
                inputs: ["disabled", "create", "enableRowNumbering", "enableCheckBoxes", "rowNumberingSeed", "rowSelectorColumnWidth", "requireSelection", "showCheckBoxesOnFocus", "inherit", "enableSelectAllForPaging", "selectAllForPagingTemplate", "deselectAllForPagingTemplate"],
                outputs: ["rowSelectorClicked", "checkBoxStateChanging", "checkBoxStateChanged"]
            },] }
];
/** @nocollapse */
IgGridRowSelectorsFeature.ctorParameters = () => [
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgGridSummariesFeature extends Feature {
    /**
     * @param {?} el
     */
    constructor(el) {
        super(el);
    }
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    destroy() { return; }
    ;
    /**
     * Returns whether summaries rows are hidden
     * @return {?}
     */
    /* istanbul ignore next */
    isSummariesRowsHidden() { return; }
    ;
    /**
     * Calculate summaries
     * @return {?}
     */
    /* istanbul ignore next */
    calculateSummaries() { return; }
    ;
    /**
     * Remove all summaries dropdown buttons.
     * @return {?}
     */
    /* istanbul ignore next */
    clearAllFooterIcons() { return; }
    ;
    /**
     * Toggle drop down
     *
     * @param {?} columnKey    toggle drop down for the column with the specified key
     * @param {?} event    event object. Its data should contain current columnKey, isAnimating, buttonId
     * @return {?}
     */
    /* istanbul ignore next */
    toggleDropDown(columnKey, event) { return; }
    ;
    /**
     * Show/Hide dialog
     *
     * @param {?} $dialog     jQuery object representation of dropdown div element
     * @return {?}
     */
    /* istanbul ignore next */
    showHideDialog($dialog) { return; }
    ;
    /**
     * Toggle summaries rows
     *
     * @param {?} isToShow    Specifies whether to show or not summaries
     * @param {?} isInternalCall    Optional parameter.Specifies whether this function is called internally by the widget.
     * @return {?}
     */
    /* istanbul ignore next */
    toggleSummariesRows(isToShow, isInternalCall) { return; }
    ;
    /**
     * Toggles the checkstate of a checkbox if checkboxMode is not set to off, otherwise does nothing.
     *
     * @param {?} $checkbox     Specifies the jQuery object of the checkbox.
     * @return {?}
     */
    /* istanbul ignore next */
    toggleCheckstate($checkbox) { return; }
    ;
    /**
     * Select/Unselect specified checkbox
     *
     * @param {?} $checkbox     Specifies the jQuery object for checkbox
     * @param {?} isToSelect     Specify whether to select or not checkbox
     * @return {?}
     */
    /* istanbul ignore next */
    selectCheckBox($checkbox, isToSelect) { return; }
    ;
    /**
     * Summary calculate the whole data for the specified column key, columnMethods and dataType (used when datasource is remote and dataType is date)
     *
     * @param {?} ck    ColumnKey
     * @param {?} columnMethods    Array of column methods objects
     * @param {?} data    Object which represents result
     * represents dataType for the current column
     * @param {?} dataType
     * @return {?}
     */
    /* istanbul ignore next */
    calculateSummaryColumn(ck, columnMethods, data, dataType) { return; }
    ;
    /**
     * Return a JQUERY object which holds all summaries for all columns
     * @return {?}
     */
    /* istanbul ignore next */
    summaryCollection() { return; }
    ;
    /**
     * Return a JQUERY object which holds all summaries for column with the specified column key
     *
     * @param {?} columnKey
     * @return {?}
     */
    /* istanbul ignore next */
    summariesFor(columnKey) { return; }
    ;
}
IgGridSummariesFeature.decorators = [
    { type: Directive, args: [{
                selector: 'summaries',
                inputs: ["disabled", "create", "type", "dialogButtonOKText", "dialogButtonCancelText", "calculateRenderMode", "featureChooserText", "featureChooserTextHide", "compactRenderingMode", "defaultDecimalDisplay", "showSummariesButton", "summariesResponseKey", "summaryExprUrlKey", "callee", "dropDownHeight", "dropDownWidth", "showDropDownButton", "summaryExecution", "dropDownDialogAnimationDuration", "emptyCellText", "summariesHeaderButtonTooltip", "resultTemplate", "isGridFormatter", "renderSummaryCellFunc", "columnSettings", "inherit"],
                outputs: ["dropDownOpening", "dropDownOpened", "dropDownClosing", "dropDownClosed", "summariesCalculating", "summariesCalculated", "summariesMethodSelectionChanged", "summariesToggling", "summariesToggled", "dropDownOKClicked", "dropDownCancelClicked"]
            },] }
];
/** @nocollapse */
IgGridSummariesFeature.ctorParameters = () => [
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgGridColumnFixingFeature extends Feature {
    /**
     * @param {?} el
     */
    constructor(el) {
        super(el);
    }
    /**
     * Unfixes a column by specified column identifier - column key or column index.
     *
     * @param {?} colIdentifier    An identifier of the column to be unfixed - column index or column key.
     * @param {?=} target    Key of the column where the unfixed column should move to.
     * @param {?=} after    Specifies where the unfixed column should be rendered after or before the target column. This parameter is disregarded if there is no target column specified.
     * @return {?}
     */
    /* istanbul ignore next */
    unfixColumn(colIdentifier, target, after) { return; }
    ;
    /**
     * Checks whether the heights of fixed and unfixed tables are equal - if not sync them. Similar check is made for heights of table rows.
     * @return {?}
     */
    /* istanbul ignore next */
    checkAndSyncHeights() { return; }
    ;
    /**
     * If the 'check' argument is set to true, checks whether the heights of fixed and unfixed tables are equal, if not sync them. Similar check is made for heights of table rows. If the clearRowsHeights argument is set to true, clears rows heights before syncing them.
     *
     * @param {?=} check    If set to true, checks whether the heights of fixed and unfixed tables are equal, if not sync them. If this argument is set to false sync is performed regardless of the current heights.
     * @param {?=} clearRowsHeights    Clears row heigths for all visible rows.
     * @return {?}
     */
    /* istanbul ignore next */
    syncHeights(check, clearRowsHeights) { return; }
    ;
    /**
     * Returns whether the column with the specified key is a column group header, when the [multi-column headers](http://www.igniteui.com/help/iggrid-multicolumnheaders-landingpage) feature is used.
     *
     * @param {?} colKey    The key of the column to perform the check for.
     * @return {?}
     */
    /* istanbul ignore next */
    isGroupHeader(colKey) { return; }
    ;
    /**
     * Checks whether column fixing is allowed for the specified columns. It should not be allowed if there is only one visible column in the unfixed area.
     *
     * @param {?} columns    Array of columns and/or column identifiers - could be column indexes, column keys, column object or mixed.
     * @return {?}
     */
    /* istanbul ignore next */
    checkFixingAllowed(columns) { return; }
    ;
    /**
     * Checks whether unfixing is allowed for the specified columns. It should not be allowed if there is only one visible column in the fixed area.
     *
     * @param {?} columns    Array of columns and/or column identifiers - could be column indexes, column keys, column object or mixed.
     * @return {?}
     */
    /* istanbul ignore next */
    checkUnfixingAllowed(columns) { return; }
    ;
    /**
     * Fixes non-data columns (such as the row numbering column of row selectors) if any and if [fixingDirection](ui.iggridcolumnfixing#options:fixingDirection) is left. Does nothing if the non-data columns are already fixed.
     * @return {?}
     */
    /* istanbul ignore next */
    fixNonDataColumns() { return; }
    ;
    /**
     * This function is deprecated - use function fixNonDataColumns.
     * @return {?}
     */
    /* istanbul ignore next */
    fixDataSkippedColumns() { return; }
    ;
    /**
     * Unfixes non-data columns (such as the row numbering column of row selectors) if any and if [fixingDirection](ui.iggridcolumnfixing#options:fixingDirection) is left. Does nothing if the non-data columns are already fixed.
     * @return {?}
     */
    /* istanbul ignore next */
    unfixNonDataColumns() { return; }
    ;
    /**
     * This function is deprecated - use function unfixNonDataColumns.
     * @return {?}
     */
    /* istanbul ignore next */
    unfixDataSkippedColumns() { return; }
    ;
    /**
     * Unfixes all fixed columns.
     * @return {?}
     */
    /* istanbul ignore next */
    unfixAllColumns() { return; }
    ;
    /**
     * Syncs rows heights between two collections of rows.
     *
     * @param {?} $trs    An array of rows of the first(fixed/unfixed) container.
     * @param {?} $anotherRows    An array of rows of the second(fixed/unfixed) container.
     * @return {?}
     */
    /* istanbul ignore next */
    syncRowsHeights($trs, $anotherRows) { return; }
    ;
    /**
     * Calculates widths of the fixed columns.
     *
     * @param {?=} fCols    Array of grid columns. If not set then the total width of the fixed columns are returned.
     * @param {?=} excludeNonDataColumns    If set to true do not calculate the width of non-data fixed columns (like the row selector row numbering column).
     * @param {?=} includeHidden    If set to true calculates width of the hidden fixed columns (their initial width before hiding).
     * @return {?}
     */
    /* istanbul ignore next */
    getWidthOfFixedColumns(fCols, excludeNonDataColumns, includeHidden) { return; }
    ;
    /**
     * Destroys the column fixing widget
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
}
IgGridColumnFixingFeature.decorators = [
    { type: Directive, args: [{
                selector: 'column-fixing',
                inputs: ["disabled", "create", "headerFixButtonText", "headerUnfixButtonText", "showFixButtons", "syncRowHeights", "scrollDelta", "fixingDirection", "columnSettings", "featureChooserTextFixedColumn", "featureChooserTextUnfixedColumn", "minimalVisibleAreaWidth", "fixNondataColumns", "populateDataRowsAttributes"],
                outputs: ["columnFixing", "columnFixed", "columnUnfixing", "columnUnfixed", "columnFixingRefused", "columnUnfixingRefused"]
            },] }
];
/** @nocollapse */
IgGridColumnFixingFeature.ctorParameters = () => [
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgGridTooltipsFeature extends Feature {
    /**
     * @param {?} el
     */
    constructor(el) {
        super(el);
    }
    /**
     * Destroys the tooltip widget.
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
    /**
     * Returns the ID of the parent div element bounding the ruler and the tooltip container
     * @return {?}
     */
    /* istanbul ignore next */
    id() { return; }
    ;
}
IgGridTooltipsFeature.decorators = [
    { type: Directive, args: [{
                selector: 'tooltips',
                inputs: ["disabled", "create", "visibility", "style", "showDelay", "hideDelay", "columnSettings", "fadeTimespan", "cursorLeftOffset", "cursorTopOffset", "inherit"],
                outputs: ["tooltipShowing", "tooltipShown", "tooltipHiding", "tooltipHidden"]
            },] }
];
/** @nocollapse */
IgGridTooltipsFeature.ctorParameters = () => [
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgGridAppendRowsOnDemandFeature extends Feature {
    /**
     * @param {?} el
     */
    constructor(el) {
        super(el);
    }
    /**
     * Destroys the append rows on demand widget
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
    /**
     * Loads the next chunk of data.
     * @return {?}
     */
    /* istanbul ignore next */
    nextChunk() { return; }
    ;
}
IgGridAppendRowsOnDemandFeature.decorators = [
    { type: Directive, args: [{
                selector: 'append-rows-on-demand',
                inputs: ["type", "chunkSize", "recordCountKey", "chunkSizeUrlKey", "chunkIndexUrlKey", "defaultChunkIndex", "currentChunkIndex", "loadTrigger", "loadMoreDataButtonText"],
                outputs: ["rowsRequesting", "rowsRequested"]
            },] }
];
/** @nocollapse */
IgGridAppendRowsOnDemandFeature.ctorParameters = () => [
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Features {
    constructor() {
        this.allFeatures = new Array();
    }
    /**
     * @param {?} name
     * @param {?} parent
     * @return {?}
     */
    addFeature(name, parent) {
        /** @type {?} */
        var nodeName = name.replace(/([A-Z])/g, (/**
         * @param {?} g
         * @return {?}
         */
        function (g) { return '-' + g[0].toLowerCase(); }));
        /** @type {?} */
        var el = document.createElement(nodeName);
        el = parent.appendChild(el);
        /** @type {?} */
        var child = new ElementRef(el);
        switch (nodeName) {
            case "filtering":
                this.filtering = new IgGridFilteringFeature(child);
                break;
            case "sorting":
                this.sorting = new IgGridSortingFeature(child);
                break;
            case "paging":
                this.paging = new IgGridPagingFeature(child);
                break;
            case "updating":
                this.updating = new IgGridUpdatingFeature(child);
                break;
            case "group-by":
                this.groupBy = new IgGridGroupByFeature(child);
                break;
            case "column-moving":
                this.columnMoving = new IgGridColumnMovingFeature(child);
                break;
            case "hiding":
                this.hiding = new IgGridHidingFeature(child);
                break;
            case "responsive":
                this.responsive = new IgGridResponsiveFeature(child);
                break;
            case "cell-merging":
                this.cellMerging = new IgGridCellMergingFeature(child);
                break;
            case "resizing":
                this.resizing = new IgGridResizingFeature(child);
                break;
            case "selection":
                this.selection = new IgGridSelectionFeature(child);
                break;
            case "row-selectors":
                this.rowSelectors = new IgGridRowSelectorsFeature(child);
                break;
            case "summaries":
                this.summaries = new IgGridSummariesFeature(child);
                break;
            case "column-fixing":
                this.columnFixing = new IgGridColumnFixingFeature(child);
                break;
            case "tooltips":
                this.tooltips = new IgGridTooltipsFeature(child);
                break;
            case "append-rows-on-demand":
                this.appendRowsOnDemand = new IgGridAppendRowsOnDemandFeature(child);
                break;
            case "multi-column-headers":
                this.multiColumnHeaders = new IgGridMultiColumnHeadersFeature(child);
                break;
        }
        this[name].ngOnInit();
        this.allFeatures.push(this[name]);
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.filtering ? this.allFeatures.push(this.filtering) : null;
        this.sorting ? this.allFeatures.push(this.sorting) : null;
        this.paging ? this.allFeatures.push(this.paging) : null;
        this.updating ? this.allFeatures.push(this.updating) : null;
        this.groupBy ? this.allFeatures.push(this.groupBy) : null;
        this.columnMoving ? this.allFeatures.push(this.columnMoving) : null;
        this.hiding ? this.allFeatures.push(this.hiding) : null;
        this.responsive ? this.allFeatures.push(this.responsive) : null;
        this.cellMerging ? this.allFeatures.push(this.cellMerging) : null;
        this.resizing ? this.allFeatures.push(this.resizing) : null;
        this.selection ? this.allFeatures.push(this.selection) : null;
        this.rowSelectors ? this.allFeatures.push(this.rowSelectors) : null;
        this.summaries ? this.allFeatures.push(this.summaries) : null;
        this.columnFixing ? this.allFeatures.push(this.columnFixing) : null;
        this.tooltips ? this.allFeatures.push(this.tooltips) : null;
        this.appendRowsOnDemand ? this.allFeatures.push(this.appendRowsOnDemand) : null;
        this.multiColumnHeaders ? this.allFeatures.push(this.multiColumnHeaders) : null;
    }
}
Features.decorators = [
    { type: Directive, args: [{
                selector: 'features'
            },] }
];
Features.propDecorators = {
    sorting: [{ type: ContentChild, args: [IgGridSortingFeature, { static: true },] }],
    filtering: [{ type: ContentChild, args: [IgGridFilteringFeature, { static: true },] }],
    paging: [{ type: ContentChild, args: [IgGridPagingFeature, { static: true },] }],
    updating: [{ type: ContentChild, args: [IgGridUpdatingFeature, { static: true },] }],
    groupBy: [{ type: ContentChild, args: [IgGridGroupByFeature, { static: true },] }],
    columnMoving: [{ type: ContentChild, args: [IgGridColumnMovingFeature, { static: true },] }],
    hiding: [{ type: ContentChild, args: [IgGridHidingFeature, { static: true },] }],
    cellMerging: [{ type: ContentChild, args: [IgGridCellMergingFeature, { static: true },] }],
    responsive: [{ type: ContentChild, args: [IgGridResponsiveFeature, { static: true },] }],
    resizing: [{ type: ContentChild, args: [IgGridResizingFeature, { static: true },] }],
    selection: [{ type: ContentChild, args: [IgGridSelectionFeature, { static: true },] }],
    rowSelectors: [{ type: ContentChild, args: [IgGridRowSelectorsFeature, { static: true },] }],
    summaries: [{ type: ContentChild, args: [IgGridSummariesFeature, { static: true },] }],
    columnFixing: [{ type: ContentChild, args: [IgGridColumnFixingFeature, { static: true },] }],
    tooltips: [{ type: ContentChild, args: [IgGridTooltipsFeature, { static: true },] }],
    appendRowsOnDemand: [{ type: ContentChild, args: [IgGridAppendRowsOnDemandFeature, { static: true },] }],
    multiColumnHeaders: [{ type: ContentChild, args: [IgGridMultiColumnHeadersFeature, { static: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var NODES = {
    "ig-text-editor": "div",
    "ig-numeric-editor": "input",
    "ig-percent-editor": "input",
    "ig-mask-editor": "input",
    "ig-date-picker": "input",
    "ig-time-picker": "input",
    "ig-date-editor": "input",
    "ig-currency-editor": "input",
    "ig-checkbox-editor": "input",
    "ig-html-editor": "div",
    "ig-combo": "input",
    "ig-grid": "table",
    "ig-tree-grid": "table",
    "ig-hierarchical-grid": "table",
    "ig-pivot-data-selector": "div",
    "ig-pivot-grid": "table",
    "ig-data-chart": "div",
    "ig-pie-chart": "div",
    "ig-doughnut-chart": "div",
    "ig-funnel-chart": "div",
    "ig-radial-gauge": "div",
    "ig-sparkline": "div",
    "ig-zoombar": "div",
    "ig-map": "div",
    "ig-bullet-graph": "div",
    "ig-linear-gauge": "div",
    "ig-q-r-code-barcode": "div",
    "ig-validator": "div",
    "ig-upload": "div",
    "ig-popover": "div",
    "ig-rating": "div",
    "ig-video-player": "div",
    "ig-radial-menu": "div",
    "ig-split-button": "div",
    "ig-notifier": "div",
    "ig-tree": "div",
    "ig-dialog": "div",
    "ig-splitter": "div",
    "ig-layout-manager": "div",
    "ig-tile-manager": "div",
    "ig-spreadsheet": "div",
    "ig-scheduler": "div"
};
/**
 * @template Model
 */
class IgControlBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiffers, cdr) {
        this.kvalDiffers = kvalDiffers;
        this.cdr = cdr;
        this.options = {};
        this._evtEmmiters = {};
        this._differs = differs;
        this._nativeElement = el.nativeElement;
        this._widgetName = this.convertToCamelCase(el.nativeElement.nodeName.toLowerCase()); //ig-grid -> igGrid
        this._el = el.nativeElement.appendChild(document.createElement(NODES[el.nativeElement.nodeName.toLowerCase()]));
        for (var propt in jQuery.ui[this._widgetName].prototype.events) {
            this[propt] = new EventEmitter();
            //cahcing the event emmitters for cases when the event name is the same as a method name.
            this._evtEmmiters[propt] = this[propt];
        }
    }
    /**
     * @param {?} name
     * @return {?}
     */
    createSetter(name) {
        return (/**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.options[name] = value;
            if (this._config) {
                this._config[name] = value;
            }
            if (jQuery.ui[this._widgetName] &&
                jQuery.ui[this._widgetName].prototype.options &&
                jQuery.ui[this._widgetName].prototype.options.hasOwnProperty(name) &&
                jQuery(this._el).data(this._widgetName)) {
                jQuery(this._el)[this._widgetName]("option", name, value);
            }
        });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        var evtName;
        /** @type {?} */
        let that = this;
        this._events = new Map();
        for (var opt in jQuery.ui[this._widgetName].prototype.options) {
            //copy root level options into this.options
            if (this[opt] && typeof this[opt] !== "function") {
                this.options[opt] = this[opt];
            }
        }
        for (var opt in jQuery.ui[this._widgetName].prototype.options) {
            if (opt !== "dataSource") {
                Object.defineProperty(this, opt, {
                    set: this.createSetter(opt),
                    enumerable: true,
                    configurable: true
                });
            }
        }
        /** @type {?} */
        var propNames = jQuery.ui[this._widgetName].prototype;
        for (var name in propNames) {
            if (name.indexOf("_") !== 0 && typeof jQuery.ui[this._widgetName].prototype[name] === "function"
                && name !== "dataSource") {
                Object.defineProperty(that, name, {
                    get: that.createMethodGetter(name)
                });
            }
        }
        //events binding
        for (var propt in jQuery.ui[this._widgetName].prototype.events) {
            evtName = this._widgetName.toLowerCase() + propt.toLowerCase();
            this._events[evtName] = propt;
            jQuery(this._el).on(evtName, (/**
             * @param {?} evt
             * @param {?} ui
             * @return {?}
             */
            function (evt, ui) {
                /** @type {?} */
                var emmiter = that._evtEmmiters[that._events[evt.type]];
                emmiter.emit({ event: evt, ui: ui });
            }));
        }
        jQuery(this._el).attr("id", this.widgetId);
        jQuery(this._el)[this._widgetName](this.options);
    }
    /**
     * @param {?} name
     * @return {?}
     */
    createMethodGetter(name) {
        return (/**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var widget = jQuery(this._el).data(this._widgetName);
            return jQuery.proxy(widget[name], widget);
        });
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this._optsDiffer) {
            /** @type {?} */
            const changes = this._optsDiffer.diff(this.options);
            if (changes) {
                changes.forEachChangedItem((/**
                 * @param {?} change
                 * @return {?}
                 */
                (change) => {
                    this[change.key] = change.currentValue;
                }));
            }
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const opts = "options";
        if (opts in changes) {
            /** @type {?} */
            const value = changes[opts].currentValue;
            //options have been changed. Destroy and re-create widget.
            if (jQuery(this._el).data(this._widgetName)) {
                jQuery(this._el)[this._widgetName]("destroy");
                jQuery(this._el)[this._widgetName](this.options);
            }
            try {
                this._optsDiffer = this.kvalDiffers.find({}).create();
            }
            catch (e) {
                throw new Error("Only binding to object is supported for options property.");
            }
        }
    }
    /**
     * @return {?}
     */
    markForCheck() {
        this.cdr.markForCheck();
    }
    /**
     * @param {?} str
     * @return {?}
     */
    convertToCamelCase(str) {
        //convert hyphen to camelCase
        return str.replace(/-([a-z])/g, (/**
         * @param {?} group
         * @return {?}
         */
        function (group) {
            return group[1].toUpperCase();
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // igZoombar should be attached to body when being destroyed
        if (this._widgetName !== "igZoombar" || document.body.contains(this._el)) {
            jQuery(this._el)[this._widgetName]("destroy");
            jQuery(this._el).remove();
            jQuery(this._nativeElement).remove();
        }
    }
}
IgControlBase.propDecorators = {
    options: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template Model
 */
class IgGridBase extends IgControlBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiffers, cdr) { super(el, renderer, differs, kvalDiffers, cdr); }
    /**
     * @param {?} value
     * @return {?}
     */
    set dataSource(value) {
        this._dataSource = value;
        /** @type {?} */
        const grid = jQuery(this._el).data(this._widgetName);
        if (grid) {
            jQuery(this._el)[this._widgetName]("option", "dataSource", this._dataSource);
        }
    }
    ;
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this._dataSource === null || this._dataSource === undefined) {
            this._dataSource = this.options["dataSource"];
        }
        if (!this.options["dataSource"] && this._dataSource) {
            this.options["dataSource"] = this._dataSource;
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this._columns && this._columns.length) {
            if (this.options) {
                this.options["columns"] = this._columns.map((/**
                 * @param {?} c
                 * @return {?}
                 */
                (c) => c._settings));
            }
        }
        if (this.featuresList) {
            if (this.options) {
                this.options["features"] = this.featuresList.allFeatures.map((/**
                 * @param {?} c
                 * @return {?}
                 */
                (c) => { return c.initSettings; }));
            }
        }
        if (this.options && this.options["features"] && !this.featuresList) {
            this.featuresList = new Features();
            //populate featuresList
            for (var i = 0; i < this.options["features"].length; i++) {
                /** @type {?} */
                var featureName = this.options["features"][i].name.charAt(0).toLowerCase() + this.options["features"][i].name.slice(1);
                this.featuresList.addFeature(featureName, this._el);
            }
        }
        super.ngOnInit();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    createDataSource(value) {
        return jQuery.extend(true, [], value);
    }
    /**
     * @param {?} id
     * @param {?} index
     * @return {?}
     */
    deleteRow(id, index) {
        /** @type {?} */
        var element = jQuery(this._el);
        /** @type {?} */
        var tr = element.find("tr[data-id='" + id + "']");
        if (tr.length > 0) {
            tr.remove();
            jQuery(this._el).data(this._widgetName).dataSource.deleteRow(id, true);
            jQuery(this._el).data(this._widgetName).dataSource._removeTransactionsByRecordId(id);
        }
        this._changes.splice(index, 1);
    }
    /**
     * @param {?} rowData
     * @param {?} index
     * @return {?}
     */
    addRow(rowData, index) {
        /** @type {?} */
        var grid;
        /** @type {?} */
        var pkKey = this["primaryKey"] || this.options["primaryKey"];
        /** @type {?} */
        var existingDomRow = jQuery(this._el).find("tr[data-id='" + rowData[pkKey] + "']");
        /** @type {?} */
        var widgetName = this._widgetName;
        /** @type {?} */
        var existingRow;
        /** @type {?} */
        var t;
        if (this._widgetName === "igHierarchicalGrid") {
            widgetName = "igGrid";
        }
        grid = jQuery(this._el).data(widgetName);
        if (existingDomRow.length === 0) {
            grid.renderNewRow(rowData, rowData[pkKey]);
        }
        existingRow = grid.dataSource.findRecordByKey(rowData[pkKey]);
        if (!existingRow) {
            // add the row without affecting the original DS (scope source) 
            // TODO: trigger rowAdded event?
            grid.dataSource._addRow(rowData, index);
            //add transaction
            t = grid.dataSource._createNewRowTransaction(rowData[pkKey], rowData);
            grid.dataSource._addTransaction(t);
            grid.dataSource._removeTransactionByTransactionId(t.tid);
        }
        this._changes.push(this.kvalDiffers.find({}).create());
    }
    /**
     * @param {?} rec
     * @param {?} currValue
     * @param {?} key
     * @return {?}
     */
    updateRow(rec, currValue, key) {
        /** @type {?} */
        const pkKey = this["primaryKey"] || this.options["primaryKey"];
        /** @type {?} */
        let widgetName = this._widgetName;
        if (this._widgetName === "igHierarchicalGrid") {
            widgetName = "igGrid";
        }
        /** @type {?} */
        const element = jQuery(this._el);
        /** @type {?} */
        const grid = element.data(widgetName);
        /** @type {?} */
        const tr = element.find("tr[data-id='" + rec[pkKey] + "']");
        /** @type {?} */
        const column = grid.columnByKey(key);
        /** @type {?} */
        let newFormattedVal;
        /** @type {?} */
        let td;
        if (column) {
            if (column.template) {
                newFormattedVal = grid._renderTemplatedCell(rec, column);
            }
            else {
                newFormattedVal = grid._renderCell(currValue, column, rec);
            }
            td = grid._getCellsByColKey(element.find("tr[data-id='" + rec[pkKey] + "']"), key);
            //if current cell is still in edit mode, exit it.
            if (jQuery(td).find("input.ui-igedit-input").length > 0) {
                element.data("igGridUpdating").endEdit();
            }
            jQuery(td).html(newFormattedVal);
            if (grid.options.localSchemaTransform) {
                rec = grid.dataSource.schema().transform([rec])[0];
            }
            grid.dataSource.updateRow(rec[pkKey], rec);
            grid.dataSource._commitTransactionsByRowId(rec[pkKey]);
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const ds = "dataSource";
        if (ds in changes) {
            /** @type {?} */
            const value = changes[ds].currentValue;
            if (value) {
                try {
                    this._differ = this._differs.find(value).create();
                    this._changes = [];
                    for (var i = 0; i < this._dataSource.length; i++) {
                        this._changes.push(this.kvalDiffers.find({}).create());
                    }
                }
                catch (e) {
                    throw new Error("Only binding to arrays is supported.");
                }
            }
        }
        super.ngOnChanges(changes);
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this._differ) {
            /** @type {?} */
            const changes = this._differ.diff(this._dataSource);
            //check if grid is initialized
            /** @type {?} */
            const grid = jQuery(this._el).data(this._widgetName);
            if (changes && grid) {
                this.dataSourceApplyChanges(changes);
            }
            if (changes && changes.isDirty && grid) {
                //data source has been changed post initialization.
                jQuery(this._el)[this._widgetName]("option", "dataSource", this._dataSource);
            }
            if (this._changes && grid) {
                /** @type {?} */
                const pkKey = this["primaryKey"] || this.options["primaryKey"];
                //check recs
                for (var i = 0; i < this._dataSource.length; i++) {
                    /** @type {?} */
                    var item = this._dataSource[i];
                    /** @type {?} */
                    var rowChanges = this._changes[i].diff(item);
                    if (rowChanges) {
                        rowChanges.forEachChangedItem((/**
                         * @param {?} change
                         * @return {?}
                         */
                        (change) => {
                            this.updateRow(item, change.currentValue, change.key);
                        }));
                    }
                }
            }
        }
        super.ngDoCheck();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    dataSourceApplyChanges(changes) {
        /** @type {?} */
        const pkKey = this["primaryKey"] || this.options["primaryKey"];
        changes.forEachAddedItem((/**
         * @param {?} r
         * @return {?}
         */
        r => this.addRow(r.item, r.currentIndex)));
        changes.forEachRemovedItem((/**
         * @param {?} r
         * @return {?}
         */
        r => { this.deleteRow(r.item[pkKey], r.previousIndex); }));
    }
    /**
     * @return {?}
     */
    allRows() { }
    ;
}
IgGridBase.propDecorators = {
    dataSource: [{ type: Input }],
    _columns: [{ type: ContentChildren, args: [Column,] }],
    featuresList: [{ type: ContentChild, args: [Features, { static: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgGridComponent extends IgGridBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiff
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiff, cdr) { super(el, renderer, differs, kvalDiff, cdr); }
    /**
     * Returns the element holding the data records
     * @return {?}
     */
    /* istanbul ignore next */
    widget() { return; }
    ;
    /**
     * Returns whether grid has non-data fixed columns(e.g. row selectors column)
     * @return {?}
     */
    /* istanbul ignore next */
    hasFixedDataSkippedColumns() { return; }
    ;
    /**
     * Returns true if grid has at least one fixed columns(even if a non-data column - like row-selectors column)
     * @return {?}
     */
    /* istanbul ignore next */
    hasFixedColumns() { return; }
    ;
    /**
     * Returns the current fixing direction. NOTE - use only if ColumnFixing feature is enabled
     * @return {?} left|right
     */
    /* istanbul ignore next */
    fixingDirection() { return; }
    ;
    /**
     * Returns whether the column with identifier colKey is fixed
     *
     * @param {?} colKey     An identifier of the column which should be checked. It can be a key or visible index.
     * @return {?}
     */
    /* istanbul ignore next */
    isFixedColumn(colKey) { return; }
    ;
    /**
     * Called to detect whether grid container is resized. When autoAdjustHeight is true and height of the grid is changed then the height of grid is re-set.
     * @return {?}
     */
    /* istanbul ignore next */
    resizeContainer() { return; }
    ;
    /**
     * Returns whether the header identified by colKey is multicolumn header(has children)
     *
     * @param {?} colKey     value of the column key
     * @return {?}
     */
    /* istanbul ignore next */
    isGroupHeader(colKey) { return; }
    ;
    /**
     * Returns an object that contains information on the passed Dom element
     *
     * 				rowId - the id of the record associated with the element - if primaryKey is not set this will be null.
     * 				rowIndex - the index (in the DOM) of the row associated with the element.
     * 				recordIndex - index of the data record associated with this element in the current dataView.
     * 				columnObject  - the column object associated with this element ( if the element is tr this will be null)
     *
     * @param {?} elem    The Dom element or jQuery object which can be a TD or TR element from the grid.
     * @return {?}
     */
    /* istanbul ignore next */
    getElementInfo(elem) { return; }
    ;
    /**
     * Returns the ID of the TABLE element where data records are rendered
     * @return {?}
     */
    /* istanbul ignore next */
    id() { return; }
    ;
    /**
     * Returns the DIV that is the topmost container of the grid widget
     * @return {?}
     */
    /* istanbul ignore next */
    container() { return; }
    ;
    /**
     * Returns the table that contains the header cells
     * @return {?}
     */
    /* istanbul ignore next */
    headersTable() { return; }
    ;
    /**
     * Returns the table that contains the footer cells
     * @return {?}
     */
    /* istanbul ignore next */
    footersTable() { return; }
    ;
    /**
     * Returns the DIV that is used as a scroll container for the grid contents
     * @return {?}
     */
    /* istanbul ignore next */
    scrollContainer() { return; }
    ;
    /**
     * Returns the DIV that is the topmost container of the fixed grid - contains fixed columns(in ColumnFixing scenario)
     * @return {?}
     */
    /* istanbul ignore next */
    fixedContainer() { return; }
    ;
    /**
     * Returns the DIV that is the topmost container of the fixed body grid - contains fixed columns(in ColumnFixing scenario)
     * @return {?}
     */
    /* istanbul ignore next */
    fixedBodyContainer() { return; }
    ;
    /**
     * Returns container(jQuery representation) containing fixed footer - contains fixed columns(in ColumnFixing scenario)
     * @return {?}
     */
    /* istanbul ignore next */
    fixedFooterContainer() { return; }
    ;
    /**
     * Returns container(jQuery representation) containing fixed header - contains fixed columns(in ColumnFixing scenario)
     * @return {?}
     */
    /* istanbul ignore next */
    fixedHeaderContainer() { return; }
    ;
    /**
     * Returns the table that contains the FIXED header cells - contains fixed columns(in ColumnFixing scenario)
     * @return {?}
     */
    /* istanbul ignore next */
    fixedHeadersTable() { return; }
    ;
    /**
     * Returns the table that contains the footer cells - contains fixed columns(in ColumnFixing scenario)
     * @return {?}
     */
    /* istanbul ignore next */
    fixedFootersTable() { return; }
    ;
    /**
     * Returns the cell TD element at the specified location
     *
     * @param {?} x     The column index.
     * @param {?} y     The row index.
     * @param {?} isFixed     Optional parameter - if true get cell TD at the specified location from the fixed table
     * @return {?}
     */
    /* istanbul ignore next */
    cellAt(x, y, isFixed) { return; }
    ;
    /**
     * Returns the cell TD element by row id and column key
     *
     * @param {?} rowId     The id of the row.
     * @param {?} columnKey     The column key.
     * @return {?}
     */
    /* istanbul ignore next */
    cellById(rowId, columnKey) { return; }
    ;
    /**
     * Returns the fixed table - contains fixed columns(in ColumnFixing scenario). If there aren't fixed columns returns the grid table
     * @return {?}
     */
    /* istanbul ignore next */
    fixedTable() { return; }
    ;
    /**
     * Gets all immediate children of the current grid
     * @return {?}
     */
    /* istanbul ignore next */
    immediateChildrenWidgets() { return; }
    ;
    /**
     * Gets all children of the current grid, recursively
     * @return {?}
     */
    /* istanbul ignore next */
    childrenWidgets() { return; }
    ;
    /**
     * Gets all children's elements of the current grid, recursively
     * @return {?}
     */
    /* istanbul ignore next */
    children() { return; }
    ;
    /**
     * Gets all immediate children's elements of the current grid
     * @return {?}
     */
    /* istanbul ignore next */
    immediateChildren() { return; }
    ;
    /**
     * Returns the row (TR element) at the specified index. jQuery selectors aren't used for performance reasons
     *
     * @param {?} i     The row index.
     * @return {?}
     */
    /* istanbul ignore next */
    rowAt(i) { return; }
    ;
    /**
     * Returns the row TR element by row id
     *
     * @param {?} rowId     The id of the row.
     * @param {?=} isFixed     Specify search in the fixed container.
     * @return {?}
     */
    /* istanbul ignore next */
    rowById(rowId, isFixed) { return; }
    ;
    /**
     * Returns the fixed row (TR element) at the specified index. jQuery selectors aren't used for performance reasons(in ColumnFixing scenario - only when there is at least one fixed column)
     *
     * @param {?} i     The row index.
     * @return {?}
     */
    /* istanbul ignore next */
    fixedRowAt(i) { return; }
    ;
    /**
     * Returns a list of all fixed TR elements holding data in the grid(in ColumnFixing scenario - only when there is at least one fixed column)
     * @return {?}
     */
    /* istanbul ignore next */
    fixedRows() { return; }
    ;
    /**
     * Returns a list of all TR elements holding data in the grid(when there is at least one fixed column returns rows only in the UNFIXED table)
     * @return {?}
     */
    /* istanbul ignore next */
    rows() { return; }
    ;
    /**
     * Returns all data fixed rows recursively, not only the immediate ones(in ColumnFixing scenario - only when there is at least one fixed column)
     * @return {?}
     */
    /* istanbul ignore next */
    allFixedRows() { return; }
    ;
    /**
     * Returns all data rows recursively, not only the immediate ones(when there is at least one fixed column returns rows only in the UNFIXED table)
     * @return {?}
     */
    /* istanbul ignore next */
    allRows() { return; }
    ;
    /**
     * Returns a column object by the specified column key
     *
     * @param {?} key     The column key.
     * @return {?}
     */
    /* istanbul ignore next */
    columnByKey(key) { return; }
    ;
    /**
     * Returns a column object by the specified header text. If there are multiple matches, returns the first one.
     *
     * @param {?} text     The column header text.
     * @return {?}
     */
    /* istanbul ignore next */
    columnByText(text) { return; }
    ;
    /**
     * Returns an array of selected cells in arbitrary order where every objects has the format { element: , row: , index: , rowIndex: , columnKey: } .
     * 				If multiple selection is disabled the function will return null.
     * @return {?}
     */
    /* istanbul ignore next */
    selectedCells() { return; }
    ;
    /**
     * Returns an array of selected rows in arbitrary order where every object has the format { element: , index: } .
     * 				If multiple selection is disabled the function will return null.
     * @return {?}
     */
    /* istanbul ignore next */
    selectedRows() { return; }
    ;
    /**
     * Returns the currently selected cell that has the format { element: , row: , index: , rowIndex: , columnKey: }, if any.
     * 				If multiple selection is enabled the function will return null.
     * @return {?}
     */
    /* istanbul ignore next */
    selectedCell() { return; }
    ;
    /**
     * Returns the currently selected row that has the format { element: , index: }, if any.
     * 				If multiple selection is enabled the function will return null.
     * @return {?}
     */
    /* istanbul ignore next */
    selectedRow() { return; }
    ;
    /**
     * Returns the currently active (focused) cell that has the format { element: , row: , index: , rowIndex: , columnKey: }, if any.
     * @return {?}
     */
    /* istanbul ignore next */
    activeCell() { return; }
    ;
    /**
     * Returns the currently active (focused) row that has the format { element: , index: }, if any.
     * @return {?}
     */
    /* istanbul ignore next */
    activeRow() { return; }
    ;
    /**
     * Retrieves a cell value using the row index and the column key. If a primaryKey is defined, rowId is assumed to be the row Key (not index).
     * 				If primary key is not defined, then rowId is converted to a number and is used as a row index.
     *
     * @param {?} rowId     Row index or row key (primary key).
     * @param {?} colKey     The column key.
     * @return {?}
     */
    /* istanbul ignore next */
    getCellValue(rowId, colKey) { return; }
    ;
    /**
     * Returns the cell text. If colKey is a number, the index of the column is used (instead of a column name)- does not apply when using a Multi-Row Layout grid.
     * 				This is the actual text (or HTML string) for the contents of the cell.
     *
     * @param {?} rowId     Row index or row data key (primary key)
     * @param {?} colKey     Column key.
     * @return {?}
     */
    /* istanbul ignore next */
    getCellText(rowId, colKey) { return; }
    ;
    /**
     * Sets a new template for a column after initialization and renders the grid if not explicitly disabled. This method will replace any existing explicitly set row template and will build one anew from the column ones.
     *
     * @param {?} col     An identifier of the column to set template for (index or key)
     * @param {?} tmpl     The column template to set
     * @param {?=} render     Should the grid rerender after template is set
     * @return {?}
     */
    /* istanbul ignore next */
    setColumnTemplate(col, tmpl, render) { return; }
    ;
    /**
     * Commits all pending transactions to the client data source. Note that there won't be anything to commit on the UI, since it is updated instantly. In order to rollback the actual UI, a call to dataBind() is required.
     *
     * @param {?=} rowId     If specified, will commit only that transaction corresponding to the specified record key.
     * @return {?}
     */
    /* istanbul ignore next */
    commit(rowId) { return; }
    ;
    /**
     * Clears the transaction log (delegates to igDataSource). Note that this does not update the UI. In case the UI must be updated, set the second parameter "updateUI" to true, which will trigger a call to dataBind() to re-render the contents.
     *
     * @param {?=} rowId     If specified, will only rollback the transactions with that row id.
     * @param {?=} updateUI     Whether to update the UI or not.
     * @return {?}
     */
    /* istanbul ignore next */
    rollback(rowId, updateUI) { return; }
    ;
    /**
     * Returns a record by a specified key (requires that primaryKey is set in the settings).
     * 				That is a wrapper for this.dataSource.findRecordByKey(key).
     *
     * @param {?} key     Primary key of the record
     * @return {?}
     */
    /* istanbul ignore next */
    findRecordByKey(key) { return; }
    ;
    /**
     * Returns a standalone object (copy) that represents the committed transactions, but detached from the data source.
     * 				That is a wrapper for this.dataSource.getDetachedRecord(t).
     *
     * @param {?} t     A transaction object.
     * @return {?}
     */
    /* istanbul ignore next */
    getDetachedRecord(t) { return; }
    ;
    /**
     * Returns a list of all transaction objects that are pending to be committed or rolled back to the data source.
     * 				That is a wrapper for this.dataSource.pendingTransactions().
     * @return {?}
     */
    /* istanbul ignore next */
    pendingTransactions() { return; }
    ;
    /**
     * Returns a list of all transaction objects that are either pending, or have been committed in the data source.
     * 				That is a wrapper for this.dataSource.allTransactions().
     * @return {?}
     */
    /* istanbul ignore next */
    allTransactions() { return; }
    ;
    /**
     * Returns the accumulated transaction log as a string. The purpose of this is to be passed to URLs or used conveniently.
     * 				That is a wrapper for this.dataSource.transactionsAsString().
     * @return {?}
     */
    /* istanbul ignore next */
    transactionsAsString() { return; }
    ;
    /**
     * Invokes an AJAX request to the updateUrl option (if specified) and passes the serialized transaction log (a serialized JSON string) as part of the POST request.
     *
     * @param {?} success    Specifies a custom function to be called when AJAX request to the updateUrl option succeeds(optional)
     * @param {?} error    Specifies a custom function to be called when AJAX request to the updateUrl option fails(optional)
     * @return {?}
     */
    /* istanbul ignore next */
    saveChanges(success, error) { return; }
    ;
    /**
     * Adds a new row (TR) to the grid, by taking a data row object. Assumes the record will have the primary key.
     *
     * @param {?=} rec     Identifier/key of row. If missing, then number of rows in grid is used.
     * @return {?}
     */
    /* istanbul ignore next */
    renderNewRow(rec) { return; }
    ;
    /**
     * If the data source points to a local JSON array of data, and it is necessary to reset it at runtime, it must be done through this API member instead of the options (options.dataSource)
     *
     * @param {?} dataSource     New data source object.
     * @return {?}
     */
    /* istanbul ignore next */
    dataSourceObject(dataSource) { return; }
    ;
    /**
     * Returns the total number of records in the underlying backend. If paging or filtering is enabled, this may differ from the number of records in the client-side data source.
     * 				In order for this to work, the response JSON/XML must include a property that specifies the total number of records, which name is specified by options.responseTotalRecCountKey.
     * 				This functionality is completely delegated to the data source control.
     * @return {?}
     */
    /* istanbul ignore next */
    totalRecordsCount() { return; }
    ;
    /**
     * Causes the grid to data bind to the data source (local or remote) , and re-render all of the data as well
     *
     * @param {?} internal
     * @return {?}
     */
    /* istanbul ignore next */
    dataBind(internal) { return; }
    ;
    /**
     * Moves a visible column at a specified place, in front or behind a target column or at a target index
     * 			Note: This method is asynchronous which means that it returns immediately and any subsequent code will execute in parallel. This may lead to runtime errors. To avoid them put the subsequent code in the callback parameter provided by the method.
     *
     * @param {?} column    An identifier of the column to be moved. It can be a key, a Multi-Column Header identificator, or an index in a number format. The latter is not supported when the grid contains multi-column headers.
     * @param {?} target    An identifier of a column where the moved column should move to or an index at which the moved column should be moved to. In the case of a column identifier the column will be moved after it by default.
     * @param {?=} after    Specifies whether the column moved should be moved after or before the target column. This parameter is disregarded if there is no target column specified but a target index is used.
     * @param {?=} inDom    Specifies whether the column moving will be enacted through DOM manipulation or through rerendering of the grid.
     * @param {?=} callback    Specifies a custom function to be called when the column is moved.
     * @return {?}
     */
    /* istanbul ignore next */
    moveColumn(column, target, after, inDom, callback) { return; }
    ;
    /**
     * Shows a hidden column. If the column is not hidden the method does nothing.
     * 				Note: This method is asynchronous which means that it returns immediately and any subsequent code will execute in parallel. This may lead to runtime errors. To avoid them put the subsequent code in the callback parameter provided by the method.
     *
     * @param {?} column     An identifier for the column. If a number is provided it will be used as a column index. If a string is provided it will be used as a column key.
     * @param {?} callback     Specifies a custom function to be called when the column is shown(optional)
     * @return {?}
     */
    /* istanbul ignore next */
    showColumn(column, callback) { return; }
    ;
    /**
     * Hides a visible column. If the column is hidden the method does nothing.
     * 				Note: This method is asynchronous which means that it returns immediately and any subsequent code will execute in parallel. This may lead to runtime errors. To avoid them put the subsequent code in the callback parameter provided by the method.
     *
     * @param {?} column     An identifier for the column. If a number is provided it will be used as a column index else if a string is provided it will be used as a column key.
     * @param {?} callback     Specifies a custom function to be called when the column is hidden(optional)
     * @return {?}
     */
    /* istanbul ignore next */
    hideColumn(column, callback) { return; }
    ;
    /**
     * Gets unbound values for the specified column key. If key is not specified returns all unboundvalues
     *
     * @param {?} key     column key
     * @return {?}
     */
    /* istanbul ignore next */
    getUnboundValues(key) { return; }
    ;
    /**
     * Sets unbound values for the unbound column with the specified key. If removeOldValues is true then values(if any) for the unbound columns are re-set with the new values
     *
     * @param {?} key     key of the unbound column
     * @param {?} values     array of values to be set on unbound values
     * @param {?} removeOldValues     if true removes current unbound values(if any) for the specified column and apply the new ones specified in parameter values. Otherwise merge current values with the specified in parameter values
     * @return {?}
     */
    /* istanbul ignore next */
    setUnboundValues(key, values, removeOldValues) { return; }
    ;
    /**
     * Sets unbound value for the unbound cell by the specified column key and row primary key.
     *
     * @param {?} col     key of the unbound column
     * @param {?} rowId     primary key value of the row
     * @param {?} val     value to be set on unbound cell
     * @param {?} notToRender     if false will re-render the row
     * @return {?}
     */
    /* istanbul ignore next */
    setUnboundValueByPK(col, rowId, val, notToRender) { return; }
    ;
    /**
     * Returns an unbound column with the specified key. If not found returns null
     *
     * @param {?} key    a column key
     * @return {?}
     */
    /* istanbul ignore next */
    getUnboundColumnByKey(key) { return; }
    ;
    /**
     * Returns whether there is vertical scrollbar. Because of perfrormance issues in older Internet Explorer especially 8,9 - there is no need to check if height is not set - there is no scrollbar OR if row virtualization is enabled - it is supposed there is vertical scrollbar
     * @return {?}
     */
    /* istanbul ignore next */
    hasVerticalScrollbar() { return; }
    ;
    /**
     * Auto resize columns that have property width set to "*" so content to be auto-fitted(not shrinked/cutted). Auto-resizing is applied ONLY for visible columns
     * @return {?}
     */
    /* istanbul ignore next */
    autoSizeColumns() { return; }
    ;
    /**
     * Calculates the width of the column so its content to be auto-fitted to the width of the data in it(the content should NOT be shrinked/cutted)
     *
     * @param {?} columnIndex    Visible column index
     * @return {?}
     */
    /* istanbul ignore next */
    calculateAutoFitColumnWidth(columnIndex) { return; }
    ;
    /**
     * Get visible index by specified column key. If column is not found or is hidden then returns -1.
     * 				Note: Method does not count column groups (Multi-Column Headers).
     *
     * @param {?} columnKey     columnKey
     * @param {?} includeDataSkip     Optional parameter - if set to true include non data columns(like expander column, row selectors column, etc.) in calculations
     * @return {?}
     */
    /* istanbul ignore next */
    getVisibleIndexByKey(columnKey, includeDataSkip) { return; }
    ;
    /**
     * When called the method re-renders the whole grid(also rebinds to the data source) and renders the cols object
     *
     * @param {?} cols an array of column objects
     * @return {?}
     */
    /* istanbul ignore next */
    renderMultiColumnHeader(cols) { return; }
    ;
    /**
     * Scroll to the specified row or specified position(in pixels)
     *
     * @param {?} scrollerPosition     An identifier of the vertical scroll position. When it is string then it is interpreted as pixels otherwise it is the row number
     * @return {?}
     */
    /* istanbul ignore next */
    virtualScrollTo(scrollerPosition) { return; }
    ;
    /**
     * Returns column object and visible index for the table cell(TD) which is passed as argument
     *
     * @param {?} $td     cell(TD) - either DOM TD element or jQuery object
     * @return {?}
     */
    /* istanbul ignore next */
    getColumnByTD($td) { return; }
    ;
    /**
     * Destroy is part of the jQuery UI widget API and does the following:
     * 				1. Remove custom CSS classes that were added.
     * 				2. Unwrap any wrapping elements such as scrolling divs and other containers.
     * 				3. Unbind all events that were bound.
     *
     * @param {?} notToCallDestroy
     * @return {?}
     */
    /* istanbul ignore next */
    destroy(notToCallDestroy) { return; }
    ;
}
IgGridComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                "selector": "ig-grid",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "width", "height", "autoAdjustHeight", "avgRowHeight", "avgColumnWidth", "defaultColumnWidth", "autoGenerateColumns", "virtualization", "virtualizationMode", "requiresDataBinding", "rowVirtualization", "columnVirtualization", "virtualizationMouseWheelStep", "adjustVirtualHeights", "templatingEngine", "columns", "dataSource", "dataSourceUrl", "dataSourceType", "responseDataKey", "responseTotalRecCountKey", "requestType", "responseContentType", "showHeader", "showFooter", "fixedHeaders", "fixedFooters", "caption", "features", "tabIndex", "localSchemaTransform", "primaryKey", "serializeTransactionLog", "autoCommit", "aggregateTransactions", "autoFormat", "renderCheckboxes", "updateUrl", "restSettings", "alternateRowStyles", "autofitLastColumn", "enableHoverStyles", "enableUTCDates", "mergeUnboundColumns", "jsonpRequest", "enableResizeContainerCheck", "featureChooserIconDisplay", "scrollSettings"],
                outputs: ["cellClick", "cellRightClick", "dataBinding", "dataBound", "rendering", "rendered", "dataRendering", "dataRendered", "headerRendering", "headerRendered", "footerRendering", "footerRendered", "headerCellRendered", "rowsRendering", "rowsRendered", "schemaGenerated", "columnsCollectionModified", "requestError", "created", "destroyed"]
            }] }
];
/** @nocollapse */
IgGridComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgTreeGridComponent extends IgGridBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiffers, cdr) { super(el, renderer, differs, kvalDiffers, cdr); }
    /**
     * @param {?} id
     * @return {?}
     */
    deleteRow(id) {
        /** @type {?} */
        var element = jQuery(this._el);
        /** @type {?} */
        var tr = element.find("tr[data-id='" + id + "']");
        /** @type {?} */
        var dataLevel = tr.attr("aria-level");
        if (tr.length > 0) {
            element.data(this._widgetName).dataSource.deleteRow(id, true);
            element.data(this._widgetName).dataSource._removeTransactionsByRecordId(id);
            /** @type {?} */
            var trs = tr.nextUntil("tr[data-level=" + dataLevel + "]");
            if (trs.length === 0) {
                trs = tr.nextAll("tr[data-level]");
            }
            tr.remove();
            trs.remove();
        }
    }
    /**
     * @param {?} rec
     * @param {?} currValue
     * @param {?} key
     * @return {?}
     */
    updateRow(rec, currValue, key) {
        /** @type {?} */
        const element = jQuery(this._el);
        /** @type {?} */
        const grid = element.data(this._widgetName);
        /** @type {?} */
        const childDataKey = this["childDataKey"] || this.options.childDataKey;
        /** @type {?} */
        const column = element.data(this._widgetName).columnByKey(key);
        if (!column && key === childDataKey) {
            //we have an hierarchical data source and one of the nested collections has changed.
            grid.dataBind();
        }
        else {
            super.updateRow(rec, currValue, key);
        }
    }
    /**
     * @return {?}
     */
    markForCheck() {
        super.markForCheck();
        /** @type {?} */
        const childDataKey = this["childDataKey"] || this.options.childDataKey;
        if (childDataKey) {
            this.dataBind();
        }
    }
    /**
     * Clears the transaction log (delegates to igDataSource). Note that this does not update the UI. In case the UI must be updated, set the second parameter "updateUI" to true, which will trigger a call to dataBind() to re-render the contents.
     *
     * @param {?=} rowId     If specified, will only rollback the transactions with that row id.
     * @param {?=} updateUI     Whether to update the UI or not.
     * @return {?}
     */
    /* istanbul ignore next */
    rollback(rowId, updateUI) { return; }
    ;
    /**
     * Causes the treegrid to data bind to the data source (local or remote) , and re-render all of the data
     * @return {?}
     */
    /* istanbul ignore next */
    dataBind() { return; }
    ;
    /**
     * Toggle row by specified row or row identifier
     *
     * @param {?} row     jQuery table row object or a row id.
     * @param {?=} callback     Specifies a custom function to be called when row is expanded/collapsed. The callback has 4 arguments- a reference to the current context(this), object that holds 2 properties(unfixedRow - DOM representation of the unfixed row, fixedRow - DOM representation of the fixed row, if there is no fixed columns it is undefined), reference to the dataRecord, expand - specifies whether row is expanded
     * @return {?}
     */
    /* istanbul ignore next */
    toggleRow(row, callback) { return; }
    ;
    /**
     * Expands a parent row by specified row or row identifier
     *
     * @param {?} row     jQuery table row object or a row id.
     * @param {?=} callback     Specifies a custom function to be called when row is expanded/collapsed. The callback has 4 arguments- a reference to the current context(this), object that holds 2 properties(unfixedRow - DOM representation of the unfixed row, fixedRow - DOM representation of the fixed row, if there is no fixed columns it is undefined), reference to the dataRecord, expand - specifies whether row is expanded
     * @return {?}
     */
    /* istanbul ignore next */
    expandRow(row, callback) { return; }
    ;
    /**
     * Collapses a parent row by specified row or row identifier
     *
     * @param {?} row     jQuery table row object, raw DOM row object or a row id.
     * @param {?=} callback     Specifies a custom function to be called when row is expanded/collapsed. The callback has 4 arguments- a reference to the current context(this), object that holds 2 properties(unfixedRow - DOM representation of the unfixed row, fixedRow - DOM representation of the fixed row, if there is no fixed columns it is undefined), reference to the dataRecord, expand - specifies whether row is expanded
     * @return {?}
     */
    /* istanbul ignore next */
    collapseRow(row, callback) { return; }
    ;
    /**
     * Adds a new row (TR) to the grid as a child of a specific row, by taking a data row object. Assumes the record will have the primary key.
     *
     * @param {?} rec     The data row JavaScript object.
     * @param {?=} parentId     Identifier/key of the targeted parent row. If missing, then the new row is rendered to the bottom of the grid.
     * @return {?}
     */
    /* istanbul ignore next */
    renderNewChild(rec, parentId) { return; }
    ;
    /**
     * Destroys igTreeGrid
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
}
IgTreeGridComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-tree-grid",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "width", "height", "autoAdjustHeight", "avgRowHeight", "avgColumnWidth", "defaultColumnWidth", "autoGenerateColumns", "virtualization", "virtualizationMode", "requiresDataBinding", "rowVirtualization", "columnVirtualization", "virtualizationMouseWheelStep", "adjustVirtualHeights", "templatingEngine", "columns", "dataSource", "dataSourceUrl", "dataSourceType", "responseDataKey", "responseTotalRecCountKey", "requestType", "responseContentType", "showHeader", "showFooter", "fixedHeaders", "fixedFooters", "caption", "features", "tabIndex", "localSchemaTransform", "primaryKey", "serializeTransactionLog", "autoCommit", "aggregateTransactions", "autoFormat", "renderCheckboxes", "updateUrl", "restSettings", "alternateRowStyles", "autofitLastColumn", "enableHoverStyles", "enableUTCDates", "mergeUnboundColumns", "jsonpRequest", "enableResizeContainerCheck", "featureChooserIconDisplay", "scrollSettings", "indentation", "initialIndentationLevel", "showExpansionIndicator", "expandTooltipText", "collapseTooltipText", "foreignKey", "initialExpandDepth", "foreignKeyRootValue", "renderExpansionIndicatorColumn", "renderFirstDataCellFunction", "childDataKey", "renderExpansionCellFunction", "enableRemoteLoadOnDemand", "dataSourceSettings"],
                outputs: ["cellClick", "cellRightClick", "dataBinding", "dataBound", "rendering", "rendered", "dataRendering", "dataRendered", "headerRendering", "headerRendered", "footerRendering", "footerRendered", "headerCellRendered", "rowsRendering", "rowsRendered", "schemaGenerated", "columnsCollectionModified", "requestError", "created", "destroyed", "rowExpanding", "rowExpanded", "rowCollapsing", "rowCollapsed"]
            }] }
];
/** @nocollapse */
IgTreeGridComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgHierarchicalGridComponent extends IgGridBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiffers, cdr) { super(el, renderer, differs, kvalDiffers, cdr); }
    /**
     * @param {?} id
     * @return {?}
     */
    deleteRow(id) {
        /** @type {?} */
        var element = jQuery(this._el);
        /** @type {?} */
        var tr = element.find("tr[data-id='" + id + "']");
        /** @type {?} */
        var childContainer = tr.next("tr[data-container]");
        if (tr.length > 0) {
            tr.remove();
            childContainer.remove();
            element.data("igGrid").dataSource.deleteRow(id, true);
            element.data("igGrid").dataSource._removeTransactionsByRecordId(id);
        }
    }
    /**
     * @param {?} rec
     * @param {?} currValue
     * @param {?} key
     * @return {?}
     */
    updateRow(rec, currValue, key) {
        /** @type {?} */
        const element = jQuery(this._el);
        /** @type {?} */
        const childrenDataProperty = this["childrenDataProperty"] || this.options.childrenDataProperty;
        /** @type {?} */
        var childGrid = element.data(this._widgetName).allChildrenWidgets().filter((/**
         * @param {?} indx
         * @return {?}
         */
        function (indx) {
            /** @type {?} */
            var parentRow = jQuery(this.element).closest('tr[data-container]').prev();
            /** @type {?} */
            var parentGridPK = parentRow.closest(".ui-iggrid-table").data("igGrid").options.primaryKey;
            return (childrenDataProperty === key ||
                parentRow.next("[data-container]").find("table[role='grid']").attr("id").contains("_" + key + "_"))
                && parentRow.attr("data-id") == rec[parentGridPK];
        }));
        if (childGrid.length > 0) {
            jQuery(childGrid).each((/**
             * @return {?}
             */
            function () {
                this.dataBind();
            }));
        }
        else {
            super.updateRow(rec, currValue, key);
        }
    }
    /**
     * @return {?}
     */
    markForCheck() {
        super.markForCheck();
        /** @type {?} */
        const element = jQuery(this._el);
        /** @type {?} */
        const childrenDataProperty = this["childrenDataProperty"] || this.options.childrenDataProperty;
        /** @type {?} */
        var childGrids = element.data(this._widgetName).allChildrenWidgets();
        for (var i = 0; i < childGrids.length; i++) {
            childGrids[i].dataBind();
        }
    }
    /**
     * Data binds the hierarchical grid. No child grids will be created or rendered by default, unless there is initialExpandDepth >= 0 set.
     * @return {?}
     */
    /* istanbul ignore next */
    dataBind() { return; }
    ;
    /**
     * Returns the element of the root grid (igGrid)
     * @return {?}
     */
    /* istanbul ignore next */
    root() { return; }
    ;
    /**
     * Returns the widget object of the root grid (igGrid)
     * @return {?}
     */
    /* istanbul ignore next */
    rootWidget() { return; }
    ;
    /**
     * Returns a flat list of all child grid elements (recursive)
     * @return {?}
     */
    /* istanbul ignore next */
    allChildren() { return; }
    ;
    /**
     * Expands or collapses (toggles) a parent row
     * 				Note: This method is asynchronous which means that it returns immediately and any subsequent code will execute in parallel. This may lead to runtime errors. To avoid them put the subsequent code in the callback parameter provided by the method.
     *
     * @param {?} element     accepts a dom element, or a jquery wrapped dom element that should be a TR and should specify a parent row
     * @param {?=} callback     Specifies a custom function to be called when parent row is toggled(optional). Takes 2 arguments - first is hierarchical grid object, second is the row element that was toggled
     * @return {?}
     */
    /* istanbul ignore next */
    toggle(element, callback) { return; }
    ;
    /**
     * Expands (toggles) a parent row
     * 				Note: This method is asynchronous which means that it returns immediately and any subsequent code will execute in parallel. This may lead to runtime errors. To avoid them put the subsequent code in the callback parameter provided by the method.
     *
     * @param {?} id     accepts a dom element, or a jquery wrapped dom element that should be a TR and should specify a parent row
     * @param {?=} callback     Specifies a custom function to be called when parent row is expanded(optional). Takes 2 arguments first is hierarchical grid object, second is the row element that was expanded
     * @return {?}
     */
    /* istanbul ignore next */
    expand(id, callback) { return; }
    ;
    /**
     * Collapses a parent row
     * 				Note: This method is asynchronous which means that it returns immediately and any subsequent code will execute in parallel. This may lead to runtime errors. To avoid them put the subsequent code in the callback parameter provided by the method.
     *
     * @param {?} id     accepts a dom element, or a jquery wrapped dom element that should be a TR and should specify a parent row
     * @param {?=} callback     Specifies a custom function to be called when parent row is expanded(optional). Takes 2 arguments - first is hierarchical grid object, second is the row element that was collapsed
     * @return {?}
     */
    /* istanbul ignore next */
    collapse(id, callback) { return; }
    ;
    /**
     * Checks if a parent row is currently collapsed
     *
     * @param {?} element     accepts a dom element, or a jquery wrapped dom element that should be a TR and should specify a parent row
     * @return {?}
     */
    /* istanbul ignore next */
    collapsed(element) { return; }
    ;
    /**
     * Checks if a parent row is populated with data
     *
     * @param {?} element     accepts a dom element, or a jquery wrapped dom element that should be a TR and should specify a parent row
     * @return {?}
     */
    /* istanbul ignore next */
    populated(element) { return; }
    ;
    /**
     * Commits pending transactions to the client data source for main and all child grids.
     * @return {?}
     */
    /* istanbul ignore next */
    commit() { return; }
    ;
    /**
     * Clears the transaction log (delegates to igDataSource). Note that this does not update the UI. In case the UI must be updated, set the second parameter "updateUI" to true, which will trigger a call to dataBind() to re-render the contents.
     *
     * @param {?=} rebind     Whether to perform a rebind.
     * @return {?}
     */
    /* istanbul ignore next */
    rollback(rebind) { return; }
    ;
    /**
     * Posts to the settings.updateUrl using $.ajax, by serializing the changes as url params
     *
     * @param {?} success    Specifies a custom function to be called when AJAX request to the updateUrl option succeeds(optional)
     * @param {?} error    Specifies a custom function to be called when AJAX request to the updateUrl option fails(optional)
     * @return {?}
     */
    /* istanbul ignore next */
    saveChanges(success, error) { return; }
    ;
    /**
     * Destroys the hierarchical grid by recursively destroying all child grids
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
}
IgHierarchicalGridComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: "ig-hierarchical-grid",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "initialDataBindDepth", "initialExpandDepth", "odata", "rest", "maxDataBindDepth", "defaultChildrenDataProperty", "autoGenerateLayouts", "expandCollapseAnimations", "expandColWidth", "pathSeparator", "animationDuration", "expandTooltip", "collapseTooltip", "columnLayouts", "width", "height", "autoAdjustHeight", "avgRowHeight", "avgColumnWidth", "defaultColumnWidth", "autoGenerateColumns", "virtualization", "virtualizationMode", "requiresDataBinding", "rowVirtualization", "columnVirtualization", "virtualizationMouseWheelStep", "adjustVirtualHeights", "templatingEngine", "columns", "dataSource", "dataSourceUrl", "dataSourceType", "responseDataKey", "responseTotalRecCountKey", "requestType", "responseContentType", "showHeader", "showFooter", "fixedHeaders", "fixedFooters", "caption", "features", "tabIndex", "localSchemaTransform", "primaryKey", "serializeTransactionLog", "autoCommit", "aggregateTransactions", "autoFormat", "renderCheckboxes", "updateUrl", "restSettings", "alternateRowStyles", "autofitLastColumn", "enableHoverStyles", "enableUTCDates", "mergeUnboundColumns", "jsonpRequest", "enableResizeContainerCheck", "featureChooserIconDisplay", "scrollSettings"],
                outputs: ["rowExpanding", "rowExpanded", "rowCollapsing", "rowCollapsed", "childrenPopulating", "childrenPopulated", "childGridRendered", "childGridCreating", "childGridCreated", "cellClick", "cellRightClick", "dataBinding", "dataBound", "rendering", "rendered", "dataRendering", "dataRendered", "headerRendering", "headerRendered", "footerRendering", "footerRendered", "headerCellRendered", "rowsRendering", "rowsRendered", "schemaGenerated", "columnsCollectionModified", "requestError", "created", "destroyed"]
            }] }
];
/** @nocollapse */
IgHierarchicalGridComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgComboComponent extends IgControlBase {
    /**
     * @param {?} model
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(model, el, renderer, differs, kvalDiffers, cdr) {
        super(el, renderer, differs, kvalDiffers, cdr);
        this.model = model;
        this.onChange = (/**
         * @param {?} _
         * @return {?}
         */
        (_) => {
        });
        this.onTouched = (/**
         * @return {?}
         */
        () => {
        });
        if (model) {
            model.valueAccessor = this;
            this._model = model;
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set dataSource(value) {
        this._dataSource = value;
    }
    ;
    /**
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        let that = this;
        if (this._dataSource === null || this._dataSource === undefined) {
            this._dataSource = this.options["dataSource"];
        }
        if (!this.options["dataSource"] && this._dataSource) {
            this.options["dataSource"] = this._dataSource;
        }
        super.ngOnInit();
        if (this._model) {
            if (this.options.allowCustomValue) {
                jQuery(this._el).on("input", (/**
                 * @param {?} evt
                 * @return {?}
                 */
                function (evt) {
                    that._model.viewToModelUpdate(evt.target.value);
                }));
                jQuery(this._el).closest(".ui-igcombo-wrapper").find(".ui-igcombo-clear").on("click", (/**
                 * @return {?}
                 */
                function () {
                    if (that.options.multiSelection && that.options.multiSelection.enabled) {
                        that._model.viewToModelUpdate([]);
                    }
                    else {
                        that._model.viewToModelUpdate(null);
                    }
                }));
            }
            // D.P. #244 only attach selectionchanged handler if there's a model to update
            jQuery(this._el).on(this._widgetName.toLowerCase() + "selectionchanged", (/**
             * @param {?} evt
             * @param {?} ui
             * @return {?}
             */
            function (evt, ui) {
                /** @type {?} */
                var items = ui.items;
                /** @type {?} */
                const valueKey = ui.owner.options.valueKey;
                if (items.length <= 0 && !ui.owner.options.multiSelection.enabled) {
                    if (!ui.owner.options.allowCustomValue) {
                        that._model.viewToModelUpdate(null);
                    }
                    return;
                }
                if (ui.owner.options.multiSelection.enabled) {
                    that._model.viewToModelUpdate(items.map((/**
                     * @param {?} item
                     * @return {?}
                     */
                    function (item) {
                        return item.data[valueKey];
                    })));
                }
                else {
                    that._model.viewToModelUpdate(items[0].data[valueKey]);
                }
            }));
            //manually call writeValue, because the LifeCycle has been changed and writeValue is executed before ngOnInit
            this.writeValue(this._model.value);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (!!jQuery(this._el).data(this._widgetName)) {
            jQuery(this._el)[this._widgetName]("value", value);
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    dataSourceApplyChanges(changes) {
        //dataSource has changed.
        /** @type {?} */
        const element = jQuery(this._el);
        if (element[this._widgetName]) {
            element[this._widgetName]("option", "dataSource", this._dataSource);
        }
        if (this.model && this.model.value) {
            this.writeValue(this.model.value);
        }
    }
    /**
     * @param {?} rec
     * @param {?} val
     * @param {?} key
     * @param {?} index
     * @return {?}
     */
    updateComboItem(rec, val, key, index) {
        /** @type {?} */
        const element = jQuery(this._el);
        /** @type {?} */
        const comboItem = element.data("igCombo").itemsFromIndex(index);
        element.data("igCombo")._updateItem(comboItem.element, rec);
        if (element.data("igCombo").isSelected(comboItem.element)) {
            //should update the input
            element.data("igCombo")._updateInputValues(false);
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const ds = "dataSource";
        if (ds in changes) {
            /** @type {?} */
            const value = changes[ds].currentValue;
            if (value) {
                try {
                    this._differ = this._differs.find(value).create();
                    this._changes = [];
                    for (var i = 0; i < this._dataSource.length; i++) {
                        this._changes.push(this.kvalDiffers.find({}).create());
                    }
                }
                catch (e) {
                    throw new Error("Only binding to arrays is supported.");
                }
            }
        }
        super.ngOnChanges(changes);
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this._differ) {
            /** @type {?} */
            const changes = this._differ.diff(this._dataSource);
            //check if grid is initialized
            /** @type {?} */
            const combo = jQuery(this._el).data(this._widgetName);
            if (changes && combo) {
                this.dataSourceApplyChanges(changes);
            }
            if (this._changes && combo) {
                //check recs
                for (var i = 0; i < this._dataSource.length; i++) {
                    /** @type {?} */
                    var item = this._dataSource[i];
                    /** @type {?} */
                    var recChanges = this._changes[i].diff(item);
                    if (recChanges) {
                        recChanges.forEachChangedItem((/**
                         * @param {?} change
                         * @return {?}
                         */
                        (change) => {
                            this.updateComboItem(item, change.currentValue, change.key, i);
                        }));
                    }
                }
            }
        }
        super.ngDoCheck();
    }
    /**
     * Performs databinding on the combo box. The [databinding](ui.igcombo#events:dataBinding) and [dataBound](ui.igcombo#events:dataBound) events are always raised.
     * @return {?}
     */
    /* istanbul ignore next */
    dataBind() { return; }
    ;
    /**
     * Forces an update of the igCombo value according to the current text in the igCombo input.
     *
     * 				The refresh is primarily intended to be used with [allowCustomValue](ui.igcombo#options:allowCustomValue) set to true.
     * 				The refresh will take the current text and, if no selection is applied, will set it as igCombo value provided that [allowCustomValue](ui.igcombo#options:allowCustomValue) true.
     * @return {?}
     */
    /* istanbul ignore next */
    refreshValue() { return; }
    ;
    /**
     * Gets the associated data of an item by value matching it's [valueKey](ui.igcombo#options:valueKey) property.
     *
     * @param {?} value Value matching the valueKey property of item to be tested if it is selected
     * @return {?}
     */
    /* istanbul ignore next */
    dataForValue(value) { return; }
    ;
    /**
     * Gets the associated data of li element in the combo.
     *
     * @param {?} $element jQuery element of item in the drop down list
     * @return {?}
     */
    /* istanbul ignore next */
    dataForElement($element) { return; }
    ;
    /**
     * Gets object/s containing data and list item in the combo by element/s.
     *
     * @param {?} $element jQuery object with drop down list item element or elements
     * @return {?}
     */
    /* istanbul ignore next */
    itemsFromElement($element) { return; }
    ;
    /**
     * Gets object/s containing data and list item in the combo by value/s.
     *
     * @param {?} value Value of item in the drop down list or array with values.
     * @return {?}
     */
    /* istanbul ignore next */
    itemsFromValue(value) { return; }
    ;
    /**
     * Gets object/s containing data and list item in the combo by index/es.
     *
     * @param {?} index Index or array of indexes of items in the drop down list
     * @return {?}
     */
    /* istanbul ignore next */
    itemsFromIndex(index) { return; }
    ;
    /**
     * Gets array with data and objects representing li elements in combo box.
     * @return {?}
     */
    /* istanbul ignore next */
    items() { return; }
    ;
    /**
     * Gets array with objects representing the filtered li elements in combo box.
     * @return {?}
     */
    /* istanbul ignore next */
    filteredItems() { return; }
    ;
    /**
     * Gets array with objects representing selected li elements in combo box.
     * @return {?}
     */
    /* istanbul ignore next */
    selectedItems() { return; }
    ;
    /**
     * Triggers filtering.
     *
     * @param {?=} texts Filter by string, or array of strings.
     * @param {?=} event Indicates the browser event which triggered this action (not API). Calling the method with this param set to "true" will trigger [filtering](ui.igcombo#events:filtering) and [filtered](ui.igcombo#events:filtered) events.
     * @return {?}
     */
    /* istanbul ignore next */
    filter(texts, event) { return; }
    ;
    /**
     * Clears filtering.
     *
     * @param {?=} event Indicates the browser event which triggered this action (not API). Calling the method with this param set to "true" will trigger [filtering](ui.igcombo#events:filtering) and [filtered](ui.igcombo#events:filtered) events.
     * @return {?}
     */
    /* istanbul ignore next */
    clearFiltering(event) { return; }
    ;
    /**
     * Opens the drop-down.
     *
     * @param {?=} callback Specifies callback function to be executed when open animation is completed.
     * @param {?=} focusCombo Set to false to not focus combo"s text input after the drop down is opened. By default the combo's input is focused.
     * @param {?=} event Indicates the browser event which triggered this action (not API). Calling the method with this param set to "true" will trigger [dropDownOpening](ui.igcombo#events:dropDownOpening) and [dropDownOpened](ui.igcombo#events:dropDownOpened) events.
     * @return {?}
     */
    /* istanbul ignore next */
    openDropDown(callback, focusCombo, event) { return; }
    ;
    /**
     * Closes the drop down.
     *
     * @param {?=} callback Specifies callback function to be executed when close animation is completed.
     * @param {?=} event Indicates the browser event which triggered this action (not API). Calling the method with this param set to "true" will trigger [dropDownClosing](ui.igcombo#events:dropDownClosing) and [dropDownClosed](ui.igcombo#events:dropDownClosed) events.
     * @return {?}
     */
    /* istanbul ignore next */
    closeDropDown(callback, event) { return; }
    ;
    /**
     * Clears the input text, resets highlighting, filtering and selection.
     *
     * @param {?=} options     Object with set of options controlling the behavior of this api method.
     * focusCombo (boolean): Set to true to focus combo after clearing the input.
     * @param {?=} event Indicates the browser event which triggered this action (not API). Calling the method with this param set to "true" will trigger [selectionChanging](ui.igcombo#events:selectionChanging) and [selectionChanged](ui.igcombo#events:selectionChanged) events.
     * @return {?}
     */
    /* istanbul ignore next */
    clearInput(options, event) { return; }
    ;
    /**
     * Verifies whether a specified value is selected.
     *
     * @param {?} value Value matching the [valueKey](ui.igcombo#options:valueKey) property of item to be tested if it is selected
     * @return {?}
     */
    /* istanbul ignore next */
    isValueSelected(value) { return; }
    ;
    /**
     * Verifies whether the li representing the data source's record at the specified index is selected.
     *
     * @param {?} index Index of data source record
     * @return {?}
     */
    /* istanbul ignore next */
    isIndexSelected(index) { return; }
    ;
    /**
     * Selects list item/items from the drop-down list by specified value or array of values. When called witout params will return the value of the selected item or if [multiSelection](ui.igcombo#options:multiSelection) is enabled array of selected values.
     *
     * @param {?=} value Value or array of values matching the valueKey property of item/items to be selected
     * @param {?=} options Object with set of options controlling the behavior of this api method.
     * closeDropDown (boolean): Set to true to close the drop down list after the selection.
     * focusCombo (boolean): Set to true to focus combo after the selection.
     * additive (boolean): Set to true to select the item without losing other selection. Works only when multi selection is enabled.
     * keepFiltering (boolean): Set to true to keep filtering after the selection. By default the filtering is cleared.
     * keepInputText (boolean): Set to true to keep input text unchanged after the selection. By default input text is updated.
     * keepHighlighting (boolean): Set to true to keep highlighting unchanged after the selection. By default highlighting is removed.
     * keepNavItem (boolean): Set to true to keep current navigation item unchanged after the selection. By default the navigation item is changed to the new selected item.
     * keepScrollPosition (boolean): Set to true to keep current scroll position. By default the scroll position will change so that the last selected item is visible.
     * @param {?=} event Indicates the browser event which triggered this action (not API). Calling the method with this param set to "true" will trigger [selectionChanging](ui.igcombo#events:selectionChanging) and [selectionChanged](ui.igcombo#events:selectionChanged) events.
     * @return {?}
     */
    /* istanbul ignore next */
    value(value, options, event) { return; }
    ;
    /**
     * Selects a list item from the drop-down list.
     *
     * @param {?} $items jQuery object with item or items to be selected.
     * @param {?=} options Object with set of options controlling the behavior of this api method.
     * closeDropDown (boolean): Set to true to close the drop down list after the selection.
     * focusCombo (boolean): Set to true to focus combo after the selection.
     * additive (boolean): Set to true to select the item without losing other selection. Works only when multi selection is enabled.
     * keepFiltering (boolean): Set to true to keep filtering after the selection. By default the filtering is cleared.
     * keepInputText (boolean): Set to true to keep input text unchanged after the selection. By default input text is updated.
     * keepHighlighting (boolean): Set to true to keep highlighting unchanged after the selection. By default highlighting is removed.
     * keepNavItem (boolean): Set to true to keep current navigation item unchanged after the selection. By default the navigation item is changed to the new selected item.
     * keepScrollPosition (boolean): Set to true to keep current scroll position. By default the scroll position will change so that the last selected item is visible.
     * @param {?=} event Indicates the browser event which triggered this action (not API). Calling the method with this param set to "true" will trigger [selectionChanging](ui.igcombo#events:selectionChanging) and [selectionChanged](ui.igcombo#events:selectionChanged) events.
     * @return {?}
     */
    /* istanbul ignore next */
    select($items, options, event) { return; }
    ;
    /**
     * Gets/Sets selected item/s from the drop-down list by specified index.
     *
     * @param {?=} index Index or array of indexes of items to be selected
     * @param {?=} options Object with set of options controlling the behavior of this api method.
     * closeDropDown (boolean): Set to true to close the drop down list after the selection.
     * focusCombo (boolean): Set to true to focus combo after the selection.
     * additive (boolean): Set to true to select the item without losing other selection. Works only when multi selection is enabled.
     * keepFiltering (boolean): Set to true to keep filtering after the selection. By default the filtering is cleared.
     * keepInputText (boolean): Set to true to keep input text unchanged after the selection. By default input text is updated.
     * keepHighlighting (boolean): Set to true to keep highlighting unchanged after the selection. By default highlighting is removed.
     * keepNavItem (boolean): Set to true to keep current navigation item unchanged after the selection. By default the navigation item is changed to the new selected item.
     * keepScrollPosition (boolean): Set to true to keep current scroll position. By default the scroll position will change so that the last selected item is visible.
     * @param {?=} event Indicates the browser event which triggered this action (not API). Calling the method with this param set to "true" will trigger [selectionChanging](ui.igcombo#events:selectionChanging) and [selectionChanged](ui.igcombo#events:selectionChanged) events.
     * @return {?}
     */
    /* istanbul ignore next */
    index(index, options, event) { return; }
    ;
    /**
     * Selects all items from the drop-down list.
     *
     * @param {?=} options Object with set of options controlling the behavior of this api method.
     * closeDropDown (boolean): Set to true to close the drop down list after the selection.
     * focusCombo (boolean): Set to true to focus combo after the selection.
     * keepFiltering (boolean): Set to true to keep filtering after the selection. By default the filtering is cleared.
     * keepInputText (boolean): Set to true to keep input text unchanged after the selection. By default input text is updated.
     * keepHighlighting (boolean): Set to true to keep highlighting unchanged after the selection. By default highlighting is removed.
     * keepNavItem (boolean): Set to true to keep current navigation item unchanged after the selection. By default the navigation item is changed to the new selected item.
     * keepScrollPosition (boolean): Set to true to keep current scroll position. By default the scroll position will change so that the last selected item is visible.
     * @param {?=} event Indicates the browser event which triggered this action (not API). Calling the method with this param set to "true" will trigger [selectionChanging](ui.igcombo#events:selectionChanging) and [selectionChanged](ui.igcombo#events:selectionChanged) events.
     * @return {?}
     */
    /* istanbul ignore next */
    selectAll(options, event) { return; }
    ;
    /**
     * Deselects a list item from the drop down list by value.
     *
     * @param {?} value Value or array of values matching the [valueKey](ui.igcombo#options:valueKey) property of item/items to be deselected
     * @param {?=} options Object with set of options controlling the behavior of this api method.
     * focusCombo (boolean): Set to true to focus combo after the deselection.
     * keepInputText (boolean): Set to true to keep input text unchanged after the deselection. By default input text is updated.
     * @param {?=} event Indicates the browser event which triggered this action (not API). Calling the method with this param set to "true" will trigger [selectionChanging](ui.igcombo#events:selectionChanging) and [selectionChanged](ui.igcombo#events:selectionChanged) events.
     * @return {?}
     */
    /* istanbul ignore next */
    deselectByValue(value, options, event) { return; }
    ;
    /**
     * Deselects a list item from the drop down list.
     *
     * @param {?} $items jQuery object with item or items to be deselected
     * @param {?=} options Object with set of options controlling the behavior of this api method.
     * focusCombo (boolean): Set to true to focus combo after the deselection.
     * keepInputText (boolean): Set to true to keep input text unchanged after the deselection. By default input text is updated.
     * @param {?=} event Indicates the browser event which triggered this action (not API). Calling the method with this param set to "true" will trigger [selectionChanging](ui.igcombo#events:selectionChanging) and [selectionChanged](ui.igcombo#events:selectionChanged) events.
     * @return {?}
     */
    /* istanbul ignore next */
    deselect($items, options, event) { return; }
    ;
    /**
     * Deselects a list item from the drop down list by index.
     *
     * @param {?} index Index or array of indexes of items to be selected
     * @param {?=} options Object with set of options controlling the behavior of this api method.
     * focusCombo (boolean): Set to true to focus combo after the deselection.
     * keepInputText (boolean): Set to true to keep input text unchanged after the deselection. By default input text is updated.
     * @param {?=} event Indicates the browser event which triggered this action (not API). Calling the method with this param set to "true" will trigger [selectionChanging](ui.igcombo#events:selectionChanging) and [selectionChanged](ui.igcombo#events:selectionChanged) events.
     * @return {?}
     */
    /* istanbul ignore next */
    deselectByIndex(index, options, event) { return; }
    ;
    /**
     * Deselects all selected items from the drop down list.
     *
     * @param {?=} options Object with set of options controlling the behavior of this api method.
     * focusCombo (boolean): Set to true to focus combo after the deselection.
     * keepInputText (boolean): Set to true to keep input text unchanged after the deselection. By default input text is updated.
     * @param {?=} event Indicates the browser event which triggered this action (not API). Calling the method with this param set to "true" will trigger [selectionChanging](ui.igcombo#events:selectionChanging) and [selectionChanged](ui.igcombo#events:selectionChanged) events.
     * @return {?}
     */
    /* istanbul ignore next */
    deselectAll(options, event) { return; }
    ;
    /**
     * Gets/Sets index of active item in list.
     *
     * @param {?=} index New active index for list. In order to clear active item, use -1.
     * @return {?} number|object Returns index of active item in list or -1, if parameter is undefined. Otherwise, it returns reference to this igCombo.
     */
    /* istanbul ignore next */
    activeIndex(index) { return; }
    ;
    /**
     * Gets/Sets text in text input field.
     *
     * @param {?=} text New text value for combo's input field.
     * @return {?} string|object If parameter is undefined, then current text in field is returned. Otherwise, it returns reference to this igCombo.
     */
    /* istanbul ignore next */
    text(text) { return; }
    ;
    /**
     * Gets/Sets scrollTop attribute of html element, which scrolls drop-down list of items.
     *
     * @param {?=} value New value for scroll top in list. Note: if list is closed and new value is provided, then openDropDown() is called automatically.
     * @return {?} number|object If parameter is undefined, then scrollTop is returned. Otherwise, it returns reference to this igCombo.
     */
    /* istanbul ignore next */
    listScrollTop(value) { return; }
    ;
    /**
     * Gets jQuery objects representing all rendered list items in the combo drop down list.
     * @return {?}
     */
    /* istanbul ignore next */
    listItems() { return; }
    ;
    /**
     * Gets jQuery object of the outer element of the combo.
     * @return {?}
     */
    /* istanbul ignore next */
    comboWrapper() { return; }
    ;
    /**
     * Gets jQuery object of the drop down associated with this combo widget
     * @return {?}
     */
    /* istanbul ignore next */
    dropDown() { return; }
    ;
    /**
     * Gets jQuery object of the container that holds the list with items.
     * @return {?}
     */
    /* istanbul ignore next */
    list() { return; }
    ;
    /**
     * Gets jQuery object of the text input associated with this combo widget.
     * @return {?}
     */
    /* istanbul ignore next */
    textInput() { return; }
    ;
    /**
     * Gets jQuery object of the value input associated with this combo widget.
     * @return {?}
     */
    /* istanbul ignore next */
    valueInput() { return; }
    ;
    /**
     * Gets reference to [igValidator](ui.igvalidator) used by igCombo.
     *
     * @param {?=} destroy Request to destroy validator.
     * @return {?}
     */
    /* istanbul ignore next */
    validator(destroy) { return; }
    ;
    /**
     * Trigger validation.
     * @return {?}
     */
    /* istanbul ignore next */
    validate() { return; }
    ;
    /**
     * Returns boolean representing whether the combo drop down list is opened.
     * @return {?}
     */
    /* istanbul ignore next */
    dropDownOpened() { return; }
    ;
    /**
     * Repositions drop down under combo input. Has effect only when the drop down is attached to body.
     * @return {?}
     */
    /* istanbul ignore next */
    positionDropDown() { return; }
    ;
    /**
     * Destroys the igCombo widget.
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
}
IgComboComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-combo",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "width", "height", "dropDownWidth", "dataSource", "dataSourceType", "dataSourceUrl", "responseTotalRecCountKey", "responseDataKey", "responseDataType", "responseContentType", "requestType", "valueKey", "textKey", "itemTemplate", "headerTemplate", "footerTemplate", "inputName", "animationShowDuration", "animationHideDuration", "dropDownAttachedToBody", "filteringType", "filterExprUrlKey", "filteringCondition", "filteringLogic", "noMatchFoundText", "loadOnDemandSettings", "visibleItemsCount", "placeHolder", "mode", "virtualization", "multiSelection", "grouping", "validatorOptions", "highlightMatchesMode", "caseSensitive", "autoSelectFirstMatch", "autoComplete", "allowCustomValue", "closeDropDownOnBlur", "delayInputChangeProcessing", "tabIndex", "dropDownOnFocus", "closeDropDownOnSelect", "selectItemBySpaceKey", "initialSelectedItems", "preventSubmitOnEnter", "format", "suppressKeyboard", "enableClearButton", "dropDownButtonTitle", "clearButtonTitle", "dropDownOrientation"],
                outputs: ["rendered", "dataBinding", "dataBound", "filtering", "filtered", "itemsRendering", "itemsRendered", "dropDownOpening", "dropDownOpened", "dropDownClosing", "dropDownClosed", "selectionChanging", "selectionChanged"]
            }] }
];
/** @nocollapse */
IgComboComponent.ctorParameters = () => [
    { type: NgModel, decorators: [{ type: Optional }] },
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];
IgComboComponent.propDecorators = {
    dataSource: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template Model
 */
class IgEditorBase extends IgControlBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     * @param {?} model
     */
    constructor(el, renderer, differs, kvalDiffers, cdr, model) {
        super(el, renderer, differs, kvalDiffers, cdr);
        this.model = model;
        this.onChange = (/**
         * @param {?} _
         * @return {?}
         */
        (_) => {
        });
        this.onTouched = (/**
         * @return {?}
         */
        () => {
        });
        if (model) {
            model.valueAccessor = this;
            this._model = model;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        let that = this;
        super.ngOnInit();
        if (this._model) {
            jQuery(this._el).on(this._widgetName.toLowerCase() + "valuechanged", (/**
             * @param {?} evt
             * @param {?} ui
             * @return {?}
             */
            function (evt, ui) {
                that.onChange(ui.newValue);
            }));
            if (this._widgetName === "igTextEditor") {
                jQuery(this._el).on(this._widgetName.toLowerCase() + "textchanged", (/**
                 * @param {?} evt
                 * @param {?} ui
                 * @return {?}
                 */
                function (evt, ui) {
                    that.onChange(ui.text);
                }));
            }
            jQuery(this._el).on(this._widgetName.toLowerCase() + "blur", (/**
             * @param {?} evt
             * @param {?} ui
             * @return {?}
             */
            function (evt, ui) {
                that.onTouched();
            }));
            //manually call writeValue, because the LifeCycle has been changed and writeValue is executed before ngOnInit
            this.writeValue(this._model.value);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (!!jQuery(this._el).data(this._widgetName) && value !== null) {
            jQuery(this._el)[this._widgetName]("value", value);
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
}
/** @nocollapse */
IgEditorBase.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef },
    { type: NgModel, decorators: [{ type: Optional }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgCheckboxEditorComponent extends IgEditorBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     * @param {?} model
     */
    constructor(el, renderer, differs, kvalDiffers, cdr, model) {
        super(el, renderer, differs, kvalDiffers, cdr, model);
        this.model = model;
    }
    /**
     * Checks if the value in the editor is valid. Note: This function will not trigger automatic notifications.
     * @return {?}
     */
    /* istanbul ignore next */
    isValid() { return; }
    ;
    /**
     * Gets/Sets Current checked state/Value of the igCheckboxEditor that will be submitted by the HTML form.
     * 1. If the [value](ui.igcheckboxeditor#options:value) option IS NOT defined, then 'value' method will match the checked state of the editor.
     * This option is used when the checkbox is intended to operate as a Boolean editor. In that case the return type is bool.
     * 2. If the [value](ui.igcheckboxeditor#options:value) option IS defined, then 'value' method will return the value that will be submitted when the editor is checked and the form is submitted.
     * To get checked state regardless of the 'value' option, use $(".selector").igCheckboxEditor("option", "checked");
     *
     * @param {?} newValue
     * @return {?}
     */
    /* istanbul ignore next */
    value(newValue) { return; }
    ;
    /**
     * Toggles the state of the checkbox.
     * @return {?}
     */
    /* istanbul ignore next */
    toggle() { return; }
    ;
    /**
     * Gets/Sets name attribute applied to the editor element.
     *
     * @param {?=} newValue The new input name.
     * @return {?}
     */
    /* istanbul ignore next */
    inputName(newValue) { return; }
    ;
    /**
     * Gets the input element of the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    field() { return; }
    ;
    /**
     * Gets a reference to the jQuery element that wraps the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    editorContainer() { return; }
    ;
    /**
     * Gets whether the editor has focus.
     * @return {?}
     */
    /* istanbul ignore next */
    hasFocus() { return; }
    ;
    /**
     * Sets focus to the editor after the specified delay.
     *
     * @param {?=} delay The delay before focusing the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    setFocus(delay) { return; }
    ;
    /**
     * Hides the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    hide() { return; }
    ;
    /**
     * Shows the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    show() { return; }
    ;
    /**
     * Gets a reference to [igValidator](ui.igvalidator) used by the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    validator() { return; }
    ;
    /**
     * Triggers validation for the editor. If validatorOptions are set will also call validate on the [igValidator](ui.igvalidator).
     * @return {?}
     */
    /* istanbul ignore next */
    validate() { return; }
    ;
    /**
     * Destroys the widget
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
}
IgCheckboxEditorComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-checkbox-editor",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "width", "height", "value", "tabIndex", "allowNullValue", "nullValue", "inputName", "readOnly", "validatorOptions", "checked", "size", "iconClass"],
                outputs: ["rendering", "rendered", "mousedown", "mouseup", "mousemove", "mouseover", "mouseout", "blur", "focus", "keydown", "keypress", "keyup", "valueChanging", "valueChanged"]
            }] }
];
/** @nocollapse */
IgCheckboxEditorComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef },
    { type: NgModel, decorators: [{ type: Optional }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgCurrencyEditorComponent extends IgEditorBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     * @param {?} model
     */
    constructor(el, renderer, differs, kvalDiffers, cdr, model) {
        super(el, renderer, differs, kvalDiffers, cdr, model);
        this.model = model;
    }
    /**
     * Gets/sets a string that is used as the currency symbol shown with the number in the input. The value provided as a param is propagated to the currencySymbol option and thus has the same priority as the option.
     *
     * @param {?=} symbol New currency symbol.
     * @return {?}
     */
    /* istanbul ignore next */
    currencySymbol(symbol) { return; }
    ;
    /**
     * Gets/Sets editor value.
     *
     * @param {?=} newValue New editor value.
     * @return {?}
     */
    /* istanbul ignore next */
    value(newValue) { return; }
    ;
    /**
     * Finds index of list item by text that matches with the search parameters.
     *
     * @param {?} number The text to search for.
     * @return {?}
     */
    /* istanbul ignore next */
    findListItemIndex(number) { return; }
    ;
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    getSelectedText() { return; }
    ;
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    getSelectionStart() { return; }
    ;
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    getSelectionEnd() { return; }
    ;
    /**
     * Increments value in editor according to the parameter or selects the previous item from the drop-down list if [isLimitedToListValues](ui.%%WidgetNameLowered%%#options:isLimitedToListValues) is enabled.
     *
     * @param {?=} delta Increments value.
     * @return {?}
     */
    /* istanbul ignore next */
    spinUp(delta) { return; }
    ;
    /**
     * Decrements value in editor according to the parameter selects the next item from the drop-down list if [isLimitedToListValues](ui.%%WidgetNameLowered%%#options:isLimitedToListValues) is enabled.
     *
     * @param {?=} delta Decrement value.
     * @return {?}
     */
    /* istanbul ignore next */
    spinDown(delta) { return; }
    ;
    /**
     * This method is deprecated in favor of [spinUp](ui.%%WidgetNameLowered%%#options:spinUp).
     * @return {?}
     */
    /* istanbul ignore next */
    selectListIndexUp() { return; }
    ;
    /**
     * This method is deprecated in favor of [spinDown](ui.%%WidgetNameLowered%%#options:spinDown).
     * @return {?}
     */
    /* istanbul ignore next */
    selectListIndexDown() { return; }
    ;
    /**
     * Gets current regional.
     * @return {?}
     */
    /* istanbul ignore next */
    getRegionalOption() { return; }
    ;
    /**
     * Changes the the regional settings of widget element to the language specified in [options.regional](ui.ignumericeditor#options:regional)
     * Note that this method is for rare scenarios, use [regional](ui.ignumericeditor#options:regional) option setter
     * @return {?}
     */
    /* istanbul ignore next */
    changeRegional() { return; }
    ;
}
IgCurrencyEditorComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-currency-editor",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "width", "height", "value", "tabIndex", "allowNullValue", "nullValue", "inputName", "readOnly", "validatorOptions", "buttonType", "listItems", "listWidth", "listItemHoverDuration", "dropDownAttachedToBody", "dropDownAnimationDuration", "visibleItemsCount", "includeKeys", "excludeKeys", "textAlign", "placeHolder", "selectionOnFocus", "textMode", "spinWrapAround", "isLimitedToListValues", "revertIfNotValid", "preventSubmitOnEnter", "dropDownOrientation", "maxLength", "dropDownOnReadOnly", "toUpper", "toLower", "locale", "suppressNotifications", "regional", "negativeSign", "negativePattern", "decimalSeparator", "groupSeparator", "groups", "maxDecimals", "minDecimals", "dataMode", "minValue", "maxValue", "spinDelta", "scientificFormat", "positivePattern", "currencySymbol"],
                outputs: ["rendering", "rendered", "mousedown", "mouseup", "mousemove", "mouseover", "mouseout", "blur", "focus", "keydown", "keypress", "keyup", "valueChanging", "valueChanged", "dropDownListOpening", "dropDownListOpened", "dropDownListClosing", "dropDownListClosed", "dropDownItemSelecting", "dropDownItemSelected", "textChanged"]
            }] }
];
/** @nocollapse */
IgCurrencyEditorComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef },
    { type: NgModel, decorators: [{ type: Optional }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgDateEditorComponent extends IgEditorBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     * @param {?} model
     */
    constructor(el, renderer, differs, kvalDiffers, cdr, model) {
        super(el, renderer, differs, kvalDiffers, cdr, model);
        this.model = model;
    }
    /**
     * Changes the the regional settings of widget element to the language specified in [options.regional](ui.igdateeditor#options:regional)
     * Note that this method is for rare scenarios, use [regional](ui.igdateeditor#options:regional) option setter
     * @return {?}
     */
    /* istanbul ignore next */
    changeRegional() { return; }
    ;
    /**
     * Gets/Sets editor value.
     *
     * Note! This option doesn't use the dateInputFormat to extract the date
     *
     * @param {?=} newValue New editor value. Date object can be set as value. String value can be passed and the editor will use the javascript Date object constructor to create date object and will use it for the comparison. MVC date format can be used too. For example Date(/"thicks"/).
     * @return {?}
     */
    /* istanbul ignore next */
    value(newValue) { return; }
    ;
    /**
     * Gets selected date as a date object. This method can be used when dataMode is set as either displayModeText or editModeText.
     * In such cases the value() method will not return date object and getSelectedDate() can be used to replace that functionality.
     * @return {?}
     */
    /* istanbul ignore next */
    getSelectedDate() { return; }
    ;
    /**
     * Sets selected date. This method can be used when dataMode is set as either displayModeText or editModeText.
     * In such cases the value() cannot accept a date object as a new value and getSelectedDate() can be used to replace that functionality.
     *
     * @param {?} date
     * @return {?}
     */
    /* istanbul ignore next */
    selectDate(date) { return; }
    ;
    /**
     * Increases the date or time period, depending on the current cursor position.
     *
     * @param {?=} delta The increase delta.
     * @return {?}
     */
    /* istanbul ignore next */
    spinUp(delta) { return; }
    ;
    /**
     * Decreases the date or time period, depending on the current cursor position.
     *
     * @param {?=} delta The decrease delta.
     * @return {?}
     */
    /* istanbul ignore next */
    spinDown(delta) { return; }
    ;
    /**
     * Returns a reference to the spin up UI element of the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    spinUpButton() { return; }
    ;
    /**
     * Returns a reference to the spin down UI element of the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    spinDownButton() { return; }
    ;
    /**
     * Checks if the value in the editor is valid. Note: This function will not trigger automatic notifications.
     * @return {?}
     */
    /* istanbul ignore next */
    isValid() { return; }
    ;
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    dropDownButton() { return; }
    ;
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    dropDownContainer() { return; }
    ;
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    dropDownVisible() { return; }
    ;
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    findListItemIndex() { return; }
    ;
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    getSelectedListItem() { return; }
    ;
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    selectedListIndex() { return; }
    ;
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    showDropDown() { return; }
    ;
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    hideDropDown() { return; }
    ;
}
IgDateEditorComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-date-editor",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "width", "height", "value", "tabIndex", "allowNullValue", "nullValue", "inputName", "readOnly", "validatorOptions", "buttonType", "listItems", "listWidth", "listItemHoverDuration", "dropDownAttachedToBody", "dropDownAnimationDuration", "visibleItemsCount", "includeKeys", "excludeKeys", "textAlign", "placeHolder", "selectionOnFocus", "textMode", "spinWrapAround", "isLimitedToListValues", "revertIfNotValid", "preventSubmitOnEnter", "dropDownOrientation", "maxLength", "dropDownOnReadOnly", "toUpper", "toLower", "locale", "suppressNotifications", "regional", "inputMask", "dataMode", "unfilledCharsPrompt", "padChar", "emptyChar", "minValue", "maxValue", "dateDisplayFormat", "dateInputFormat", "spinDelta", "limitSpinToCurrentField", "enableUTCDates", "centuryThreshold", "yearShift"],
                outputs: ["rendering", "rendered", "mousedown", "mouseup", "mousemove", "mouseover", "mouseout", "blur", "focus", "keydown", "keypress", "keyup", "valueChanging", "valueChanged", "dropDownListOpening", "dropDownListOpened", "dropDownListClosing", "dropDownListClosed", "dropDownItemSelecting", "dropDownItemSelected", "textChanged"]
            }] }
];
/** @nocollapse */
IgDateEditorComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef },
    { type: NgModel, decorators: [{ type: Optional }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgDatePickerComponent extends IgEditorBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     * @param {?} model
     */
    constructor(el, renderer, differs, kvalDiffers, cdr, model) {
        super(el, renderer, differs, kvalDiffers, cdr, model);
        this.model = model;
    }
    /**
     * Changes the the regional settings of widget element to the language specified in [options.regional](ui.igdatepicker#options:regional)
     * Note that this method is for rare scenarios, use [regional](ui.igdatepicker#options:regional) option setter
     * @return {?}
     */
    /* istanbul ignore next */
    changeRegional() { return; }
    ;
    /**
     * Returns a reference to the jQuery calendar used as a picker selector
     * @return {?}
     */
    /* istanbul ignore next */
    getCalendar() { return; }
    ;
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    dropDownContainer() { return; }
    ;
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    findListItemIndex() { return; }
    ;
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    getSelectedListItem() { return; }
    ;
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    selectedListIndex() { return; }
    ;
    /**
     * Shows the drop down list.
     * @return {?}
     */
    /* istanbul ignore next */
    showDropDown() { return; }
    ;
    /**
     * Hides the drop down list.
     * @return {?}
     */
    /* istanbul ignore next */
    hideDropDown() { return; }
    ;
    /**
     * Returns a reference to the calendar button UI element of the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    dropDownButton() { return; }
    ;
    /**
     * Returns the visibility state of the calendar.
     * @return {?}
     */
    /* istanbul ignore next */
    dropDownVisible() { return; }
    ;
    /**
     * Destroys the widget
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
    /**
     * Gets/Sets editor value.
     *
     * Note! This option doesn't use the dateInputFormat to extract the date
     *
     * @param {?=} newValue New editor value. Date object can be set as value. String value can be passed and the editor will use the javascript Date object constructor to create date object and will use it for the comparison. MVC date format can be used too. For example Date(/"thicks"/).
     * @return {?}
     */
    /* istanbul ignore next */
    value(newValue) { return; }
    ;
    /**
     * Gets selected date as a date object. This method can be used when dataMode is set as either displayModeText or editModeText.
     * In such cases the value() method will not return date object and getSelectedDate() can be used to replace that functionality.
     * @return {?}
     */
    /* istanbul ignore next */
    getSelectedDate() { return; }
    ;
    /**
     * Sets selected date. This method can be used when dataMode is set as either displayModeText or editModeText.
     * In such cases the value() cannot accept a date object as a new value and getSelectedDate() can be used to replace that functionality.
     *
     * @param {?} date
     * @return {?}
     */
    /* istanbul ignore next */
    selectDate(date) { return; }
    ;
    /**
     * Increases the date or time period, depending on the current cursor position.
     *
     * @param {?=} delta The increase delta.
     * @return {?}
     */
    /* istanbul ignore next */
    spinUp(delta) { return; }
    ;
    /**
     * Decreases the date or time period, depending on the current cursor position.
     *
     * @param {?=} delta The decrease delta.
     * @return {?}
     */
    /* istanbul ignore next */
    spinDown(delta) { return; }
    ;
    /**
     * Returns a reference to the spin up UI element of the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    spinUpButton() { return; }
    ;
    /**
     * Returns a reference to the spin down UI element of the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    spinDownButton() { return; }
    ;
    /**
     * Checks if the value in the editor is valid. Note: This function will not trigger automatic notifications.
     * @return {?}
     */
    /* istanbul ignore next */
    isValid() { return; }
    ;
}
IgDatePickerComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-date-picker",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "width", "height", "value", "tabIndex", "allowNullValue", "nullValue", "inputName", "readOnly", "validatorOptions", "buttonType", "listItems", "listWidth", "listItemHoverDuration", "dropDownAttachedToBody", "dropDownAnimationDuration", "visibleItemsCount", "includeKeys", "excludeKeys", "textAlign", "placeHolder", "selectionOnFocus", "textMode", "spinWrapAround", "isLimitedToListValues", "revertIfNotValid", "preventSubmitOnEnter", "dropDownOrientation", "maxLength", "dropDownOnReadOnly", "toUpper", "toLower", "locale", "suppressNotifications", "regional", "inputMask", "dataMode", "unfilledCharsPrompt", "padChar", "emptyChar", "minValue", "maxValue", "dateDisplayFormat", "dateInputFormat", "spinDelta", "limitSpinToCurrentField", "enableUTCDates", "centuryThreshold", "yearShift", "datepickerOptions"],
                outputs: ["rendering", "rendered", "mousedown", "mouseup", "mousemove", "mouseover", "mouseout", "blur", "focus", "keydown", "keypress", "keyup", "valueChanging", "valueChanged", "dropDownListOpening", "dropDownListOpened", "dropDownListClosing", "dropDownListClosed", "dropDownItemSelecting", "dropDownItemSelected", "textChanged", "itemSelected"]
            }] }
];
/** @nocollapse */
IgDatePickerComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef },
    { type: NgModel, decorators: [{ type: Optional }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgTimePickerComponent extends IgEditorBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     * @param {?} model
     */
    constructor(el, renderer, differs, kvalDiffers, cdr, model) {
        super(el, renderer, differs, kvalDiffers, cdr, model);
        this.model = model;
    }
    /**
     * Gets the selected list item.
     * @return {?}
     */
    /* istanbul ignore next */
    getSelectedListItem() { return; }
    ;
    /**
     * Returns the visibility state of the calendar.
     * @return {?}
     */
    /* istanbul ignore next */
    dropDownVisible() { return; }
    ;
    /**
     * Returns a reference to the drop-down button UI element of the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    dropDownButton() { return; }
    ;
    /**
     * Gets reference to jquery object which is used as container of drop-down list.
     * @return {?}
     */
    /* istanbul ignore next */
    dropDownContainer() { return; }
    ;
    /**
     * Finds index of list item by text that matches with the search parameters.
     *
     * @param {?} text The text to search for in the drop down list.
     * @param {?=} matchType The rule that is applied for searching the text.
     * @return {?}
     */
    /* istanbul ignore next */
    findListItemIndex(text, matchType) { return; }
    ;
    /**
     * Gets the index of the selected list item. Sets selected item by index.
     *
     * @param {?=} index The index of the item that needs to be selected.
     * @return {?}
     */
    /* istanbul ignore next */
    selectedListIndex(index) { return; }
    ;
    /* istanbul ignore next */
    /**
     * @param {?} newValue
     * @return {?}
     */
    value(newValue) { return; }
    ;
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    selectDate() { return; }
    ;
    /**
     * Changes the the regional settings of widget element to the language specified in [options.regional](ui.igdateeditor#options:regional)
     * Note that this method is for rare scenarios, use [regional](ui.igdateeditor#options:regional) option setter
     * @return {?}
     */
    /* istanbul ignore next */
    changeRegional() { return; }
    ;
    /**
     * Gets selected date as a date object. This method can be used when dataMode is set as either displayModeText or editModeText.
     * In such cases the value() method will not return date object and getSelectedDate() can be used to replace that functionality.
     * @return {?}
     */
    /* istanbul ignore next */
    getSelectedDate() { return; }
    ;
    /**
     * Increases the date or time period, depending on the current cursor position.
     *
     * @param {?=} delta The increase delta.
     * @return {?}
     */
    /* istanbul ignore next */
    spinUp(delta) { return; }
    ;
    /**
     * Decreases the date or time period, depending on the current cursor position.
     *
     * @param {?=} delta The decrease delta.
     * @return {?}
     */
    /* istanbul ignore next */
    spinDown(delta) { return; }
    ;
    /**
     * Returns a reference to the spin up UI element of the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    spinUpButton() { return; }
    ;
    /**
     * Returns a reference to the spin down UI element of the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    spinDownButton() { return; }
    ;
    /**
     * Checks if the value in the editor is valid. Note: This function will not trigger automatic notifications.
     * @return {?}
     */
    /* istanbul ignore next */
    isValid() { return; }
    ;
}
IgTimePickerComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-time-picker",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "disabled", "create", "locale", "language", "regional", "width", "height", "value", "tabIndex", "allowNullValue", "nullValue", "inputName", "readOnly", "validatorOptions", "buttonType", "listItems", "listWidth", "listItemHoverDuration", "dropDownAttachedToBody", "dropDownAnimationDuration", "visibleItemsCount", "includeKeys", "excludeKeys", "textAlign", "placeHolder", "selectionOnFocus", "textMode", "spinWrapAround", "isLimitedToListValues", "revertIfNotValid", "preventSubmitOnEnter", "dropDownOrientation", "maxLength", "dropDownOnReadOnly", "toUpper", "toLower", "suppressNotifications", "suppressKeyboard", "inputMask", "dataMode", "unfilledCharsPrompt", "padChar", "emptyChar", "minValue", "maxValue", "dateDisplayFormat", "dateInputFormat", "displayTimeOffset", "spinDelta", "limitSpinToCurrentField", "enableUTCDates", "centuryThreshold", "yearShift", "itemsDelta", "timeInputFormat", "timeDisplayFormat"],
                outputs: ["rendering", "rendered", "mousedown", "mouseup", "mousemove", "mouseover", "mouseout", "blur", "focus", "keydown", "keypress", "keyup", "valueChanging", "valueChanged", "dropDownListOpening", "dropDownListOpened", "dropDownListClosing", "dropDownListClosed", "dropDownItemSelecting", "dropDownItemSelected", "textChanged"]
            }] }
];
/** @nocollapse */
IgTimePickerComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef },
    { type: NgModel, decorators: [{ type: Optional }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgMaskEditorComponent extends IgEditorBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     * @param {?} model
     */
    constructor(el, renderer, differs, kvalDiffers, cdr, model) {
        super(el, renderer, differs, kvalDiffers, cdr, model);
        this.model = model;
    }
    /**
     * Gets/Sets mask editor value.
     *
     * @param {?=} newValue New mask editor value.
     * @return {?}
     */
    /* istanbul ignore next */
    value(newValue) { return; }
    ;
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    dropDownContainer() { return; }
    ;
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    showDropDown() { return; }
    ;
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    hideDropDown() { return; }
    ;
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    dropDownButton() { return; }
    ;
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    spinUpButton() { return; }
    ;
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    spinDownButton() { return; }
    ;
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    dropDownVisible() { return; }
    ;
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    findListItemIndex() { return; }
    ;
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    selectedListIndex() { return; }
    ;
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    getSelectedListItem() { return; }
    ;
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    spinUp() { return; }
    ;
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    spinDown() { return; }
    ;
    /**
     * Checks if the value in the editor is valid. Note: This function will not trigger automatic notifications.
     * @return {?}
     */
    /* istanbul ignore next */
    isValid() { return; }
    ;
    /**
     * Changes the all locales into the widget element to the language specified in [options.language](ui.igtexteditor#options:language)
     * Note that this method is for rare scenarios, see [language](ui.igtexteditor#options:language) or [locale](ui.igtexteditor#options:locale) option setter
     * @return {?}
     */
    /* istanbul ignore next */
    changeLocale() { return; }
    ;
    /**
     * Gets the visible text in the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    displayValue() { return; }
    ;
    /**
     * Returns a reference to the clear button UI element of the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    clearButton() { return; }
    ;
    /**
     * Gets the selected text from the editor in edit mode. This can be done inside key event handlers, like keydown or keyup. This method can be used only when the editor is focused. If you invoke this method in display mode, when the editor input is blurred, the returned value will be an empty string.
     * @return {?}
     */
    /* istanbul ignore next */
    getSelectedText() { return; }
    ;
    /**
     * Gets the start index of the selected text in the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    getSelectionStart() { return; }
    ;
    /**
     * Gets the end index of the selected text in the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    getSelectionEnd() { return; }
    ;
    /**
     * Inserts the text at the location of the caret or over the current selection. If the editor is focused the method will insert the text over the current selection. If the editor is not focused the method will set the text as value of the editor.
     * Note: The method raises [textChanged](ui.igtexteditor#events:textChanged) event.
     *
     * @param {?} string The string to be inserted.
     * @return {?}
     */
    /* istanbul ignore next */
    insert(string) { return; }
    ;
    /**
     * Selects the text between start and end indices in the editor. If the parameters are equal, then the method sets location of caret. The method has effect only when the editor has focus.
     *
     * @param {?} start Start of the selection.
     * @param {?} end End of the selection.
     * @return {?}
     */
    /* istanbul ignore next */
    select(start, end) { return; }
    ;
}
IgMaskEditorComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-mask-editor",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "width", "height", "value", "tabIndex", "allowNullValue", "nullValue", "inputName", "readOnly", "validatorOptions", "buttonType", "listItems", "listWidth", "listItemHoverDuration", "dropDownAttachedToBody", "dropDownAnimationDuration", "visibleItemsCount", "includeKeys", "excludeKeys", "textAlign", "placeHolder", "selectionOnFocus", "textMode", "spinWrapAround", "isLimitedToListValues", "revertIfNotValid", "preventSubmitOnEnter", "dropDownOrientation", "maxLength", "dropDownOnReadOnly", "toUpper", "toLower", "locale", "suppressNotifications", "regional", "inputMask", "dataMode", "unfilledCharsPrompt", "padChar", "emptyChar"],
                outputs: ["rendering", "rendered", "mousedown", "mouseup", "mousemove", "mouseover", "mouseout", "blur", "focus", "keydown", "keypress", "keyup", "valueChanging", "valueChanged", "dropDownListOpening", "dropDownListOpened", "dropDownListClosing", "dropDownListClosed", "dropDownItemSelecting", "dropDownItemSelected", "textChanged"]
            }] }
];
/** @nocollapse */
IgMaskEditorComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef },
    { type: NgModel, decorators: [{ type: Optional }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgNumericEditorComponent extends IgEditorBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     * @param {?} model
     */
    constructor(el, renderer, differs, kvalDiffers, cdr, model) {
        super(el, renderer, differs, kvalDiffers, cdr, model);
        this.model = model;
    }
    /**
     * Gets/Sets editor value.
     *
     * @param {?=} newValue New editor value.
     * @return {?}
     */
    /* istanbul ignore next */
    value(newValue) { return; }
    ;
    /**
     * Finds index of list item by text that matches with the search parameters.
     *
     * @param {?} number The text to search for.
     * @return {?}
     */
    /* istanbul ignore next */
    findListItemIndex(number) { return; }
    ;
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    getSelectedText() { return; }
    ;
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    getSelectionStart() { return; }
    ;
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    getSelectionEnd() { return; }
    ;
    /**
     * Increments value in editor according to the parameter or selects the previous item from the drop-down list if [isLimitedToListValues](ui.%%WidgetNameLowered%%#options:isLimitedToListValues) is enabled.
     *
     * @param {?=} delta Increments value.
     * @return {?}
     */
    /* istanbul ignore next */
    spinUp(delta) { return; }
    ;
    /**
     * Decrements value in editor according to the parameter selects the next item from the drop-down list if [isLimitedToListValues](ui.%%WidgetNameLowered%%#options:isLimitedToListValues) is enabled.
     *
     * @param {?=} delta Decrement value.
     * @return {?}
     */
    /* istanbul ignore next */
    spinDown(delta) { return; }
    ;
    /**
     * This method is deprecated in favor of [spinUp](ui.%%WidgetNameLowered%%#options:spinUp).
     * @return {?}
     */
    /* istanbul ignore next */
    selectListIndexUp() { return; }
    ;
    /**
     * This method is deprecated in favor of [spinDown](ui.%%WidgetNameLowered%%#options:spinDown).
     * @return {?}
     */
    /* istanbul ignore next */
    selectListIndexDown() { return; }
    ;
    /**
     * Gets current regional.
     * @return {?}
     */
    /* istanbul ignore next */
    getRegionalOption() { return; }
    ;
    /**
     * Changes the the regional settings of widget element to the language specified in [options.regional](ui.ignumericeditor#options:regional)
     * Note that this method is for rare scenarios, use [regional](ui.ignumericeditor#options:regional) option setter
     * @return {?}
     */
    /* istanbul ignore next */
    changeRegional() { return; }
    ;
    /**
     * Changes the all locales into the widget element to the language specified in [options.language](ui.igtexteditor#options:language)
     * Note that this method is for rare scenarios, see [language](ui.igtexteditor#options:language) or [locale](ui.igtexteditor#options:locale) option setter
     * @return {?}
     */
    /* istanbul ignore next */
    changeLocale() { return; }
    ;
    /**
     * Gets the visible text in the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    displayValue() { return; }
    ;
    /**
     * Gets reference to jquery object which is used as container of drop-down list.
     * @return {?}
     */
    /* istanbul ignore next */
    dropDownContainer() { return; }
    ;
    /**
     * Shows the drop down list.
     * @return {?}
     */
    /* istanbul ignore next */
    showDropDown() { return; }
    ;
    /**
     * Hides the drop down list.
     * @return {?}
     */
    /* istanbul ignore next */
    hideDropDown() { return; }
    ;
    /**
     * Returns a reference to the drop-down button UI element of the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    dropDownButton() { return; }
    ;
    /**
     * Returns if the drop-down list is visible.
     * @return {?}
     */
    /* istanbul ignore next */
    dropDownVisible() { return; }
    ;
    /**
     * Returns a reference to the clear button UI element of the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    clearButton() { return; }
    ;
    /**
     * Gets the index of the selected list item. Sets selected item by index.
     *
     * @param {?=} index The index of the item that needs to be selected.
     * @return {?}
     */
    /* istanbul ignore next */
    selectedListIndex(index) { return; }
    ;
    /**
     * Gets the selected list item.
     * @return {?}
     */
    /* istanbul ignore next */
    getSelectedListItem() { return; }
    ;
    /**
     * Inserts the text at the location of the caret or over the current selection. If the editor is focused the method will insert the text over the current selection. If the editor is not focused the method will set the text as value of the editor.
     * Note: The method raises [textChanged](ui.igtexteditor#events:textChanged) event.
     *
     * @param {?} string The string to be inserted.
     * @return {?}
     */
    /* istanbul ignore next */
    insert(string) { return; }
    ;
    /**
     * Selects the text between start and end indices in the editor. If the parameters are equal, then the method sets location of caret. The method has effect only when the editor has focus.
     *
     * @param {?} start Start of the selection.
     * @param {?} end End of the selection.
     * @return {?}
     */
    /* istanbul ignore next */
    select(start, end) { return; }
    ;
    /**
     * Returns a reference to the spin up UI element of the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    spinUpButton() { return; }
    ;
    /**
     * Returns a reference to the spin down UI element of the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    spinDownButton() { return; }
    ;
}
IgNumericEditorComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-numeric-editor",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "width", "height", "value", "tabIndex", "allowNullValue", "nullValue", "inputName", "readOnly", "validatorOptions", "buttonType", "listItems", "listWidth", "listItemHoverDuration", "dropDownAttachedToBody", "dropDownAnimationDuration", "visibleItemsCount", "includeKeys", "excludeKeys", "textAlign", "placeHolder", "selectionOnFocus", "textMode", "spinWrapAround", "isLimitedToListValues", "revertIfNotValid", "preventSubmitOnEnter", "dropDownOrientation", "maxLength", "dropDownOnReadOnly", "toUpper", "toLower", "locale", "suppressNotifications", "regional", "negativeSign", "negativePattern", "decimalSeparator", "groupSeparator", "groups", "maxDecimals", "minDecimals", "dataMode", "minValue", "maxValue", "spinDelta", "scientificFormat"],
                outputs: ["rendering", "rendered", "mousedown", "mouseup", "mousemove", "mouseover", "mouseout", "blur", "focus", "keydown", "keypress", "keyup", "valueChanging", "valueChanged", "dropDownListOpening", "dropDownListOpened", "dropDownListClosing", "dropDownListClosed", "dropDownItemSelecting", "dropDownItemSelected", "textChanged"]
            }] }
];
/** @nocollapse */
IgNumericEditorComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef },
    { type: NgModel, decorators: [{ type: Optional }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgPercentEditorComponent extends IgEditorBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     * @param {?} model
     */
    constructor(el, renderer, differs, kvalDiffers, cdr, model) {
        super(el, renderer, differs, kvalDiffers, cdr, model);
        this.model = model;
    }
    /**
     * Paste text at location of the caret or over the current selection. Best used during editing, as the method will instead set the text as value (modified by the [displayFactor](ui.igpercenteditor#options:displayFactor)) if the editor is not focused.
     * Note: the method raises the [textChanged](ui.igpercenteditor#events:textChanged) event.
     *
     * @param {?} string The string to be inserted.
     * @return {?}
     */
    /* istanbul ignore next */
    insert(string) { return; }
    ;
    /**
     * Gets/Sets a string that is used as the percent symbol shown with the number in the input. The value provided as a param is propagated to the [percentSymbol](ui.igpercenteditor#options:percentSymbol) option and thus has the same priority as the option.
     *
     * @param {?=} symbol New percent symbol.
     * @return {?}
     */
    /* istanbul ignore next */
    percentSymbol(symbol) { return; }
    ;
    /**
     * Gets/Sets editor value.
     *
     * @param {?=} newValue New editor value.
     * @return {?}
     */
    /* istanbul ignore next */
    value(newValue) { return; }
    ;
    /**
     * Finds index of list item by text that matches with the search parameters.
     *
     * @param {?} number The text to search for.
     * @return {?}
     */
    /* istanbul ignore next */
    findListItemIndex(number) { return; }
    ;
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    getSelectedText() { return; }
    ;
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    getSelectionStart() { return; }
    ;
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    getSelectionEnd() { return; }
    ;
    /**
     * Increments value in editor according to the parameter or selects the previous item from the drop-down list if [isLimitedToListValues](ui.%%WidgetNameLowered%%#options:isLimitedToListValues) is enabled.
     *
     * @param {?=} delta Increments value.
     * @return {?}
     */
    /* istanbul ignore next */
    spinUp(delta) { return; }
    ;
    /**
     * Decrements value in editor according to the parameter selects the next item from the drop-down list if [isLimitedToListValues](ui.%%WidgetNameLowered%%#options:isLimitedToListValues) is enabled.
     *
     * @param {?=} delta Decrement value.
     * @return {?}
     */
    /* istanbul ignore next */
    spinDown(delta) { return; }
    ;
    /**
     * This method is deprecated in favor of [spinUp](ui.%%WidgetNameLowered%%#options:spinUp).
     * @return {?}
     */
    /* istanbul ignore next */
    selectListIndexUp() { return; }
    ;
    /**
     * This method is deprecated in favor of [spinDown](ui.%%WidgetNameLowered%%#options:spinDown).
     * @return {?}
     */
    /* istanbul ignore next */
    selectListIndexDown() { return; }
    ;
    /**
     * Gets current regional.
     * @return {?}
     */
    /* istanbul ignore next */
    getRegionalOption() { return; }
    ;
    /**
     * Changes the the regional settings of widget element to the language specified in [options.regional](ui.ignumericeditor#options:regional)
     * Note that this method is for rare scenarios, use [regional](ui.ignumericeditor#options:regional) option setter
     * @return {?}
     */
    /* istanbul ignore next */
    changeRegional() { return; }
    ;
}
IgPercentEditorComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-percent-editor",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "width", "height", "value", "tabIndex", "allowNullValue", "nullValue", "inputName", "readOnly", "validatorOptions", "buttonType", "listItems", "listWidth", "listItemHoverDuration", "dropDownAttachedToBody", "dropDownAnimationDuration", "visibleItemsCount", "includeKeys", "excludeKeys", "textAlign", "placeHolder", "selectionOnFocus", "textMode", "spinWrapAround", "isLimitedToListValues", "revertIfNotValid", "preventSubmitOnEnter", "dropDownOrientation", "maxLength", "dropDownOnReadOnly", "toUpper", "toLower", "locale", "suppressNotifications", "regional", "negativeSign", "negativePattern", "decimalSeparator", "groupSeparator", "groups", "maxDecimals", "minDecimals", "dataMode", "minValue", "maxValue", "spinDelta", "scientificFormat", "positivePattern", "percentSymbol", "displayFactor"],
                outputs: ["rendering", "rendered", "mousedown", "mouseup", "mousemove", "mouseover", "mouseout", "blur", "focus", "keydown", "keypress", "keyup", "valueChanging", "valueChanged", "dropDownListOpening", "dropDownListOpened", "dropDownListClosing", "dropDownListClosed", "dropDownItemSelecting", "dropDownItemSelected", "textChanged"]
            }] }
];
/** @nocollapse */
IgPercentEditorComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef },
    { type: NgModel, decorators: [{ type: Optional }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgTextEditorComponent extends IgEditorBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     * @param {?} model
     */
    constructor(el, renderer, differs, kvalDiffers, cdr, model) {
        super(el, renderer, differs, kvalDiffers, cdr, model);
        this.model = model;
    }
    /**
     * Changes the all locales into the widget element to the language specified in [options.language](ui.igtexteditor#options:language)
     * Note that this method is for rare scenarios, see [language](ui.igtexteditor#options:language) or [locale](ui.igtexteditor#options:locale) option setter
     * @return {?}
     */
    /* istanbul ignore next */
    changeLocale() { return; }
    ;
    /**
     * Gets the visible text in the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    displayValue() { return; }
    ;
    /**
     * Gets reference to jquery object which is used as container of drop-down list.
     * @return {?}
     */
    /* istanbul ignore next */
    dropDownContainer() { return; }
    ;
    /**
     * Shows the drop down list.
     * @return {?}
     */
    /* istanbul ignore next */
    showDropDown() { return; }
    ;
    /**
     * Hides the drop down list.
     * @return {?}
     */
    /* istanbul ignore next */
    hideDropDown() { return; }
    ;
    /**
     * Returns a reference to the drop-down button UI element of the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    dropDownButton() { return; }
    ;
    /**
     * Returns if the drop-down list is visible.
     * @return {?}
     */
    /* istanbul ignore next */
    dropDownVisible() { return; }
    ;
    /**
     * Returns a reference to the clear button UI element of the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    clearButton() { return; }
    ;
    /**
     * Finds index of list item by text that matches with the search parameters.
     *
     * @param {?} text The text to search for in the drop down list.
     * @param {?=} matchType The rule that is applied for searching the text.
     * @return {?}
     */
    /* istanbul ignore next */
    findListItemIndex(text, matchType) { return; }
    ;
    /**
     * Gets the index of the selected list item. Sets selected item by index.
     *
     * @param {?=} index The index of the item that needs to be selected.
     * @return {?}
     */
    /* istanbul ignore next */
    selectedListIndex(index) { return; }
    ;
    /**
     * Gets the selected list item.
     * @return {?}
     */
    /* istanbul ignore next */
    getSelectedListItem() { return; }
    ;
    /**
     * Gets the selected text from the editor in edit mode. This can be done inside key event handlers, like keydown or keyup. This method can be used only when the editor is focused. If you invoke this method in display mode, when the editor input is blurred, the returned value will be an empty string.
     * @return {?}
     */
    /* istanbul ignore next */
    getSelectedText() { return; }
    ;
    /**
     * Gets the start index of the selected text in the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    getSelectionStart() { return; }
    ;
    /**
     * Gets the end index of the selected text in the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    getSelectionEnd() { return; }
    ;
    /**
     * Inserts the text at the location of the caret or over the current selection. If the editor is focused the method will insert the text over the current selection. If the editor is not focused the method will set the text as value of the editor.
     * Note: The method raises [textChanged](ui.igtexteditor#events:textChanged) event.
     *
     * @param {?} string The string to be inserted.
     * @return {?}
     */
    /* istanbul ignore next */
    insert(string) { return; }
    ;
    /**
     * Selects the text between start and end indices in the editor. If the parameters are equal, then the method sets location of caret. The method has effect only when the editor has focus.
     *
     * @param {?} start Start of the selection.
     * @param {?} end End of the selection.
     * @return {?}
     */
    /* istanbul ignore next */
    select(start, end) { return; }
    ;
    /**
     * Selects the previous item from the drop-down list.
     * @return {?}
     */
    /* istanbul ignore next */
    spinUp() { return; }
    ;
    /**
     * Selects the next item from the drop-down list.
     * @return {?}
     */
    /* istanbul ignore next */
    spinDown() { return; }
    ;
    /**
     * Returns a reference to the spin up UI element of the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    spinUpButton() { return; }
    ;
    /**
     * Returns a reference to the spin down UI element of the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    spinDownButton() { return; }
    ;
    /**
     * Gets/Sets name attribute applied to the editor element.
     *
     * @param {?=} newValue The new input name.
     * @return {?}
     */
    /* istanbul ignore next */
    inputName(newValue) { return; }
    ;
    /**
     * @param {?} newValue
     * @return {?}
     */
    value(newValue) { return; }
    ;
    /**
     * Gets the input element of the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    field() { return; }
    ;
    /**
     * Gets a reference to the jQuery element that wraps the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    editorContainer() { return; }
    ;
    /**
     * Gets whether the editor has focus.
     * @return {?}
     */
    /* istanbul ignore next */
    hasFocus() { return; }
    ;
    /**
     * Sets focus to the editor after the specified delay.
     *
     * @param {?=} delay The delay before focusing the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    setFocus(delay) { return; }
    ;
    /**
     * Hides the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    hide() { return; }
    ;
    /**
     * Shows the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    show() { return; }
    ;
    /**
     * Gets a reference to [igValidator](ui.igvalidator) used by the editor.
     * @return {?}
     */
    /* istanbul ignore next */
    validator() { return; }
    ;
    /**
     * Checks if the value in the editor is valid. Note: This function will not trigger automatic notifications.
     * @return {?}
     */
    /* istanbul ignore next */
    isValid() { return; }
    ;
    /**
     * Triggers validation for the editor. If validatorOptions are set will also call validate on the [igValidator](ui.igvalidator).
     * @return {?}
     */
    /* istanbul ignore next */
    validate() { return; }
    ;
    /**
     * Destroys the widget
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
}
IgTextEditorComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-text-editor",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "width", "height", "value", "tabIndex", "allowNullValue", "nullValue", "inputName", "readOnly", "validatorOptions", "buttonType", "listItems", "listWidth", "listItemHoverDuration", "dropDownAttachedToBody", "dropDownAnimationDuration", "visibleItemsCount", "includeKeys", "excludeKeys", "textAlign", "placeHolder", "selectionOnFocus", "textMode", "spinWrapAround", "isLimitedToListValues", "revertIfNotValid", "preventSubmitOnEnter", "dropDownOrientation", "maxLength", "dropDownOnReadOnly", "toUpper", "toLower", "locale", "suppressNotifications"],
                outputs: ["rendering", "rendered", "mousedown", "mouseup", "mousemove", "mouseover", "mouseout", "blur", "focus", "keydown", "keypress", "keyup", "valueChanging", "valueChanged", "dropDownListOpening", "dropDownListOpened", "dropDownListClosing", "dropDownListClosed", "dropDownItemSelecting", "dropDownItemSelected", "textChanged"]
            }] }
];
/** @nocollapse */
IgTextEditorComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef },
    { type: NgModel, decorators: [{ type: Optional }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgTreeComponent extends IgControlBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiffers, cdr) {
        super(el, renderer, differs, kvalDiffers, cdr);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set dataSource(value) {
        this._dataSource = value;
    }
    ;
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.options["dataSource"] && this._dataSource) {
            this.options["dataSource"] = this._dataSource;
        }
        super.ngOnInit();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const ds = "dataSource";
        //const options = "options";
        if (ds in changes) {
            /** @type {?} */
            const value = changes[ds].currentValue;
            if (!this._differ && value) {
                try {
                    this._differ = this._differs.find(value).create();
                    this._changes = [];
                    for (var i = 0; i < this._dataSource.length; i++) {
                        this._changes.push(this.kvalDiffers.find({}).create());
                    }
                }
                catch (e) {
                    throw new Error("Only binding to arrays is supported.");
                }
            }
        }
        super.ngOnChanges(changes);
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this._differ) {
            /** @type {?} */
            const changes = this._differ.diff(this._dataSource);
            //check if grid is initialized
            /** @type {?} */
            const elem = jQuery(this._el).data(this._widgetName);
            if (changes && elem) {
                this.dataSourceApplyChanges(changes);
            }
            if (this._changes && elem) {
                //check recs
                for (var i = 0; i < this._dataSource.length; i++) {
                    /** @type {?} */
                    var item = this._dataSource[i];
                    /** @type {?} */
                    var rowChanges = this._changes[i].diff(item);
                    if (rowChanges) {
                        rowChanges.forEachChangedItem((/**
                         * @param {?} change
                         * @return {?}
                         */
                        (change) => {
                            this.updateItem(item, change.currentValue, change.key);
                        }));
                    }
                }
            }
        }
        super.ngDoCheck();
    }
    /**
     * @param {?} item
     * @param {?} index
     * @return {?}
     */
    addItem(item, index) {
        this.dataBind();
        this._changes.push(this.kvalDiffers.find({}).create());
    }
    /**
     * @param {?} item
     * @param {?} index
     * @return {?}
     */
    deleteItem(item, index) {
        this.dataBind();
        this._changes.splice(index, 1);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    dataSourceApplyChanges(changes) {
        changes.forEachAddedItem((/**
         * @param {?} r
         * @return {?}
         */
        r => this.addItem(r.item, r.currentIndex)));
        changes.forEachRemovedItem((/**
         * @param {?} r
         * @return {?}
         */
        r => { this.deleteItem(r.item, r.previousIndex); }));
    }
    /**
     * @param {?} item
     * @param {?} value
     * @param {?} key
     * @return {?}
     */
    updateItem(item, value, key) {
        this.dataBind();
    }
    /**
     * @return {?}
     */
    markForCheck() {
        super.markForCheck();
        /** @type {?} */
        const bindings = this["bindings"] || this.options.bindings;
        if (bindings && bindings.childDataProperty) {
            this.dataBind();
        }
    }
    // optionChange(options?) {
    // 	var opts = options || jQuery.extend(true, {}, this._config);
    // 	// Bindings are modified internally by the tree. Excluding them from the change detection
    // 	if (opts.bindings) {
    // 		delete opts.bindings;
    // 	}
    // 	super.optionChange(opts);
    // }
    /**
     * Performs databinding on the igTree.
     * @return {?}
     */
    /* istanbul ignore next */
    dataBind() { return; }
    ;
    /**
     * Toggles the checkstate of a node if checkboxMode is not set to off, otherwise does nothing.
     *
     * @param {?} node     Specifies the node element the checkbox of which would be toggled.
     * @param {?=} event     Indicates the browser event which triggered this action, if this is not an API call.
     * @return {?}
     */
    /* istanbul ignore next */
    toggleCheckstate(node, event) { return; }
    ;
    /**
     * Toggles the collapse/expand state for the specified node.
     *
     * @param {?} node     Specifies the node element the checkbox of which would be toggled.
     * @param {?=} event     Indicates the browser event which triggered this action, if this is not an API call.
     * @return {?}
     */
    /* istanbul ignore next */
    toggle(node, event) { return; }
    ;
    /**
     * Expands the tree down to the specified node and selects the node if specified.
     *
     * @param {?} node     Specifies the node element down to which the tree would be expanded.
     * @param {?=} toSelect     Specifies the whether to select the node after expanding to it.
     * @return {?}
     */
    /* istanbul ignore next */
    expandToNode(node, toSelect) { return; }
    ;
    /**
     * Expands the specified node.
     *
     * @param {?} node     Specifies the node element to expand.
     * @return {?}
     */
    /* istanbul ignore next */
    expand(node) { return; }
    ;
    /**
     * Collapses the specified node.
     *
     * @param {?} node     Specifies the node element to collapse.
     * @return {?}
     */
    /* istanbul ignore next */
    collapse(node) { return; }
    ;
    /**
     * Retrieves the parent node element of the specified node element.
     *
     * @param {?} node     Specifies the jQuery selected node element to collapse.
     * @return {?}
     */
    /* istanbul ignore next */
    parentNode(node) { return; }
    ;
    /**
     * Retrieves the jQuery element of the node with the specified path.
     *
     * @param {?} nodePath     Specifies the path to the required node.
     * @return {?}
     */
    /* istanbul ignore next */
    nodeByPath(nodePath) { return; }
    ;
    /**
     * Retrieves the jQuery element of the node with the specified value.
     *
     * @param {?} value     Specifies the value of the required node.
     * @return {?}
     */
    /* istanbul ignore next */
    nodesByValue(value) { return; }
    ;
    /**
     * Retrieves all the node objects for the nodes that have their checkboxes checked.
     * @return {?}
     */
    /* istanbul ignore next */
    checkedNodes() { return; }
    ;
    /**
     * Retrieves all the node objects for the nodes that have their checkboxes unchecked.
     * @return {?}
     */
    /* istanbul ignore next */
    uncheckedNodes() { return; }
    ;
    /**
     * Retrieves all the node objects for the nodes that have their checkboxes partially checked.
     * @return {?}
     */
    /* istanbul ignore next */
    partiallyCheckedNodes() { return; }
    ;
    /**
     * Selects a node.
     *
     * @param {?} node     Specifies the node element to be selected.
     * @param {?=} event     Indicates the browser event which triggered this action, if this is not an API call.
     * @return {?}
     */
    /* istanbul ignore next */
    select(node, event) { return; }
    ;
    /**
     * Deselects the specified node.
     *
     * @param {?} node     Specifies the node element to be deselected.
     * @return {?}
     */
    /* istanbul ignore next */
    deselect(node) { return; }
    ;
    /**
     * Deselects all the selected nodes.
     * @return {?}
     */
    /* istanbul ignore next */
    clearSelection() { return; }
    ;
    /**
     * Retrieves the node object for the selected node.
     * @return {?}
     */
    /* istanbul ignore next */
    selectedNode() { return; }
    ;
    /**
     * Retrieves all node objects with the specified text (case sensitive).
     *
     * @param {?} text     The text to search for.
     * @param {?=} parent     The node element to start the search from. If not specified then search would start from the root of the tree.
     * @return {?}
     */
    /* istanbul ignore next */
    findNodesByText(text, parent) { return; }
    ;
    /**
     * Retrieves all node objects for the immediate children of the specified parent with the specified text (case sensitive).
     *
     * @param {?} text     The text to search for.
     * @param {?=} parent     The node element the children of which would be searched.
     * @return {?}
     */
    /* istanbul ignore next */
    findImmediateNodesByText(text, parent) { return; }
    ;
    /**
     * Retrieves the n-th jQuery node element child of the specified parent.
     *
     * @param {?} index     Specifies the index the node at which to be retrieved.
     * @param {?=} parent     The parent node element to start the search from.
     * @return {?}
     */
    /* istanbul ignore next */
    nodeByIndex(index, parent) { return; }
    ;
    /**
     * Retrieves a node object for the specified node element.
     *
     * @param {?} element     Specifies the node element.
     * @return {?}
     */
    /* istanbul ignore next */
    nodeFromElement(element) { return; }
    ;
    /**
     * Retrieves a node object collection of the immediate children of the provided node element.
     *
     * @param {?} parent     Specifies the node element.
     * @return {?}
     */
    /* istanbul ignore next */
    children(parent) { return; }
    ;
    /**
     * Retrieves a node object collection of the immediate children of the node with the provided path.
     *
     * @param {?} path     Specifies the path of the node the children of which are to be retrieved.
     * @return {?}
     */
    /* istanbul ignore next */
    childrenByPath(path) { return; }
    ;
    /**
     * Returns true if the provided node element is selected and false otherwise.
     *
     * @param {?} node     Specifies the node element.
     * @return {?}
     */
    /* istanbul ignore next */
    isSelected(node) { return; }
    ;
    /**
     * Returns true if the provided node element is expanded and false otherwise.
     *
     * @param {?} node     Specifies the node element.
     * @return {?}
     */
    /* istanbul ignore next */
    isExpanded(node) { return; }
    ;
    /**
     * Returns true if the provided node element has its checkbox checkstate checked and false otherwise.
     *
     * @param {?} node     Specifies the node element.
     * @return {?}
     */
    /* istanbul ignore next */
    isChecked(node) { return; }
    ;
    /**
     * Returns the specified node checkstate.
     *
     * @param {?} node     Specifies the node element.
     * @return {?}
     */
    /* istanbul ignore next */
    checkState(node) { return; }
    ;
    /**
     * Adds a new array of nodes to the tree. New nodes are appended to the root or to a specified parent node, at a specified index.
     *
     * @param {?} node     Specifies the data used to create the new nodeс.
     * @param {?=} parent     Specifies the element of the parent node the nodes are to be appended to.
     * @param {?=} nodeIndex     Specifies the index at which the nodes to be inserted.
     * @return {?}
     */
    /* istanbul ignore next */
    addNode(node, parent, nodeIndex) { return; }
    ;
    /**
     * Removes the node with with the specified path and all of its children.
     *
     * @param {?} path     Specifies the path of the node to be removed.
     * @return {?}
     */
    /* istanbul ignore next */
    removeAt(path) { return; }
    ;
    /**
     * Removing all the nodes with the specified value.
     *
     * @param {?} value     Specifies the value of the nodes to be removed.
     * @return {?}
     */
    /* istanbul ignore next */
    removeNodesByValue(value) { return; }
    ;
    /**
     * Performs a UI update on the provided node element with the provided data.
     *
     * @param {?} element     Specifies the node to be updated.
     * @param {?} data     Specifies the new data item the node would update according to.
     * @return {?}
     */
    /* istanbul ignore next */
    applyChangesToNode(element, data) { return; }
    ;
    /**
     * Returns the transaction log stack.
     * @return {?}
     */
    /* istanbul ignore next */
    transactionLog() { return; }
    ;
    /**
     * Returns the data for the node with specified path.
     *
     * @param {?} path     Specifies the node path for which the data is returned.
     * @return {?}
     */
    /* istanbul ignore next */
    nodeDataFor(path) { return; }
    ;
    /**
     * Destructor for the igTree widget.
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
}
IgTreeComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-tree",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "width", "height", "checkboxMode", "singleBranchExpand", "hotTracking", "parentNodeImageUrl", "parentNodeImageClass", "parentNodeImageTooltip", "leafNodeImageUrl", "leafNodeImageClass", "leafNodeImageTooltip", "animationDuration", "pathSeparator", "dataSource", "dataSourceUrl", "dataSourceType", "responseDataKey", "responseDataType", "requestType", "responseContentType", "initialExpandDepth", "loadOnDemand", "bindings", "defaultNodeTarget", "dragAndDrop", "updateUrl", "dragAndDropSettings"],
                outputs: ["dataBinding", "dataBound", "rendering", "rendered", "selectionChanging", "selectionChanged", "nodeCheckstateChanging", "nodeCheckstateChanged", "nodePopulating", "nodePopulated", "nodeCollapsing", "nodeCollapsed", "nodeExpanding", "nodeExpanded", "nodeClick", "nodeDoubleClick", "dragStart", "drag", "dragStop", "nodeDropping", "nodeDropped"]
            }] }
];
/** @nocollapse */
IgTreeComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];
IgTreeComponent.propDecorators = {
    dataSource: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template Model
 */
class IgContentControlBase extends IgControlBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiffers, cdr) {
        super(el, renderer, differs, kvalDiffers, cdr);
        this.childNodes = el.nativeElement.childNodes;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        jQuery(this._el).append(this.childNodes);
        super.ngOnInit();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgDialogComponent extends IgContentControlBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiffers, cdr) { super(el, renderer, differs, kvalDiffers, cdr); }
    /**
     * Destroys the igDialog and moves the target element to its original parent.
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
    /**
     * Gets/Sets the state of the editor.
     * 				Note: If the state of the dialog changes, then stateChanging and stateChanged events are raised.
     *
     * @param {?=} state     New state.
     * @return {?}
     */
    /* istanbul ignore next */
    state(state) { return; }
    ;
    /**
     * Gets reference to the dynamically created DIV element which represents the dialog.
     * @return {?}
     */
    /* istanbul ignore next */
    mainElement() { return; }
    ;
    /**
     * Closes the dialog if it is opened.
     * 				Notes:
     * 				1. If the state of the dialog changes, then stateChanging and stateChanged events are raised.
     * 				2. That method does not change minimized or maximized state of the dialog.
     * 				It means that method "open" will open the dialog and keep previous minimized or maximized state.
     *
     * @param {?=} e     Browser event: internal use only.
     * @return {?}
     */
    /* istanbul ignore next */
    close(e) { return; }
    ;
    /**
     * Opens the dialog if it is closed. Notes:
     * 				1. If the state of the dialog changes, then stateChanging and stateChanged events are raised.
     * 				2. That method does not change minimized or maximized state of the dialog. It means that if the dialog was in minimized or maximized stated when closed by "close" method, then the dialog will open in minimized or maximized state respectively.
     * @return {?}
     */
    /* istanbul ignore next */
    open() { return; }
    ;
    /**
     * Minimizes the dialog if it is not minimized.
     * 				Note: If the state of the dialog changes, then stateChanging and stateChanged events are raised.
     * @return {?}
     */
    /* istanbul ignore next */
    minimize() { return; }
    ;
    /**
     * Maximizes the dialog if it is not maximized.
     * 				Note: If the state of the dialog changes, then stateChanging and stateChanged events are raised.
     * @return {?}
     */
    /* istanbul ignore next */
    maximize() { return; }
    ;
    /**
     * Sets the normal state for the dialog if it was maximized or minimized.
     * 				Note: If the state of the dialog changes, then stateChanging and stateChanged events are raised.
     * @return {?}
     */
    /* istanbul ignore next */
    restore() { return; }
    ;
    /**
     * Pins the dialog if it is not pinned.
     * 				When the dialog is pinned, then the html element of the dialog is moved to the original container where the target element was located and position:absolute is removed.
     * 				The pinned dialog does not support modal state, maximized state and it can not be moved.
     * 				Notes:
     * 				1. If the parent element of the original target-element is invisible, then the pinned dialog becomes invisible as well.
     * 				2. If the state of the dialog changes, then stateChanging and stateChanged events are raised.
     * @return {?}
     */
    /* istanbul ignore next */
    pin() { return; }
    ;
    /**
     * Unpins the dialog if it is pinned.
     * 				Note: If the state of the dialog changes, then stateChanging and stateChanged events are raised.
     * @return {?}
     */
    /* istanbul ignore next */
    unpin() { return; }
    ;
    /**
     * Gets a reference to the top modal dialog.
     * @return {?}
     */
    /* istanbul ignore next */
    getTopModal() { return; }
    ;
    /**
     * Checks if the dialog is modal and if it is currently active.
     * @return {?}
     */
    /* istanbul ignore next */
    isTopModal() { return; }
    ;
    /**
     * Moves a not modal dialog to the top.
     *
     * @param {?=} e     Original event of browser.
     * @return {?}
     */
    /* istanbul ignore next */
    moveToTop(e) { return; }
    ;
    /**
     * Retrieves the igDialog content container or sets its content to be the new content provided.
     *
     * @param {?=} newContent     The new html content provided as a string. If the parameter is provided then the method acts as a setter.
     * @return {?}
     */
    /* istanbul ignore next */
    content(newContent) { return; }
    ;
}
IgDialogComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-dialog",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "mainElement", "state", "pinned", "closeOnEscape", "showCloseButton", "showMaximizeButton", "showMinimizeButton", "showPinButton", "pinOnMinimized", "imageClass", "headerText", "showHeader", "showFooter", "footerText", "dialogClass", "container", "height", "width", "minHeight", "minWidth", "maxHeight", "maxWidth", "draggable", "position", "resizable", "tabIndex", "openAnimation", "closeAnimation", "zIndex", "modal", "trackFocus", "closeButtonTitle", "minimizeButtonTitle", "maximizeButtonTitle", "pinButtonTitle", "unpinButtonTitle", "restoreButtonTitle", "temporaryUrl", "enableHeaderFocus", "enableDblclick"],
                outputs: ["stateChanging", "stateChanged", "animationEnded", "focus", "blur"]
            }] }
];
/** @nocollapse */
IgDialogComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgSplitterComponent extends IgContentControlBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiffers, cdr) { super(el, renderer, differs, kvalDiffers, cdr); }
    /**
     * Returns the element that represents this widget.
     * @return {?}
     */
    /* istanbul ignore next */
    widget() { return; }
    ;
    /**
     * Expand the specified panel by index.
     *
     * @param {?} index Specifies the index of the panel to expand.
     * @return {?}
     */
    /* istanbul ignore next */
    expandAt(index) { return; }
    ;
    /**
     * Collapse the specified panel.
     *
     * @param {?} index Specifies the index of the panel to collapse.
     * @return {?}
     */
    /* istanbul ignore next */
    collapseAt(index) { return; }
    ;
    /**
     * Retrieves the jQuery element of the first panel.
     * @return {?}
     */
    /* istanbul ignore next */
    firstPanel() { return; }
    ;
    /**
     * Retrieves the jQuery element of the second panel.
     * @return {?}
     */
    /* istanbul ignore next */
    secondPanel() { return; }
    ;
    /**
     * Refresh splitter layout, use this method to re-render the splitter if some changes to the layout are applied.
     * @return {?}
     */
    /* istanbul ignore next */
    refreshLayout() { return; }
    ;
    /**
     * You can set new size of the first panel after the splitter is rendered.
     *
     * @param {?} size Specifies the new size of the first panel.
     * @return {?}
     */
    /* istanbul ignore next */
    setFirstPanelSize(size) { return; }
    ;
    /**
     * You can set new size of the second panel after the splitter is rendered.
     *
     * @param {?} size Specifies the new size of the second panel.
     * @return {?}
     */
    /* istanbul ignore next */
    setSecondPanelSize(size) { return; }
    ;
    /**
     * Destroys the igSplitter widget
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
}
IgSplitterComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-splitter",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "width", "height", "orientation", "panels", "dragDelta", "resizeOtherSplitters"],
                outputs: ["collapsed", "expanded", "resizeStarted", "resizing", "resizeEnded", "layoutRefreshing", "layoutRefreshed"]
            }] }
];
/** @nocollapse */
IgSplitterComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgLayoutManagerComponent extends IgContentControlBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiffers, cdr) { super(el, renderer, differs, kvalDiffers, cdr); }
    /**
     * Triggers recalculation of the layout dimensions. Layouts may not need to be reflowed manually, if their sizes are in percentages (i.e. they are responsive by default)
     *                     this can be particularly useful with a grid layout, when the container has percentage sizes, but items are calculated in pixels and positioned absolutely in the container.
     *
     * @param {?=} forceReflow Indicates whether the reflow should be forced. Useful in cases where the items size and position was changed manually.
     * @param {?=} animationDuration The animation duration to be used for this reflow only. Supported only for Grid Layout mode.
     * @param {?=} event Indicates the browser even which triggered this action (not API).
     * @return {?}
     */
    /* istanbul ignore next */
    reflow(forceReflow, animationDuration, event) { return; }
    ;
    /**
     * Destroy is part of the jQuery UI widget API and does the following:
     *                     1. Remove custom CSS classes that were added.
     *                     2. Remove any elements that were added at widget's initialization and after that, which didn't below to the original markup
     *                     3. Unbind all events that were bound.
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
}
IgLayoutManagerComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-layout-manager",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "borderLayout", "gridLayout", "height", "itemCount", "items", "layoutMode", "width"],
                outputs: ["internalResized", "internalResizing", "itemRendered", "itemRendering", "rendered"]
            }] }
];
/** @nocollapse */
IgLayoutManagerComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgTileManagerComponent extends IgContentControlBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiffers, cdr) {
        super(el, renderer, differs, kvalDiffers, cdr);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set dataSource(value) {
        this._dataSource = value;
        /** @type {?} */
        const widget = jQuery(this._el).data(this._widgetName);
        if (widget) {
            jQuery(this._el)[this._widgetName]("option", "dataSource", this._dataSource);
        }
    }
    ;
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this._dataSource === null || this._dataSource === undefined) {
            this._dataSource = this.options["dataSource"];
        }
        if (!this.options["dataSource"] && this._dataSource) {
            this.options["dataSource"] = this._dataSource;
        }
        super.ngOnInit();
    }
    /**
     * Maximizes a given tile.
     *
     * @param {?} $tileToMaximize Specifies the jQuery object of the tile element to be maximized.
     * @param {?=} animDuration Specifies the animation duration for this maximizing.
     * @param {?=} event Indicates the browser even which triggered this action (not API).
     * @return {?}
     */
    /* istanbul ignore next */
    maximize($tileToMaximize, animDuration, event) { return; }
    ;
    /**
     * Minimizes the maximized tile. Has no effect if no maximized tile is present.
     *
     * @param {?=} animDuration Specifies the animation duration for this minimize.
     * @param {?=} event Indicates the browser even which triggered this action (not API).
     * @return {?}
     */
    /* istanbul ignore next */
    minimize(animDuration, event) { return; }
    ;
    /**
     * Returns the maximized tile or null if such is not present.
     * @return {?} object|null Returns the maximized tile or null if such is not present.
     */
    /* istanbul ignore next */
    maximizedTile() { return; }
    ;
    /**
     * Returns an array with the tiles in minimized state or null if such are not present.
     * @return {?} object|null Returns an array with the tiles in minimized state or null if such are not present.
     */
    /* istanbul ignore next */
    minimizedTiles() { return; }
    ;
    /**
     * Returns the splitter associated with this tile manager or
     *                 null if the tile manager was instantiated with maximizedTileIndex.
     * @return {?} object|null Returns the splitter associated with this tile manager or null if the tile manager was instantiated with maximizedTileIndex.
     */
    /* istanbul ignore next */
    splitter() { return; }
    ;
    /**
     * Returns the [layout manager](ui.iglayoutmanager) associated with current tile manager.
     * @return {?}
     */
    /* istanbul ignore next */
    layoutManager() { return; }
    ;
    /**
     * Reflow the tile manager. Rearranging the tiles to fit in the container
     *
     * @param {?=} forceReflow Indicates whether the reflow should be forced. Useful in cases where the items size and position was changed manually.
     * @param {?=} animationDuration The animation duration to be used for this reflow only.
     * @param {?=} event Indicates the browser even which triggered this action (not API).
     * @return {?}
     */
    /* istanbul ignore next */
    reflow(forceReflow, animationDuration, event) { return; }
    ;
    /**
     * Returns the element that represents this widget.
     * @return {?}
     */
    /* istanbul ignore next */
    widget() { return; }
    ;
    /**
     * Causes the TileManager to data bind to the data source (local or remote) , and re-render all of the data as well.
     * @return {?}
     */
    /* istanbul ignore next */
    dataBind() { return; }
    ;
    /**
     * Deletes the widget instance (client object). It is no longer accessible and all its event handlers stop working. Destroys all child widgets. Removes auto-generated HTML content, which is outside the widget, e.g. detached popups, dropdowns, etc.
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
}
IgTileManagerComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-tile-manager",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "width", "height", "columnWidth", "columnHeight", "cols", "rows", "marginLeft", "marginTop", "rearrangeItems", "items", "dataSource", "minimizedState", "maximizedState", "maximizedTileIndex", "rightPanelCols", "rightPanelTilesWidth", "rightPanelTilesHeight", "showRightPanelScroll", "splitterOptions", "preventMaximizingSelector", "animationDuration", "dataSourceUrl", "responseDataKey", "responseDataType", "dataSourceType", "requestType", "responseContentType"],
                outputs: ["dataBinding", "dataBound", "rendering", "rendered", "tileRendering", "tileRendered", "tileMaximizing", "tileMaximized", "tileMinimizing", "tileMinimized"]
            }] }
];
/** @nocollapse */
IgTileManagerComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];
IgTileManagerComponent.propDecorators = {
    dataSource: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgHtmlEditorComponent extends IgControlBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} model
     * @param {?} zone
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(el, renderer, differs, model, zone, kvalDiffers, cdr) {
        super(el, renderer, differs, kvalDiffers, cdr);
        this.model = model;
        this.zone = zone;
        this.onChange = (/**
         * @param {?} _
         * @return {?}
         */
        (_) => {
        });
        this.onTouched = (/**
         * @return {?}
         */
        () => {
        });
        if (model) {
            model.valueAccessor = this;
            this._zone = zone;
            this._model = model;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        /** @type {?} */
        let that = this;
        if (this._model) {
            /** @type {?} */
            var iframe = jQuery(this._el).find("iframe")[0].contentWindow.document;
            jQuery(iframe).find("body[contenteditable=true]").on("keyup", (/**
             * @param {?} evt
             * @param {?} ui
             * @return {?}
             */
            function (evt, ui) {
                that._model.viewToModelUpdate(jQuery(evt.target).html());
                that._zone.run((/**
                 * @return {?}
                 */
                () => {
                    that._model.viewToModelUpdate(jQuery(evt.target).html());
                }));
            }));
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (!!jQuery(this._el).data(this._widgetName) && value !== null && value !== jQuery(this._el)[this._widgetName]("getContent", "html")) {
            jQuery(this._el)[this._widgetName]("setContent", value, "html");
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * Returns the element on which the widget was instantiated
     * @return {?}
     */
    /* istanbul ignore next */
    widget() { return; }
    ;
    /**
     * Resizes the height of the workspace
     * @return {?}
     */
    /* istanbul ignore next */
    resizeWorkspace() { return; }
    ;
    /**
     * Gets the content of the html editor.
     *
     * @param {?} format Returns the content as html or plain text. Values can be "text" or "html".
     * @return {?}
     */
    /* istanbul ignore next */
    getContent(format) { return; }
    ;
    /**
     * Sets the content of the html editor.
     *
     * @param {?} content The content which will be set.
     * @param {?} format The content type: "text" or "html".
     * @return {?}
     */
    /* istanbul ignore next */
    setContent(content, format) { return; }
    ;
    /**
     * Destroys the widget.
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
    /**
     * Executes htmleditor commands.
     *
     * @param {?} actionName The command name.
     * @param {?=} args Additional parameter for the command.
     * @return {?}
     */
    /* istanbul ignore next */
    executeAction(actionName, args) { return; }
    ;
    /**
     * Returns true/false if the editor contents were modified or not.
     * @return {?}
     */
    /* istanbul ignore next */
    isDirty() { return; }
    ;
    /**
     * Returns the window object associated with the Html Editor's content editable area
     * @return {?}
     */
    /* istanbul ignore next */
    contentWindow() { return; }
    ;
    /**
     * Returns the document object associated with the Html Editor's content editable area
     * @return {?}
     */
    /* istanbul ignore next */
    contentDocument() { return; }
    ;
    /**
     * Returns the content editable associated with this Html Editor
     * @return {?}
     */
    /* istanbul ignore next */
    contentEditable() { return; }
    ;
    /**
     * Returns Selection object that represent the current selection in the content editable
     * @return {?}
     */
    /* istanbul ignore next */
    selection() { return; }
    ;
    /**
     * Returns Range object that represent the current range in the content editable
     * @return {?}
     */
    /* istanbul ignore next */
    range() { return; }
    ;
    /**
     * Inserts the provided content at the position of the caret.
     *
     * @param {?} element Accepts html string, DOM element or a jQuery object.
     * @return {?}
     */
    /* istanbul ignore next */
    insertAtCaret(element) { return; }
    ;
}
IgHtmlEditorComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-html-editor",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "showFormattingToolbar", "showTextToolbar", "showInsertObjectToolbar", "showCopyPasteToolbar", "width", "height", "toolbarSettings", "customToolbars", "inputName", "value"],
                outputs: ["rendered", "rendering", "actionExecuting", "actionExecuted", "toolbarCollapsing", "toolbarCollapsed", "toolbarExpanding", "toolbarExpanded", "cut", "copy", "paste", "undo", "redo", "workspaceResized"]
            }] }
];
/** @nocollapse */
IgHtmlEditorComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: NgModel, decorators: [{ type: Optional }] },
    { type: NgZone },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgValidatorComponent extends IgControlBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiffers, cdr) {
        super(el, renderer, differs, kvalDiffers, cdr);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        var evtName;
        this._el = jQuery(document).find("#" + this.widgetId);
        jQuery(this._el)[this._widgetName](this.options);
        this._events = new Map();
        //events binding
        /** @type {?} */
        let that = this;
        for (var propt in jQuery.ui[this._widgetName].prototype.events) {
            evtName = this._widgetName.toLowerCase() + propt.toLowerCase();
            this._events[evtName] = propt;
            jQuery(this._el).on(evtName, (/**
             * @param {?} evt
             * @param {?} ui
             * @return {?}
             */
            function (evt, ui) {
                that[that._events[evt.type]].emit({ event: evt, ui: ui });
            }));
        }
    }
    /**
     * Trigger validation and show errors for invalid fields.
     *
     * @param {?=} field    Optional field object, its selector or zero-based index to check. Only has effect with fields collection and skips other fields.
     * @return {?}
     */
    /* istanbul ignore next */
    validate(field) { return; }
    ;
    /**
     * Trigger validation but do not display error messages.
     *
     * @param {?=} field    Optional field object, its selector or zero-based index to check. Only has effect with fields collection and skips other fields.
     * @return {?}
     */
    /* istanbul ignore next */
    isValid(field) { return; }
    ;
    /**
     * Hide any possible message(s) (either messageTarget or igNotifier).
     * 			Note: When the validator has a fields colleciton, not passing a field will hide messages on all fields.
     *
     * @param {?=} field    Optional field object, its selector or zero-based index to hide message for.
     * @return {?}
     */
    /* istanbul ignore next */
    hide(field) { return; }
    ;
    /**
     * Gets all current error messages for invalid field(s). Note that this method does not valdiate and states and messages are only updated on validation, so
     * 			this can be used on formValidated event or after validate/isValid method calls.
     *
     * @param {?=} field    Optional field object, selector or zero-based index for a single field to get error message for.
     * @return {?}
     */
    /* istanbul ignore next */
    getErrorMessages(field) { return; }
    ;
    /**
     * Check for currently displayed message(s). Takes an optional field.
     * 			Note: When the validator has a fields colleciton, not passing a field will return a cumulative true even if just one field has a visible message.
     *
     * @param {?=} field    Optional field object, selector or zero-based index for a single field to get error message for.
     * @return {?}
     */
    /* istanbul ignore next */
    isMessageDisplayed(field) { return; }
    ;
    /**
     * Gets the notifier for the igValidator or for a single filed.
     *
     * @param {?=} field    Optional field object, its selector or zero-based index to get notifier for.
     * @return {?}
     */
    /* istanbul ignore next */
    notifier(field) { return; }
    ;
    /**
     * Adds an new input to the fields collection and initializes it with the validator. Note: Additional fields are only accepted if the validator has been created with the collection.
     *
     * @param {?} field    An object with the field selector and options.
     * @return {?}
     */
    /* istanbul ignore next */
    addField(field) { return; }
    ;
    /**
     * Removes an input from the fields collection.
     *
     * @param {?} field    The field object to remove, its zero-based index or selector.
     * @return {?}
     */
    /* istanbul ignore next */
    removeField(field) { return; }
    ;
    /**
     * Updates a field in the validator collection. Used to reinitialize field in case a control has been created after the validator or to pass in new options.
     *
     * @param {?} field    The field object to update, its zero-based index or selector.
     * @param {?=} fieldOptions    New options to apply to the field.
     * @return {?}
     */
    /* istanbul ignore next */
    updateField(field, fieldOptions) { return; }
    ;
    /**
     * Destroys the validator widget.
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
}
IgValidatorComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-validator",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "onchange", "onblur", "onsubmit", "required", "number", "date", "email", "lengthRange", "valueRange", "creditCard", "pattern", "messageTarget", "errorMessage", "successMessage", "threshold", "equalTo", "custom", "fields", "notificationOptions", "requiredIndication", "optionalIndication"],
                outputs: ["validating", "validated", "success", "error", "errorShowing", "errorHiding", "errorShown", "errorHidden", "successShowing", "successHiding", "successShown", "successHidden", "formValidating", "formValidated", "formError", "formSuccess"]
            }] }
];
/** @nocollapse */
IgValidatorComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgPivotDataSelectorComponent extends IgControlBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiffers, cdr) { super(el, renderer, differs, kvalDiffers, cdr); }
    /**
     * @return {?}
     */
    option() { return; }
    ;
    /**
     * @param {?} value
     * @return {?}
     */
    set dataSource(value) {
        this._dataSource = value;
        /** @type {?} */
        const widget = jQuery(this._el).data(this._widgetName);
        if (widget) {
            jQuery(this._el)[this._widgetName]("option", "dataSource", this._dataSource);
        }
    }
    ;
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this._dataSource === null || this._dataSource === undefined) {
            this._dataSource = this.options["dataSource"];
        }
        if (!this.options["dataSource"] && this._dataSource) {
            this.options["dataSource"] = this._dataSource;
        }
        super.ngOnInit();
    }
    /**
     * Updates the data source.
     * @return {?}
     */
    /* istanbul ignore next */
    update() { return; }
    ;
    /**
     * Destroy is part of the jQuery UI widget API and does the following:
     *                 1. Remove custom CSS classes that were added.
     *                 2. Unwrap any wrapping elements such as scrolling divs and other containers.
     *                 3. Unbind all events that were bound.
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
}
IgPivotDataSelectorComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-pivot-data-selector",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "width", "height", "dataSource", "dataSourceOptions", "deferUpdate", "dragAndDropSettings", "dropDownParent", "disableRowsDropArea", "disableColumnsDropArea", "disableMeasuresDropArea", "disableFiltersDropArea", "customMoveValidation"],
                outputs: ["dataSelectorRendered", "dataSourceInitialized", "dataSourceUpdated", "deferUpdateChanged", "dragStart", "drag", "dragStop", "metadataDropping", "metadataDropped", "metadataRemoving", "metadataRemoved", "filterDropDownOpening", "filterDropDownOpened", "filterMembersLoaded", "filterDropDownOk", "filterDropDownClosing", "filterDropDownClosed"]
            }] }
];
/** @nocollapse */
IgPivotDataSelectorComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];
IgPivotDataSelectorComponent.propDecorators = {
    dataSource: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgPivotGridComponent extends IgControlBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiffers, cdr) { super(el, renderer, differs, kvalDiffers, cdr); }
    /**
     * @return {?}
     */
    option() { return; }
    ;
    /**
     * @param {?} value
     * @return {?}
     */
    set dataSource(value) {
        this._dataSource = value;
        /** @type {?} */
        const widget = jQuery(this._el).data(this._widgetName);
        if (widget) {
            jQuery(this._el)[this._widgetName]("option", "dataSource", this._dataSource);
        }
    }
    ;
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this._dataSource === null || this._dataSource === undefined) {
            this._dataSource = this.options["dataSource"];
        }
        if (!this.options["dataSource"] && this._dataSource) {
            this.options["dataSource"] = this._dataSource;
        }
        super.ngOnInit();
    }
    /**
     * Returns the igGrid instance used to render the OLAP data.
     * @return {?}
     */
    /* istanbul ignore next */
    grid() { return; }
    ;
    /**
     * Triggers an update on the data source and the igPivotGrid.
     * @return {?}
     */
    /* istanbul ignore next */
    updateGrid() { return; }
    ;
    /**
     * Expands a member from the data source and returns true if the expand succeeds. If the data source has a pending update, the method will return false. Note that igPivotGrid to will display the expanded result after the data source is updated.
     *
     * @param {?} tupleLocation The name of the parent axis - 'columnAxis' or 'rowAxis'.
     * @param {?} tupleIndex The index of the containing tuple. This index should correspond to the position of the tuple in the original unsorted result of the data source.
     * @param {?} memberIndex The index of the member in the tuple. This index should correspond to the position of the member in the original unsorted result of the data source.
     * @param {?=} shouldUpdate A flag indicating whether the data source should be updated after the expand.
     * @return {?}
     */
    /* istanbul ignore next */
    expandTupleMember(tupleLocation, tupleIndex, memberIndex, shouldUpdate) { return; }
    ;
    /**
     * Collapses a member from the data source and returns true if the collapse succeeds. If the data source has a pending update, the method will return false. Note that igPivotGrid to will display the expanded result after the data source is updated.
     *
     * @param {?} tupleLocation The name of the parent axis - 'columnAxis' or 'rowAxis'.
     * @param {?} tupleIndex The index of the containing tuple. This index should correspond to the position of the tuple in the original unsorted result of the data source.
     * @param {?} memberIndex The index of the member in the tuple. This index should correspond to the position of the member in the original unsorted result of the data source.
     * @param {?=} shouldUpdate A flag indicating whether the data source should be updated after the expand.
     * @return {?}
     */
    /* istanbul ignore next */
    collapseTupleMember(tupleLocation, tupleIndex, memberIndex, shouldUpdate) { return; }
    ;
    /**
     * Returns an array with the applied sort directions on the igPivotGrid's columns. The returned array contains objects with the following properties:
     *             memberNames: The names of the members in the tuple.
     *             tupleIndex: The index of the tuple on the column axis in the original unsorted result.
     *             sortDirection: The direction of the sort - ascending or descending.
     * @return {?}
     */
    /* istanbul ignore next */
    appliedColumnSortDirections() { return; }
    ;
    /**
     * Returns an array with the applied level sort direction items, which were used for the sorting of the header cells. The returned array contains objects with the following properties:
     *             levelUniqueName: Specifies the unique name of the level, which was sorted.
     *             sortDirection: The direction of the header sort - ascending or descending.
     * @return {?}
     */
    /* istanbul ignore next */
    appliedLevelSortDirections() { return; }
    ;
    /**
     * Destroy is part of the jQuery UI widget API and does the following:
     *             1. Remove custom CSS classes that were added.
     *             2. Unwrap any wrapping elements such as scrolling divs and other containers.
     *             3. Unbind all events that were bound.
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
}
IgPivotGridComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-pivot-grid",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "width", "height", "dataSource", "dataSourceOptions", "deferUpdate", "isParentInFrontForColumns", "isParentInFrontForRows", "compactColumnHeaders", "compactRowHeaders", "rowHeadersLayout", "compactColumnHeaderIndentation", "compactRowHeaderIndentation", "rowHeaderLinkGroupIndentation", "treeRowHeaderIndentation", "defaultRowHeaderWidth", "allowSorting", "firstSortDirection", "allowHeaderRowsSorting", "allowHeaderColumnsSorting", "levelSortDirections", "defaultLevelSortBehavior", "firstLevelSortDirection", "gridOptions", "dragAndDropSettings", "dropDownParent", "disableRowsDropArea", "disableColumnsDropArea", "disableMeasuresDropArea", "disableFiltersDropArea", "hideRowsDropArea", "hideColumnsDropArea", "hideMeasuresDropArea", "hideFiltersDropArea", "customMoveValidation"],
                outputs: ["dataSourceInitialized", "dataSourceUpdated", "pivotGridHeadersRendered", "pivotGridRendered", "tupleMemberExpanding", "tupleMemberExpanded", "tupleMemberCollapsing", "tupleMemberCollapsed", "sorting", "sorted", "headersSorting", "headersSorted", "dragStart", "drag", "dragStop", "metadataDropping", "metadataDropped", "metadataRemoving", "metadataRemoved", "filterDropDownOpening", "filterDropDownOpened", "filterMembersLoaded", "filterDropDownOk", "filterDropDownClosing", "filterDropDownClosed"]
            }] }
];
/** @nocollapse */
IgPivotGridComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];
IgPivotGridComponent.propDecorators = {
    dataSource: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgDataChartComponent extends IgControlBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiffers, cdr) { super(el, renderer, differs, kvalDiffers, cdr); }
    /**
     * @param {?} value
     * @return {?}
     */
    set dataSource(value) {
        this._dataSource = value;
        /** @type {?} */
        const chart = jQuery(this._el).data(this._widgetName);
        if (chart) {
            jQuery(this._el)[this._widgetName]("option", "dataSource", this._dataSource);
        }
    }
    ;
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this._dataSource === null || this._dataSource === undefined) {
            this._dataSource = this.options["dataSource"];
        }
        if (!this.options["dataSource"] && this._dataSource) {
            this.options["dataSource"] = this._dataSource;
        }
        super.ngOnInit();
    }
    /**
     * @return {?}
     */
    option() { return; }
    ;
    /**
     * Returns the element holding the chart.
     * @return {?}
     */
    /* istanbul ignore next */
    widget() { return; }
    ;
    /**
     * Returns the ID of parent element holding the chart.
     * @return {?}
     */
    /* istanbul ignore next */
    id() { return; }
    ;
    /**
     * Exports the chart to a PNG image.
     *
     * @param {?=} width     The width of the image.
     * @param {?=} height     The height of the image.
     * @return {?}
     */
    /* istanbul ignore next */
    exportImage(width, height) { return; }
    ;
    /**
     * Destroys the widget.
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
    /**
     * Notify the chart that styles it draws colors from may have been updated.
     * @return {?}
     */
    /* istanbul ignore next */
    styleUpdated() { return; }
    ;
    /**
     * Resets the zoom level of the chart to default.
     * @return {?}
     */
    /* istanbul ignore next */
    resetZoom() { return; }
    ;
    /**
     * Adds a new item to the data source and notifies the chart.
     *
     * @param {?} item     The item that we want to add to the data source.
     * @param {?} targetName     The name of the series or axis bound to the data source. This is required only when the data is bound to series or axis. If the data is bound to dataSource of igDataChart, the second parameter should not be set.
     * @return {?}
     */
    /* istanbul ignore next */
    addItem(item, targetName) { return; }
    ;
    /**
     * Inserts a new item to the data source and notifies the chart.
     *
     * @param {?} item     the new item that we want to insert in the data source.
     * @param {?} index     The index in the data source where the new item will be inserted.
     * @param {?} targetName     The name of the series or axis bound to the data source.
     * @return {?}
     */
    /* istanbul ignore next */
    insertItem(item, index, targetName) { return; }
    ;
    /**
     * Deletes an item from the data source and notifies the chart.
     *
     * @param {?} index     The index in the data source from where the item will be been removed.
     * @param {?} targetName     The name of the series or axis bound to the data source. This is required only when the data is bound to series or axis. If the data is bound to dataSource of igDataChart, the second parameter should not be set.
     * @return {?}
     */
    /* istanbul ignore next */
    removeItem(index, targetName) { return; }
    ;
    /**
     * Updates an item in the data source and notifies the chart.
     *
     * @param {?} index     The index of the item in the data source that we want to change.
     * @param {?} item     The new item object that will be set in the data source.
     * @param {?} targetName     The name of the series or axis bound to the data source.
     * @return {?}
     */
    /* istanbul ignore next */
    setItem(index, item, targetName) { return; }
    ;
    /**
     * Notifies the chart that an item has been set in an associated data source.
     *
     * @param {?} dataSource     The data source in which the change happened.
     * @param {?} index     The index in the items source that has been changed.
     * @param {?} newItem     the new item that has been set in the collection.
     * @param {?} oldItem     the old item that has been overwritten in the collection.
     * @return {?}
     */
    /* istanbul ignore next */
    notifySetItem(dataSource, index, newItem, oldItem) { return; }
    ;
    /**
     * Notifies the chart that the items have been cleared from an associated data source.
     * 				It's not necessary to notify more than one target of a change if they share the same items source.
     *
     * @param {?} dataSource     The data source in which the change happened.
     * @return {?}
     */
    /* istanbul ignore next */
    notifyClearItems(dataSource) { return; }
    ;
    /**
     * Notifies the target axis or series that an item has been inserted at the specified index in its data source.
     * 				It's not necessary to notify more than one target of a change if they share the same items source.
     *
     * @param {?} dataSource     The data source in which the change happened.
     * @param {?} index     The index in the items source where the new item has been inserted.
     * @param {?} newItem     the new item that has been set in the collection.
     * @return {?}
     */
    /* istanbul ignore next */
    notifyInsertItem(dataSource, index, newItem) { return; }
    ;
    /**
     * Notifies the target axis or series that an item has been removed from the specified index in its data source.
     * 				It's not necessary to notify more than one target of a change if they share the same items source.
     *
     * @param {?} dataSource     The data source in which the change happened.
     * @param {?} index     The index in the items source from where the old item has been removed.
     * @param {?} oldItem     the old item that has been removed from the collection.
     * @return {?}
     */
    /* istanbul ignore next */
    notifyRemoveItem(dataSource, index, oldItem) { return; }
    ;
    /**
     * Notifies the target axis or series that it should scroll the requested data item into view.
     *
     * @param {?} targetName     The name of the axis or series notify.
     * @param {?} item     The data item to bring into view, if possible.
     * @return {?}
     */
    /* istanbul ignore next */
    scrollIntoView(targetName, item) { return; }
    ;
    /**
     * Notifies the target axis that it should scale the requested value into chart space from axis space.
     * 				For example you can use this method if you want to find where value 50 of the x axis stands scaled to chart's width.
     *
     * @param {?} targetName     The name of the axis to notify.
     * @param {?} unscaledValue     The value in axis space to translate into chart space.
     * @return {?}
     */
    /* istanbul ignore next */
    scaleValue(targetName, unscaledValue) { return; }
    ;
    /**
     * Notifies the target axis that it should unscale the requested value into axis space from chart space.
     * 				For example you can use this method if you want to find what is the value of x axis unscaled from 0 width of the chart.
     *
     * @param {?} targetName     The name of the axis to notify.
     * @param {?} scaledValue     The value in chart space to translate into axis space.
     * @return {?}
     */
    /* istanbul ignore next */
    unscaleValue(targetName, scaledValue) { return; }
    ;
    /**
     * For the target axis, if using enhanced interval management and precise interval fitting, this will reset the cached maximum label width, and recalculate using the current labels.
     *
     * @param {?} targetName     The name of the axis to notify.
     * @return {?}
     */
    /* istanbul ignore next */
    resetCachedEnhancedInterval(targetName) { return; }
    ;
    /**
     * Notifies the target series that something that affects its visual properties has changed and the visual output needs a repaint.
     *
     * @param {?} targetName     The name of the series to notify.
     * @return {?}
     */
    /* istanbul ignore next */
    notifyVisualPropertiesChanged(targetName) { return; }
    ;
    /**
     * Forces any pending deferred work to render on the chart before continuing
     * @return {?}
     */
    /* istanbul ignore next */
    flush() { return; }
    ;
    /**
     * Exports visual data from the chart to aid in unit testing
     * @return {?}
     */
    /* istanbul ignore next */
    exportVisualData() { return; }
    ;
    /**
     * Gets the actual minimum value of the target numeric or date time axis
     *
     * @param {?} targetName    The name of the axis from which to get the minimum value.
     * @return {?}
     */
    /* istanbul ignore next */
    getActualMinimumValue(targetName) { return; }
    ;
    /**
     * Gets the actual maximum value of the target numeric or date time axis
     *
     * @param {?} targetName    The name of the axis from which to get the maximum value.
     * @return {?}
     */
    /* istanbul ignore next */
    getActualMaximumValue(targetName) { return; }
    ;
    /**
     * Gets the actual interval of the target numeric or date time axis
     *
     * @param {?} targetName    The name of the axis from which to get the interval.
     * @return {?}
     */
    /* istanbul ignore next */
    getActualInterval(targetName) { return; }
    ;
    /**
     * Creates a print preview page with the chart, hiding all other elements on the page.
     * @return {?}
     */
    /* istanbul ignore next */
    print() { return; }
    ;
    /**
     * Indicates that a series should render, even though no option has been modified that would normally cause it to refresh.
     *
     * @param {?} targetName     The name of the series to render.
     * @param {?} animate     Whether the change should be animated, if possible.
     * @return {?}
     */
    /* istanbul ignore next */
    renderSeries(targetName, animate) { return; }
    ;
    /**
     * Gets the item item index associated with the specified world position.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} worldPoint    The world position (in the form {x: [number from 0 to 1], y: [number from 0 to 1]} ) that represents a position in the space of the axes.
     * @return {?}
     */
    /* istanbul ignore next */
    getItemIndex(targetName, worldPoint) { return; }
    ;
    /**
     * Gets the item that is the best match for the specified world coordinates.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} worldPoint    The world position (in the form {x: [number from 0 to 1], y: [number from 0 to 1]} ) that represents a position in the space of the axes.
     * @return {?}
     */
    /* istanbul ignore next */
    getItem(targetName, worldPoint) { return; }
    ;
    /**
     * For a category plotted series, gets the current width of the items within the categories. This only returns a value if the items have some form of width (e.g. columns, bars, etc.) otherwise 0 is returned.
     *
     * @param {?} targetName    The name of the series to target.
     * @return {?}
     */
    /* istanbul ignore next */
    getItemSpan(targetName) { return; }
    ;
    /**
     * If possible, will return the best available main value of the series for a given world coordinate.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} worldPoint    The world position (in the form {x: [number from 0 to 1], y: [number from 0 to 1]} ) that represents a position in the space of the axes.
     * @param {?} useInterpolation    If true, interpolation should be used to get in-between values, rather than only the actual values in the data set.
     * @param {?} skipUnknowns    If true, unknown values should be skipped.
     * @return {?}
     */
    /* istanbul ignore next */
    getSeriesValue(targetName, worldPoint, useInterpolation, skipUnknowns) { return; }
    ;
    /**
     * If possible, will return the best available value bounding box within the series that has the best value match for the world position provided.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} worldPoint    The world position (in the form {x: [number from 0 to 1], y: [number from 0 to 1]} ) that represents a position in the space of the axes.
     * @return {?}
     */
    /* istanbul ignore next */
    getSeriesValueBoundingBox(targetName, worldPoint) { return; }
    ;
    /**
     * If possible, will return the best available value fine grained bounding boxes within the series that have the best value match for the world position provided.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} worldPoint    The world position (in the form {x: [number from 0 to 1], y: [number from 0 to 1]} ) that represents a position in the space of the axes.
     * @return {?}
     */
    /* istanbul ignore next */
    getSeriesValueFineGrainedBoundingBoxes(targetName, worldPoint) { return; }
    ;
    /**
     * If possible, will return the best available main value position of the series for a given world coordinate.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} worldPoint    The world position (in the form {x: [number from 0 to 1], y: [number from 0 to 1]} ) that represents a position in the space of the axes.
     * @param {?} useInterpolation    If true, interpolation should be used to get in-between values, rather than only the actual values in the data set.
     * @param {?} skipUnknowns    If true, unknown values should be skipped.
     * @return {?}
     */
    /* istanbul ignore next */
    getSeriesValuePosition(targetName, worldPoint, useInterpolation, skipUnknowns) { return; }
    ;
    /**
     * If possible, will return the best available main value position of the series for a given world coordinate.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} seriesPoint    The series pixel position (in the form {x: [number], y: [number]} that represents a position within the pixel space of the series.
     * @param {?} useInterpolation    If true, interpolation should be used to get in-between values, rather than only the actual values in the data set.
     * @param {?} skipUnknowns    If true, unknown values should be skipped.
     * @return {?}
     */
    /* istanbul ignore next */
    getSeriesValuePositionFromSeriesPixel(targetName, seriesPoint, useInterpolation, skipUnknowns) { return; }
    ;
    /**
     * If possible, will return the best available main value of the series for a given world coordinate.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} seriesPoint    The series pixel position (in the form {x: [number], y: [number]} ) that represents a position in the pixel space of the series.
     * @param {?} useInterpolation    If true, interpolation should be used to get in-between values, rather than only the actual values in the data set.
     * @param {?} skipUnknowns    If true, unknown values should be skipped.
     * @return {?}
     */
    /* istanbul ignore next */
    getSeriesValueFromSeriesPixel(targetName, seriesPoint, useInterpolation, skipUnknowns) { return; }
    ;
    /**
     * If possible, will return the best available value bounding box within the series that has the best value match for the given series pixel coordinate.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} seriesPoint    The series pixel position (in the form {x: [number], y: [number]} ) that represents a position in the pixel space of the series.
     * @return {?}
     */
    /* istanbul ignore next */
    getSeriesValueBoundingBoxFromSeriesPixel(targetName, seriesPoint) { return; }
    ;
    /**
     * If possible, will return the best available value fine grained bounding boxes within the series that have the best value match for series pixel position provided.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} worldPoint    The series pixel position (in the form {x: [number], y: [number]} ) that represents a position in the pixel space of the series.
     * @return {?}
     */
    /* istanbul ignore next */
    getSeriesValueFineGrainedBoundingBoxesFromSeriesPixel(targetName, worldPoint) { return; }
    ;
    /**
     * If possible, will return the best available high value of the series for a given world coordinate.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} worldPoint    The world position (in the form {x: [number from 0 to 1], y: [number from 0 to 1]} ) that represents a position in the space of the axes.
     * @param {?} useInterpolation    If true, interpolation should be used to get in-between values, rather than only the actual values in the data set.
     * @param {?} skipUnknowns    If true, unknown values should be skipped.
     * @return {?}
     */
    /* istanbul ignore next */
    getSeriesHighValue(targetName, worldPoint, useInterpolation, skipUnknowns) { return; }
    ;
    /**
     * If possible, will return the best available high value position of the series for a given world coordinate.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} worldPoint    The world position (in the form {x: [number from 0 to 1], y: [number from 0 to 1]} ) that represents a position in the space of the axes.
     * @param {?} useInterpolation    If true, interpolation should be used to get in-between values, rather than only the actual values in the data set.
     * @param {?} skipUnknowns    If true, unknown values should be skipped.
     * @return {?}
     */
    /* istanbul ignore next */
    getSeriesHighValuePosition(targetName, worldPoint, useInterpolation, skipUnknowns) { return; }
    ;
    /**
     * If possible, will return the best available high value position of the series for a given world coordinate.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} seriesPoint    The series pixel position (in the form {x: [number], y: [number]} that represents a position within the pixel space of the series.
     * @param {?} useInterpolation    If true, interpolation should be used to get in-between values, rather than only the actual values in the data set.
     * @param {?} skipUnknowns    If true, unknown values should be skipped.
     * @return {?}
     */
    /* istanbul ignore next */
    getSeriesHighValuePositionFromSeriesPixel(targetName, seriesPoint, useInterpolation, skipUnknowns) { return; }
    ;
    /**
     * If possible, will return the best available high value of the series for a given world coordinate.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} seriesPoint    The series pixel position (in the form {x: [number], y: [number]} ) that represents a position in the pixel space of the series.
     * @param {?} useInterpolation    If true, interpolation should be used to get in-between values, rather than only the actual values in the data set.
     * @param {?} skipUnknowns    If true, unknown values should be skipped.
     * @return {?}
     */
    /* istanbul ignore next */
    getSeriesHighValueFromSeriesPixel(targetName, seriesPoint, useInterpolation, skipUnknowns) { return; }
    ;
    /**
     * If possible, will return the best available low value of the series for a given world coordinate.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} worldPoint    The world position (in the form {x: [number from 0 to 1], y: [number from 0 to 1]} ) that represents a position in the space of the axes.
     * @param {?} useInterpolation    If true, interpolation should be used to get in-between values, rather than only the actual values in the data set.
     * @param {?} skipUnknowns    If true, unknown values should be skipped.
     * @return {?}
     */
    /* istanbul ignore next */
    getSeriesLowValue(targetName, worldPoint, useInterpolation, skipUnknowns) { return; }
    ;
    /**
     * If possible, will return the best available low value position of the series for a given world coordinate.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} worldPoint    The world position (in the form {x: [number from 0 to 1], y: [number from 0 to 1]} ) that represents a position in the space of the axes.
     * @param {?} useInterpolation    If true, interpolation should be used to get in-between values, rather than only the actual values in the data set.
     * @param {?} skipUnknowns    If true, unknown values should be skipped.
     * @return {?}
     */
    /* istanbul ignore next */
    getSeriesLowValuePosition(targetName, worldPoint, useInterpolation, skipUnknowns) { return; }
    ;
    /**
     * If possible, will return the best available low value position of the series for a given world coordinate.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} seriesPoint    The series pixel position (in the form {x: [number], y: [number]} that represents a position within the pixel space of the series.
     * @param {?} useInterpolation    If true, interpolation should be used to get in-between values, rather than only the actual values in the data set.
     * @param {?} skipUnknowns    If true, unknown values should be skipped.
     * @return {?}
     */
    /* istanbul ignore next */
    getSeriesLowValuePositionFromSeriesPixel(targetName, seriesPoint, useInterpolation, skipUnknowns) { return; }
    ;
    /**
     * If possible, will return the best available low value of the series for a given world coordinate.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} seriesPoint    The series pixel position (in the form {x: [number], y: [number]} ) that represents a position in the pixel space of the series.
     * @param {?} useInterpolation    If true, interpolation should be used to get in-between values, rather than only the actual values in the data set.
     * @param {?} skipUnknowns    If true, unknown values should be skipped.
     * @return {?}
     */
    /* istanbul ignore next */
    getSeriesLowValueFromSeriesPixel(targetName, seriesPoint, useInterpolation, skipUnknowns) { return; }
    ;
    /**
     * Gets the item item index associated with the specified series pixel coordinate.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} seriesPoint    The world position (in the form {x: [number from 0 to 1], y: [number from 0 to 1]} ) that represents a position in the space of the axes.
     * @return {?}
     */
    /* istanbul ignore next */
    getItemIndexFromSeriesPixel(targetName, seriesPoint) { return; }
    ;
    /**
     * Gets the item that is the best match for the specified world coordinates.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} seriesPoint    The series pixel position (in the form {x: [number], y: [number]} ) that represents a position in the pixel space of the series.
     * @return {?}
     */
    /* istanbul ignore next */
    getItemFromSeriesPixel(targetName, seriesPoint) { return; }
    ;
    /**
     * Gets the category offset for a series, if applicable.
     *
     * @param {?} targetName    The name of the series to target.
     * @return {?}
     */
    /* istanbul ignore next */
    getSeriesOffsetValue(targetName) { return; }
    ;
    /**
     * Gets the category width for a series, if applicable.
     *
     * @param {?} targetName    The name of the series to target.
     * @return {?}
     */
    /* istanbul ignore next */
    getSeriesCategoryWidth(targetName) { return; }
    ;
    /**
     * Replays the transition in animation for a series, if applicable.
     *
     * @param {?} targetName    The name of the series to target.
     * @return {?}
     */
    /* istanbul ignore next */
    replayTransitionIn(targetName) { return; }
    ;
    /**
     * Simulates a hover interaction over a given point in the viewport of a series.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} seriesPoint    The point at which to hover. Should have an x property with type number and a y property with type number.
     * @return {?}
     */
    /* istanbul ignore next */
    simulateHover(targetName, seriesPoint) { return; }
    ;
    /**
     * Moves the cursor point of the target annotation layer to the desired world coordinates.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} worldPoint    The point to which to move the cursor. Should have an x property with type number and a y property with type number.
     * @return {?}
     */
    /* istanbul ignore next */
    moveCursorPoint(targetName, worldPoint) { return; }
    ;
    /**
     * Manually starts a tiled zoom if one isn't already running.
     * @return {?}
     */
    /* istanbul ignore next */
    startTiledZoomingIfNecessary() { return; }
    ;
    /**
     * Manually ends a tiled zoom if one is running.
     * @return {?}
     */
    /* istanbul ignore next */
    endTiledZoomingIfRunning() { return; }
    ;
    /**
     * Clears the tile zoom tile cache so that new tiles will be generated. Only applies if the viewer is using a tile based zoom.
     * @return {?}
     */
    /* istanbul ignore next */
    clearTileZoomCache() { return; }
    ;
}
IgDataChartComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-data-chart",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "isPagePanningAllowed", "syncChannel", "synchronizeVertically", "synchronizeHorizontally", "crosshairPoint", "windowRect", "horizontalZoomable", "verticalZoomable", "windowResponse", "windowRectMinWidth", "overviewPlusDetailPaneVisibility", "crosshairVisibility", "plotAreaBackground", "defaultInteraction", "dragModifier", "panModifier", "previewRect", "windowPositionHorizontal", "windowPositionVertical", "windowScaleHorizontal", "windowScaleVertical", "circleMarkerTemplate", "triangleMarkerTemplate", "pyramidMarkerTemplate", "squareMarkerTemplate", "diamondMarkerTemplate", "pentagonMarkerTemplate", "hexagonMarkerTemplate", "tetragramMarkerTemplate", "pentagramMarkerTemplate", "hexagramMarkerTemplate", "topMargin", "leftMargin", "rightMargin", "bottomMargin", "autoMarginWidth", "autoMarginHeight", "isSquare", "gridMode", "brushes", "markerBrushes", "outlines", "markerOutlines", "width", "height", "size", "dataSource", "dataSourceUrl", "dataSourceType", "responseDataKey", "isSurfaceInteractionDisabled", "animateSeriesWhenAxisRangeChanges", "title", "subtitle", "titleTextStyle", "titleTopMargin", "titleLeftMargin", "titleRightMargin", "titleBottomMargin", "subtitleTextStyle", "subtitleTopMargin", "subtitleLeftMargin", "subtitleRightMargin", "subtitleBottomMargin", "titleTextColor", "subtitleTextColor", "titleHorizontalAlignment", "subtitleHorizontalAlignment", "highlightingTransitionDuration", "useTiledZooming", "preferHigherResolutionTiles", "pixelScalingRatio", "zoomTileCacheSize", "contentHitTestMode", "legend", "axes", "series", "theme"],
                outputs: ["tooltipShowing", "tooltipShown", "tooltipHiding", "tooltipHidden", "browserNotSupported", "seriesCursorMouseMove", "seriesMouseLeftButtonDown", "seriesMouseLeftButtonUp", "seriesMouseMove", "seriesMouseEnter", "seriesMouseLeave", "windowRectChanged", "gridAreaRectChanged", "refreshCompleted", "axisRangeChanged", "typicalBasedOn", "progressiveLoadStatusChanged", "assigningCategoryStyle", "assigningCategoryMarkerStyle"]
            }] }
];
/** @nocollapse */
IgDataChartComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];
IgDataChartComponent.propDecorators = {
    dataSource: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgPieChartComponent extends IgControlBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiffers, cdr) { super(el, renderer, differs, kvalDiffers, cdr); }
    /**
     * @return {?}
     */
    option() { return; }
    ;
    //public option(): void { return; } ;
    /**
     * @param {?} value
     * @return {?}
     */
    set dataSource(value) {
        this._dataSource = value;
        /** @type {?} */
        const chart = jQuery(this._el).data(this._widgetName);
        if (chart) {
            jQuery(this._el)[this._widgetName]("option", "dataSource", this._dataSource);
        }
    }
    ;
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this._dataSource === null || this._dataSource === undefined) {
            this._dataSource = this.options["dataSource"];
        }
        if (!this.options["dataSource"] && this._dataSource) {
            this.options["dataSource"] = this._dataSource;
        }
        super.ngOnInit();
    }
    /**
     * Adds a new item to the data source and notifies the chart.
     *
     * @param {?} item     the new item that will be added to the data source.
     * @return {?}
     */
    /* istanbul ignore next */
    addItem(item) { return; }
    ;
    /**
     * Inserts a new item to the data source and notifies the chart.
     *
     * @param {?} item     the new item that will be inserted in the data source.
     * @param {?} index     The index in the data source where the new item will be inserted.
     * @return {?}
     */
    /* istanbul ignore next */
    insertItem(item, index) { return; }
    ;
    /**
     * Deletes an item from the data source and notifies the chart.
     *
     * @param {?} index     The index in the data source from where the item will be been removed.
     * @return {?}
     */
    /* istanbul ignore next */
    removeItem(index) { return; }
    ;
    /**
     * Updates an item in the data source and notifies the chart.
     *
     * @param {?} index     The index in the data source that we want to change.
     * @param {?} item     the new item that we want to set in the data source.
     * @return {?}
     */
    /* istanbul ignore next */
    setItem(index, item) { return; }
    ;
    /**
     * Exports the chart to a PNG image.
     *
     * @param {?=} width     The width of the image.
     * @param {?=} height     The height of the image.
     * @return {?}
     */
    /* istanbul ignore next */
    exportImage(width, height) { return; }
    ;
    /**
     * Destroys the widget.
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
    /**
     * Returns the ID of parent element holding the chart.
     * @return {?}
     */
    /* istanbul ignore next */
    id() { return; }
    ;
    /**
     * Returns the element holding the chart.
     * @return {?}
     */
    /* istanbul ignore next */
    widget() { return; }
    ;
    /**
     * Creates a print preview page with the chart, hiding all other elements on the page.
     * @return {?}
     */
    /* istanbul ignore next */
    print() { return; }
    ;
    /**
     * Exports visual data from the pie chart to aid in unit testing
     * @return {?}
     */
    /* istanbul ignore next */
    exportVisualData() { return; }
    ;
}
IgPieChartComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-pie-chart",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "width", "height", "dataSource", "dataSourceUrl", "dataSourceType", "responseDataKey", "valueMemberPath", "labelMemberPath", "dataValue", "dataLabel", "labelsPosition", "labelOuterColor", "labelInnerColor", "selectionMode", "selectedItem", "selectedItems", "leaderLineVisibility", "leaderLineType", "leaderLineMargin", "othersCategoryThreshold", "formatLabel", "othersCategoryStyle", "othersCategoryType", "othersCategoryText", "explodedRadius", "radiusFactor", "allowSliceSelection", "allowSliceExplosion", "explodedSlices", "selectedSlices", "showTooltip", "tooltipTemplate", "legend", "labelExtent", "startAngle", "sweepDirection", "selectedStyle", "brushes", "outlines", "legendItemTemplate", "legendItemBadgeTemplate", "textStyle", "theme"],
                outputs: ["tooltipShowing", "tooltipShown", "tooltipHiding", "tooltipHidden", "browserNotSupported", "sliceClick", "labelClick", "selectedItemChanging", "selectedItemChanged", "selectedItemsChanging", "selectedItemsChanged"]
            }] }
];
/** @nocollapse */
IgPieChartComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];
IgPieChartComponent.propDecorators = {
    dataSource: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgDoughnutChartComponent extends IgControlBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiffers, cdr) { super(el, renderer, differs, kvalDiffers, cdr); }
    /**
     * @param {?} value
     * @return {?}
     */
    set dataSource(value) {
        this._dataSource = value;
        /** @type {?} */
        const chart = jQuery(this._el).data(this._widgetName);
        if (chart) {
            jQuery(this._el)[this._widgetName]("option", "dataSource", this._dataSource);
        }
    }
    ;
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this._dataSource === null || this._dataSource === undefined) {
            this._dataSource = this.options["dataSource"];
        }
        if (!this.options["dataSource"] && this._dataSource) {
            this.options["dataSource"] = this._dataSource;
        }
        super.ngOnInit();
    }
    /**
     * Adds a new series to the doughnut chart.
     *
     * @param {?} seriesObj     The series object to be added.
     * @return {?}
     */
    /* istanbul ignore next */
    addSeries(seriesObj) { return; }
    ;
    /**
     * Removes the specified series from the doughnut chart.
     *
     * @param {?} seriesObj     The series object identifying the series to be removed.
     * @return {?}
     */
    /* istanbul ignore next */
    removeSeries(seriesObj) { return; }
    ;
    /**
     * Updates the series with the specified name with the specified new property values.
     *
     * @param {?} value     The series object identifying the series to be updated.
     * @return {?}
     */
    /* istanbul ignore next */
    updateSeries(value) { return; }
    ;
    /**
     * Returns the center of the doughnut chart.
     * @return {?}
     */
    /* istanbul ignore next */
    getCenterCoordinates() { return; }
    ;
    /**
     * Returns the radius of the chart's hole.
     * @return {?}
     */
    /* istanbul ignore next */
    getHoleRadius() { return; }
    ;
    /**
     * Returns information about how the doughnut chart is rendered.
     * @return {?}
     */
    /* istanbul ignore next */
    exportVisualData() { return; }
    ;
    /**
     * Causes all of the series that have pending changes e.g. by changed property values to be rendered immediately.
     * @return {?}
     */
    /* istanbul ignore next */
    flush() { return; }
    ;
    /**
     * Destroys the widget.
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
}
IgDoughnutChartComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-doughnut-chart",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "width", "height", "tooltipTemplate", "maxRecCount", "dataSource", "dataSourceType", "dataSourceUrl", "responseTotalRecCountKey", "responseDataKey", "series", "allowSliceSelection", "isSurfaceInteractionDisabled", "allowSliceExplosion", "innerExtent", "selectedStyle"],
                outputs: ["dataBinding", "dataBound", "updateTooltip", "hideTooltip", "tooltipShowing", "tooltipShown", "tooltipHiding", "tooltipHidden", "browserNotSupported", "sliceClick", "holeDimensionsChanged"]
            }] }
];
/** @nocollapse */
IgDoughnutChartComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];
IgDoughnutChartComponent.propDecorators = {
    dataSource: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgFunnelChartComponent extends IgControlBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiffers, cdr) { super(el, renderer, differs, kvalDiffers, cdr); }
    /**
     * @param {?} value
     * @return {?}
     */
    set dataSource(value) {
        this._dataSource = value;
        /** @type {?} */
        const chart = jQuery(this._el).data(this._widgetName);
        if (chart) {
            jQuery(this._el)[this._widgetName]("option", "dataSource", this._dataSource);
        }
    }
    ;
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this._dataSource === null || this._dataSource === undefined) {
            this._dataSource = this.options["dataSource"];
        }
        if (!this.options["dataSource"] && this._dataSource) {
            this.options["dataSource"] = this._dataSource;
        }
        super.ngOnInit();
    }
    /**
     * Gets array of selected slice items.
     *
     * @param {?=} selection     Array or selected slice items.
     * @return {?} array|object     If parameter is undefined, then array of selected items is returned. Otherwise, it returns reference to igFunnelChart.
     */
    /* istanbul ignore next */
    selectedSliceItems(selection) { return; }
    ;
    /**
     * Gets sets array of indexes of selected slices.
     *
     * @param {?=} selection     Array or selected slice indexes.
     * @return {?} array|object     If parameter is undefined, then array of selected indexes is returned. Otherwise, it returns reference to igFunnelChart.
     */
    /* istanbul ignore next */
    selectedSliceIndexes(selection) { return; }
    ;
    /**
     * Checks if slice is selected.
     *
     * @param {?} slice     Index of slice or reference to slice-data-item.
     * @return {?}
     */
    /* istanbul ignore next */
    isSelected(slice) { return; }
    ;
    /**
     * Toggles selected state of slice.
     *
     * @param {?} slice     Index of slice or reference to slice-data-item.
     * @return {?}
     */
    /* istanbul ignore next */
    toggleSelection(slice) { return; }
    ;
    /**
     * @return {?}
     */
    exportVisualData() { return; }
    ;
    /**
     * Destroys widget.
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
}
IgFunnelChartComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-funnel-chart",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "width", "height", "tooltipTemplate", "maxRecCount", "dataSource", "dataSourceType", "dataSourceUrl", "responseTotalRecCountKey", "responseDataKey", "bezierPoints", "legend", "valueMemberPath", "brushes", "outlines", "bottomEdgeWidth", "innerLabelMemberPath", "outerLabelMemberPath", "innerLabelVisibility", "outerLabelVisibility", "outerLabelAlignment", "funnelSliceDisplay", "formatInnerLabel", "formatOuterLabel", "transitionDuration", "isInverted", "useBezierCurve", "allowSliceSelection", "useUnselectedStyle", "selectedSliceStyle", "unselectedSliceStyle", "legendItemBadgeTemplate", "useOuterLabelsForLegend", "textStyle", "outerLabelTextStyle", "outlineThickness", "pixelScalingRatio", "outerLabelTextColor", "textColor"],
                outputs: ["dataBinding", "dataBound", "updateTooltip", "hideTooltip", "sliceClicked"]
            }] }
];
/** @nocollapse */
IgFunnelChartComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];
IgFunnelChartComponent.propDecorators = {
    dataSource: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgRadialGaugeComponent extends IgControlBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiffers, cdr) { super(el, renderer, differs, kvalDiffers, cdr); }
    /**
     * Returns a string containing the names of all the ranges delimited with a \n symbol.
     * @return {?}
     */
    /* istanbul ignore next */
    getRangeNames() { return; }
    ;
    /**
     * Adds a new range to the radial gauge.
     *
     * @param {?} value
     * @return {?}
     */
    /* istanbul ignore next */
    addRange(value) { return; }
    ;
    /**
     * Removes a specified range.
     *
     * @param {?} value
     * @return {?}
     */
    /* istanbul ignore next */
    removeRange(value) { return; }
    ;
    /**
     * Updates the range.
     *
     * @param {?} value
     * @return {?}
     */
    /* istanbul ignore next */
    updateRange(value) { return; }
    ;
    /**
     * Clears the ranges in the radial gauge.
     * @return {?}
     */
    /* istanbul ignore next */
    clearRanges() { return; }
    ;
    /**
     * Scales a value on the gauge's main scale to an angle around the center point of the gauge, in radians.
     *
     * @param {?} value
     * @return {?}
     */
    /* istanbul ignore next */
    scaleValue(value) { return; }
    ;
    /**
     * Unscales a value from an angle in radians to the represented value along the main scale of the gauge.
     *
     * @param {?} value
     * @return {?}
     */
    /* istanbul ignore next */
    unscaleValue(value) { return; }
    ;
    /**
     * Gets the value for the main scale of the gauge for a given point within the bounds of the gauge.
     *
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    /* istanbul ignore next */
    getValueForPoint(x, y) { return; }
    ;
    /**
     * Gets the point on the gauge for a given scale value and extent.
     *
     * @param {?} value
     * @param {?} extent
     * @return {?}
     */
    /* istanbul ignore next */
    getPointForValue(value, extent) { return; }
    ;
    /**
     * Returns true if the main gauge needle bounding box contains the point provided, otherwise false.
     *
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    /* istanbul ignore next */
    needleContainsPoint(x, y) { return; }
    ;
    /**
     * Exports the visual data for the radial gauge.
     * @return {?}
     */
    /* istanbul ignore next */
    exportVisualData() { return; }
    ;
    /**
     * Flushes the gauge.
     * @return {?}
     */
    /* istanbul ignore next */
    flush() { return; }
    ;
    /**
     * Destroys widget.
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
    /**
     * Returns true if the style was updated for the radial gauge.
     * @return {?}
     */
    /* istanbul ignore next */
    styleUpdated() { return; }
    ;
}
IgRadialGaugeComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-radial-gauge",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "width", "height", "ranges", "rangeBrushes", "rangeOutlines", "minimumValue", "maximumValue", "interval", "centerX", "centerY", "value", "scaleStartAngle", "scaleEndAngle", "scaleSweepDirection", "transitionDuration", "transitionEasingFunction", "needleBrush", "needleOutline", "needleStartExtent", "needleEndExtent", "needleShape", "needleStartWidthRatio", "needleEndWidthRatio", "needleBaseFeatureWidthRatio", "needleBaseFeatureExtent", "needlePointFeatureWidthRatio", "needlePointFeatureExtent", "needlePivotWidthRatio", "needlePivotInnerWidthRatio", "needlePivotShape", "scaleStartExtent", "needlePivotBrush", "needlePivotOutline", "needleStrokeThickness", "needlePivotStrokeThickness", "scaleEndExtent", "labelExtent", "labelInterval", "tickStartExtent", "tickEndExtent", "tickStrokeThickness", "tickBrush", "fontBrush", "minorTickStartExtent", "minorTickEndExtent", "minorTickStrokeThickness", "minorTickBrush", "minorTickCount", "scaleBrush", "backingBrush", "backingOutline", "backingStrokeThickness", "backingOuterExtent", "backingOversweep", "scaleOversweep", "scaleOversweepShape", "backingCornerRadius", "backingInnerExtent", "backingShape", "radiusMultiplier", "duplicateLabelOmissionStrategy", "isNeedleDraggingEnabled", "isNeedleDraggingConstrained", "font", "transitionProgress", "pixelScalingRatio"],
                outputs: ["formatLabel", "alignLabel", "valueChanged"]
            }] }
];
/** @nocollapse */
IgRadialGaugeComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgZoombarComponent extends IgControlBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiffers, cdr) {
        super(el, renderer, differs, kvalDiffers, cdr);
    }
    /**
     * Destroys the Zoombar widget
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
    /**
     * Returns the main zoombar element
     * @return {?}
     */
    /* istanbul ignore next */
    widget() { return; }
    ;
    /**
     * Returns the ID of the element the zoombar is initialized on
     * @return {?}
     */
    /* istanbul ignore next */
    id() { return; }
    ;
    /**
     * Returns the DIV that is the topmost container of the zoombar widget
     * @return {?}
     */
    /* istanbul ignore next */
    container() { return; }
    ;
    /**
     * Returns the element the clone widget is initialized on
     * @return {?}
     */
    /* istanbul ignore next */
    clone() { return; }
    ;
    /**
     * Gets or sets the current zoom window
     *
     * @param {?=} left     The left parameter of the new zoom window in percentages
     * @param {?=} width     The width parameter of the new zoom window in percentages
     * @return {?}
     */
    /* istanbul ignore next */
    zoom(left, width) { return; }
    ;
}
IgZoombarComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-zoombar",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "target", "clone", "width", "height", "zoomAction", "zoomWindowMoveDistance", "defaultZoomWindow", "zoomWindowMinWidth", "hoverStyleAnimationDuration", "windowPanDuration", "tabIndex"],
                outputs: ["zoomChanging", "zoomChanged", "providerCreated", "windowDragStarting", "windowDragStarted", "windowDragging", "windowDragEnding", "windowDragEnded", "windowResizing", "windowResized"]
            }] }
];
/** @nocollapse */
IgZoombarComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgMapComponent extends IgControlBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiffers, cdr) { super(el, renderer, differs, kvalDiffers, cdr); }
    /**
     * @return {?}
     */
    option() { return; }
    ;
    /**
     * @param {?} value
     * @return {?}
     */
    set dataSource(value) {
        this._dataSource = value;
        /** @type {?} */
        const map = jQuery(this._el).data(this._widgetName);
        if (map) {
            jQuery(this._el)[this._widgetName]("option", "dataSource", this._dataSource);
        }
    }
    ;
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this._dataSource === null || this._dataSource === undefined) {
            this._dataSource = this.options["dataSource"];
        }
        if (!this.options["dataSource"] && this._dataSource) {
            this.options["dataSource"] = this._dataSource;
        }
        super.ngOnInit();
    }
    /**
     * Destroys the widget.
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
    /**
     * Returns the ID of parent element holding the map.
     * @return {?}
     */
    /* istanbul ignore next */
    id() { return; }
    ;
    /**
     * Exports the map to a PNG image.
     *
     * @param {?=} width The width of the image.
     * @param {?=} height The height of the image.
     * @return {?}
     */
    /* istanbul ignore next */
    exportImage(width, height) { return; }
    ;
    /**
     * Notify the map that styles it draws colors from may have been updated.
     * @return {?}
     */
    /* istanbul ignore next */
    styleUpdated() { return; }
    ;
    /**
     * Resets the zoom level of the map to default.
     * @return {?}
     */
    /* istanbul ignore next */
    resetZoom() { return; }
    ;
    /**
     * Adds a new item to the data source and notifies the map.
     *
     * @param {?} item     The item that we want to add to the data source.
     * @param {?} targetName     The name of the series bound to the data source.
     * @return {?}
     */
    /* istanbul ignore next */
    addItem(item, targetName) { return; }
    ;
    /**
     * Inserts a new item to the data source and notifies the map.
     *
     * @param {?} item     the new item that we want to insert in the data source.
     * @param {?} index     The index in the data source where the new item will be inserted.
     * @param {?} targetName     The name of the series bound to the data source.
     * @return {?}
     */
    /* istanbul ignore next */
    insertItem(item, index, targetName) { return; }
    ;
    /**
     * Deletes an item from the data source and notifies the map.
     *
     * @param {?} index     The index in the data source from where the item will be been removed.
     * @param {?} targetName     The name of the series bound to the data source.
     * @return {?}
     */
    /* istanbul ignore next */
    removeItem(index, targetName) { return; }
    ;
    /**
     * Updates an item in the data source and notifies the map.
     *
     * @param {?} index     The index of the item in the data source that we want to change.
     * @param {?} item     The new item object that will be set in the data source.
     * @param {?} targetName     The name of the series bound to the data source.
     * @return {?}
     */
    /* istanbul ignore next */
    setItem(index, item, targetName) { return; }
    ;
    /**
     * Notifies the the map that an item has been set in an associated data source.
     *
     * @param {?} dataSource The data source in which the change happened.
     * @param {?} index The index in the items source that has been changed.
     * @param {?} newItem the new item that has been set in the collection.
     * @param {?} oldItem the old item that has been overwritten in the collection.
     * @return {?}
     */
    /* istanbul ignore next */
    notifySetItem(dataSource, index, newItem, oldItem) { return; }
    ;
    /**
     * Notifies the the map that the items have been cleared from an associated data source.
     *                 It's not necessary to notify more than one target of a change if they share the same items source.
     *
     * @param {?} dataSource The data source in which the change happened.
     * @return {?}
     */
    /* istanbul ignore next */
    notifyClearItems(dataSource) { return; }
    ;
    /**
     * Notifies the the target series that an item has been inserted at the specified index in its data source.
     *                 It's not necessary to notify more than one target of a change if they share the same items source.
     *
     * @param {?} dataSource The data source in which the change happened.
     * @param {?} index The index in the items source where the new item has been inserted.
     * @param {?} newItem the new item that has been set in the collection.
     * @return {?}
     */
    /* istanbul ignore next */
    notifyInsertItem(dataSource, index, newItem) { return; }
    ;
    /**
     * Notifies the the target series that an item has been removed from the specified index in its data source.
     *                 It's not necessary to notify more than one target of a change if they share the same items source.
     *
     * @param {?} dataSource The data source in which the change happened.
     * @param {?} index The index in the items source from where the old item has been removed.
     * @param {?} oldItem the old item that has been removed from the collection.
     * @return {?}
     */
    /* istanbul ignore next */
    notifyRemoveItem(dataSource, index, oldItem) { return; }
    ;
    /**
     * Notifies the target series or axis that it should scroll the requested data item into view.
     *
     * @param {?} targetName The name of the series or axis notify.
     * @param {?} item The data item to bring into view, if possible.
     * @return {?}
     */
    /* istanbul ignore next */
    scrollIntoView(targetName, item) { return; }
    ;
    /**
     * Either xAxis or yAxis (longitude or latitude) that it should scale the requested value into map space from axis space.
     * 				For example you can use this method if you want to find where longitude 50 stands scaled to map's width.
     *
     * @param {?} targetName Either xAxis or yAxis to notify.
     * @param {?} unscaledValue The value in axis space to translate into map space.
     * @return {?}
     */
    /* istanbul ignore next */
    scaleValue(targetName, unscaledValue) { return; }
    ;
    /**
     * Either xAxis or yAxis (longitude or latitude) that it should unscale the requested value into axis space from map space.
     * 				For example you can use this method if you want to find what is the longitude unscaled from 0 width of the map.
     *
     * @param {?} targetName Either xAxis or yAxis to notify.
     * @param {?} scaledValue The value in map space to translate into axis space.
     * @return {?}
     */
    /* istanbul ignore next */
    unscaleValue(targetName, scaledValue) { return; }
    ;
    /**
     * Manually starts a tiled zoom if one isn't already running.
     * @return {?}
     */
    /* istanbul ignore next */
    startTiledZoomingIfNecessary() { return; }
    ;
    /**
     * Manually ends a tiled zoom if one is running.
     * @return {?}
     */
    /* istanbul ignore next */
    endTiledZoomingIfRunning() { return; }
    ;
    /**
     * Clears the tile zoom tile cache so that new tiles will be generated. Only applies if the viewer is using a tile based zoom..
     * @return {?}
     */
    /* istanbul ignore next */
    clearTileZoomCache() { return; }
    ;
    /**
     * Forces any pending deferred work to render on the map before continuing
     * @return {?}
     */
    /* istanbul ignore next */
    flush() { return; }
    ;
    /**
     * Exports visual data from the map to aid in unit testing
     * @return {?}
     */
    /* istanbul ignore next */
    exportVisualData() { return; }
    ;
    /**
     * Gets the actual minimum value of the target xAxis or yAxis
     *
     * @param {?} targetName
     * @return {?}
     */
    /* istanbul ignore next */
    getActualMinimumValue(targetName) { return; }
    ;
    /**
     * Gets the actual maximum value of the target xAxis or yAxis
     *
     * @param {?} targetName
     * @return {?}
     */
    /* istanbul ignore next */
    getActualMaximumValue(targetName) { return; }
    ;
    /**
     * Notifies the map that the container was resized
     * @return {?}
     */
    /* istanbul ignore next */
    notifyContainerResized() { return; }
    ;
    /**
     * Zoom in to the geographic region specified, when possible (may need to wait fior map to be initialized).
     *
     * @param {?} rect The geographic area rectangle.
     * @return {?}
     */
    /* istanbul ignore next */
    zoomToGeographic(rect) { return; }
    ;
    /**
     * Given the current plot area of the control and a geographic region, get the WindowRect that would encompass that geographic region.
     *
     * @param {?} rect The geographic area rectangle.
     * @return {?}
     */
    /* istanbul ignore next */
    getGeographicFromZoom(rect) { return; }
    ;
    /**
     * Given the current plot area of the control and a geographic region, get the WindowRect that would encompass that geographic region.
     *
     * @param {?} rect The geographic area rectangle.
     * @return {?}
     */
    /* istanbul ignore next */
    getZoomFromGeographic(rect) { return; }
    ;
    /**
     * Creates a print preview page with the map, hiding all other elements on the page.
     * @return {?}
     */
    /* istanbul ignore next */
    print() { return; }
    ;
    /**
     * Indicates that a series should render, even though no option has been modified that would normally cause it to refresh.
     *
     * @param {?} targetName     The name of the series to render.
     * @param {?} animate     Whether the change should be animated, if possible.
     * @return {?}
     */
    /* istanbul ignore next */
    renderSeries(targetName, animate) { return; }
    ;
}
IgMapComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-map",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "width", "height", "dataSource", "dataSourceUrl", "dataSourceType", "responseDataKey", "autoMarginWidth", "autoMarginHeight", "crosshairVisibility", "crosshairPoint", "plotAreaBackground", "defaultInteraction", "dragModifier", "panModifier", "previewRect", "windowRect", "zoomable", "windowScale", "windowResponse", "windowRectMinWidth", "windowPositionHorizontal", "windowPositionVertical", "circleMarkerTemplate", "triangleMarkerTemplate", "pyramidMarkerTemplate", "squareMarkerTemplate", "diamondMarkerTemplate", "pentagonMarkerTemplate", "hexagonMarkerTemplate", "tetragramMarkerTemplate", "pentagramMarkerTemplate", "hexagramMarkerTemplate", "overviewPlusDetailPaneBackgroundImageUri", "useTiledZooming", "preferHigherResolutionTiles", "zoomTileCacheSize", "backgroundContent", "series", "theme"],
                outputs: ["tooltipShowing", "tooltipShown", "tooltipHiding", "tooltipHidden", "browserNotSupported", "seriesCursorMouseMove", "seriesMouseLeftButtonDown", "seriesMouseLeftButtonUp", "seriesMouseMove", "seriesMouseEnter", "seriesMouseLeave", "windowRectChanged", "gridAreaRectChanged", "refreshCompleted", "triangulationStatusChanged"]
            }] }
];
/** @nocollapse */
IgMapComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];
IgMapComponent.propDecorators = {
    dataSource: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgSparklineComponent extends IgControlBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiffers, cdr) {
        super(el, renderer, differs, kvalDiffers, cdr);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set dataSource(value) {
        this._dataSource = value;
        /** @type {?} */
        const widget = jQuery(this._el).data(this._widgetName);
        if (widget) {
            jQuery(this._el)[this._widgetName]("option", "dataSource", this._dataSource);
        }
    }
    ;
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this._dataSource === null || this._dataSource === undefined) {
            this._dataSource = this.options["dataSource"];
        }
        if (!this.options["dataSource"] && this._dataSource) {
            this.options["dataSource"] = this._dataSource;
        }
        super.ngOnInit();
    }
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    destroy() { return; }
    ;
}
IgSparklineComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-sparkline",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "width", "height", "tooltipTemplate", "maxRecCount", "dataSource", "dataSourceType", "dataSourceUrl", "responseTotalRecCountKey", "responseDataKey", "brush", "negativeBrush", "markerBrush", "negativeMarkerBrush", "firstMarkerBrush", "lastMarkerBrush", "highMarkerBrush", "lowMarkerBrush", "trendLineBrush", "horizontalAxisBrush", "verticalAxisBrush", "normalRangeFill", "horizontalAxisVisibility", "verticalAxisVisibility", "markerVisibility", "negativeMarkerVisibility", "firstMarkerVisibility", "lastMarkerVisibility", "lowMarkerVisibility", "highMarkerVisibility", "normalRangeVisibility", "displayNormalRangeInFront", "markerSize", "firstMarkerSize", "lastMarkerSize", "highMarkerSize", "lowMarkerSize", "negativeMarkerSize", "lineThickness", "valueMemberPath", "labelMemberPath", "trendLineType", "trendLinePeriod", "trendLineThickness", "normalRangeMinimum", "normalRangeMaximum", "displayType", "unknownValuePlotting", "verticalAxisLabel", "horizontalAxisLabel", "formatLabel", "pixelScalingRatio"],
                outputs: ["dataBinding", "dataBound", "updateTooltip", "hideTooltip"]
            }] }
];
/** @nocollapse */
IgSparklineComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];
IgSparklineComponent.propDecorators = {
    dataSource: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgBulletGraphComponent extends IgControlBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiffers, cdr) { super(el, renderer, differs, kvalDiffers, cdr); }
    /**
     * Returns a string containing the names of all the ranges delimited with a \n symbol.
     * @return {?}
     */
    /* istanbul ignore next */
    getRangeNames() { return; }
    ;
    /**
     * Adds a new range to the bullet graph.
     *
     * @param {?} value     The range object to be added.
     * @return {?}
     */
    /* istanbul ignore next */
    addRange(value) { return; }
    ;
    /**
     * Removes a range from the bullet graph.
     *
     * @param {?} value     A JS object with properties set as follows: name: nameOfTheRangeToRemove, remove: true
     * @return {?}
     */
    /* istanbul ignore next */
    removeRange(value) { return; }
    ;
    /**
     * Updates the specified range of the bullet graph.
     *
     * @param {?} value     The range object to be updated.
     * @return {?}
     */
    /* istanbul ignore next */
    updateRange(value) { return; }
    ;
    /**
     * Returns information about how the bullet graph is rendered.
     * @return {?}
     */
    /* istanbul ignore next */
    exportVisualData() { return; }
    ;
    /**
     * Causes all pending changes of the bullet graph e.g. by changed property values to be rendered immediately.
     * @return {?}
     */
    /* istanbul ignore next */
    flush() { return; }
    ;
    /**
     * Destroys widget.
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
    /**
     * Re-polls the css styles for the widget. Use this method when the css styles have been modified.
     * @return {?}
     */
    /* istanbul ignore next */
    styleUpdated() { return; }
    ;
}
IgBulletGraphComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-bullet-graph",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "width", "height", "ranges", "rangeToolTipTemplate", "valueToolTipTemplate", "targetValueToolTipTemplate", "orientation", "rangeBrushes", "rangeOutlines", "minimumValue", "maximumValue", "targetValue", "targetValueName", "value", "valueName", "rangeInnerExtent", "rangeOuterExtent", "valueInnerExtent", "valueOuterExtent", "interval", "ticksPostInitial", "ticksPreTerminal", "labelInterval", "labelExtent", "labelsPostInitial", "labelsPreTerminal", "minorTickCount", "tickStartExtent", "tickEndExtent", "tickStrokeThickness", "tickBrush", "fontBrush", "valueBrush", "valueOutline", "valueStrokeThickness", "minorTickStartExtent", "minorTickEndExtent", "minorTickStrokeThickness", "minorTickBrush", "isScaleInverted", "backingBrush", "backingOutline", "backingStrokeThickness", "backingInnerExtent", "backingOuterExtent", "scaleStartExtent", "scaleEndExtent", "targetValueBrush", "targetValueBreadth", "targetValueInnerExtent", "targetValueOuterExtent", "targetValueOutline", "targetValueStrokeThickness", "transitionDuration", "showToolTipTimeout", "showToolTip", "font", "pixelScalingRatio"],
                outputs: ["formatLabel", "alignLabel"]
            }] }
];
/** @nocollapse */
IgBulletGraphComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgLinearGaugeComponent extends IgControlBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiffers, cdr) { super(el, renderer, differs, kvalDiffers, cdr); }
    /**
     * Returns a string containing the names of all the ranges delimited with a \n symbol.
     * @return {?}
     */
    /* istanbul ignore next */
    getRangeNames() { return; }
    ;
    /**
     * Adds a new range to the linear gauge.
     *
     * @param {?} value     The range object to be added.
     * @return {?}
     */
    /* istanbul ignore next */
    addRange(value) { return; }
    ;
    /**
     * Removes a range from the linear gauge.
     *
     * @param {?} value     A JS object with properties set as follows: name: nameOfTheRangeToRemove, remove: true
     * @return {?}
     */
    /* istanbul ignore next */
    removeRange(value) { return; }
    ;
    /**
     * Updates the specified range of the linear gauge.
     *
     * @param {?} value     The range object to be updated.
     * @return {?}
     */
    /* istanbul ignore next */
    updateRange(value) { return; }
    ;
    /**
     * Gets the value for the main scale of the gauge for a given point within the bounds of the gauge.
     *
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    /* istanbul ignore next */
    getValueForPoint(x, y) { return; }
    ;
    /**
     * Returns true if the main gauge needle bounding box contains the point provided, otherwise false.
     *
     * @param {?} x The x coordinate of the point.
     * @param {?} y The y coordinate of the point.
     * @return {?}
     */
    /* istanbul ignore next */
    needleContainsPoint(x, y) { return; }
    ;
    /**
     * Returns information about how the linear gauge is rendered.
     * @return {?}
     */
    /* istanbul ignore next */
    exportVisualData() { return; }
    ;
    /**
     * Causes all pending changes of the linear gauge e.g. by changed property values to be rendered immediately.
     * @return {?}
     */
    /* istanbul ignore next */
    flush() { return; }
    ;
    /**
     * Destroys widget.
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
    /**
     * Re-polls the css styles for the widget. Use this method when the css styles have been modified.
     * @return {?}
     */
    /* istanbul ignore next */
    styleUpdated() { return; }
    ;
}
IgLinearGaugeComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-linear-gauge",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "width", "height", "ranges", "rangeToolTipTemplate", "needleToolTipTemplate", "orientation", "rangeBrushes", "rangeOutlines", "minimumValue", "maximumValue", "value", "needleShape", "needleName", "rangeInnerExtent", "scaleInnerExtent", "rangeOuterExtent", "scaleOuterExtent", "needleInnerExtent", "needleOuterExtent", "needleInnerBaseWidth", "needleOuterBaseWidth", "needleInnerPointWidth", "needleOuterPointWidth", "needleInnerPointExtent", "needleOuterPointExtent", "interval", "ticksPostInitial", "ticksPreTerminal", "labelInterval", "labelExtent", "labelsPostInitial", "labelsPreTerminal", "minorTickCount", "tickStartExtent", "tickEndExtent", "tickStrokeThickness", "tickBrush", "fontBrush", "needleBreadth", "needleBrush", "needleOutline", "needleStrokeThickness", "minorTickStartExtent", "minorTickEndExtent", "minorTickStrokeThickness", "minorTickBrush", "isScaleInverted", "backingBrush", "backingOutline", "backingStrokeThickness", "backingInnerExtent", "backingOuterExtent", "scaleStartExtent", "scaleEndExtent", "scaleBrush", "scaleOutline", "scaleStrokeThickness", "isNeedleDraggingEnabled", "transitionDuration", "showToolTipTimeout", "showToolTip", "font", "pixelScalingRatio"],
                outputs: ["formatLabel", "alignLabel", "valueChanged"]
            }] }
];
/** @nocollapse */
IgLinearGaugeComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgQRCodeBarcodeComponent extends IgControlBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiffers, cdr) { super(el, renderer, differs, kvalDiffers, cdr); }
    /**
     * @return {?}
     */
    option() { return; }
    ;
    /**
     * Returns information about how the barcode is rendered.
     * @return {?}
     */
    /* istanbul ignore next */
    exportVisualData() { return; }
    ;
    /**
     * Causes all pending changes of the barcode e.g. by changed property values to be rendered immediately.
     * @return {?}
     */
    /* istanbul ignore next */
    flush() { return; }
    ;
    /**
     * Destroys widget.
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
    /**
     * Re-polls the css styles for the widget. Use this method when the css styles have been modified.
     * @return {?}
     */
    /* istanbul ignore next */
    styleUpdated() { return; }
    ;
}
IgQRCodeBarcodeComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-q-r-code-barcode",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "width", "height", "backingBrush", "backingOutline", "backingStrokeThickness", "barBrush", "fontBrush", "font", "data", "errorMessageText", "stretch", "barsFillMode", "widthToHeightRatio", "xDimension", "errorCorrectionLevel", "sizeVersion", "encodingMode", "eciNumber", "eciHeaderDisplayMode", "fnc1Mode", "applicationIndicator"],
                outputs: ["errorMessageDisplaying", "dataChanged"]
            }] }
];
/** @nocollapse */
IgQRCodeBarcodeComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgUploadComponent extends IgControlBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiffers, cdr) {
        super(el, renderer, differs, kvalDiffers, cdr);
    }
    /**
     * Return jquery object of fileupload container - html DOM element
     * @return {?}
     */
    /* istanbul ignore next */
    container() { return; }
    ;
    /**
     * Returns the current widget element
     * @return {?}
     */
    /* istanbul ignore next */
    widget() { return; }
    ;
    /**
     * Hide finished files
     * @return {?}
     */
    /* istanbul ignore next */
    clearAll() { return; }
    ;
    /**
     * Append additional data field to formData(before submitting it to the server). Usually this function is used in the handler of the event onFormDataSubmit. If the browser supports HTML5 file API formData is instance of FormData, otherwise(like IE10 and older) formData is jQuery representation of the <form> that should be submitted to the server
     *
     * @param {?} formData    If the browser supports HTML5 file API formData is instance of FormData, otherwise(like IE10 and older) formData is jQuery representation of the <form> that should be submitted to the server
     * @param {?} field    Data field that should be appended to the formData. The object has 2 properties - value and name. If the browser supports HTML5 the data field is appended to the formData object. Otherwise it is appended as input hidden field to the <form>
     * @return {?}
     */
    /* istanbul ignore next */
    addDataField(formData, field) { return; }
    ;
    /**
     * Append additional data fields to formData(before submitting it to the server). Usually this function is used in the handler of the event onFormDataSubmit. If the browser supports HTML5 file API formData is instance of FormData, otherwise(like IE10 and older) formData is jQuery representation of the <form> that should be submitted to the server
     *
     * @param {?} formData    If the browser supports HTML5 file API formData is instance of FormData, otherwise(like IE10 and older) formData is jQuery representation of the <form> that should be submitted to the server
     * @param {?} fields    Array of data fields that should be appended to the formData. Each data field is object with 2 properties - value and name. If the browser supports HTML5 these data fields are added to the formData. Otherwise each of these data field is appended as input hidden field to the <form>
     * @return {?}
     */
    /* istanbul ignore next */
    addDataFields(formData, fields) { return; }
    ;
    /**
     * Start uploading file as submitting form with the specified formNumber.
     *
     * @param {?} formNumber    id of the upload form
     * @return {?}
     */
    /* istanbul ignore next */
    startUpload(formNumber) { return; }
    ;
    /**
     * Cancel upload for the specified file id
     * 			 formNumber - id of the file to be canceled
     *
     * @param {?} formNumber    id of the form which should be cancelled
     * @return {?}
     */
    /* istanbul ignore next */
    cancelUpload(formNumber) { return; }
    ;
    /**
     * Destroy the widget
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
    /**
     * Returns the information about uploading files - all files uploaded/uploading/pending
     * @return {?}
     */
    /* istanbul ignore next */
    getFileInfoData() { return; }
    ;
    /**
     * Cancel all uploading and pending files
     * @return {?}
     */
    /* istanbul ignore next */
    cancelAll() { return; }
    ;
    /**
     * Returns the information about the file by specified file identifier. It could be file which is uploading/uploaded or uploading is not started. If there isn"t file with the specified file id returns null
     *
     * @param {?} fileIndex    unique identifier of the file
     * @return {?}
     */
    /* istanbul ignore next */
    getFileInfo(fileIndex) { return; }
    ;
}
IgUploadComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-upload",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "width", "height", "autostartupload", "labelUploadButton", "labelAddButton", "labelClearAllButton", "labelSummaryTemplate", "labelSummaryProgressBarTemplate", "labelShowDetails", "labelHideDetails", "labelSummaryProgressButtonCancel", "labelSummaryProgressButtonContinue", "labelSummaryProgressButtonDone", "labelProgressBarFileNameContinue", "errorMessageMaxFileSizeExceeded", "errorMessageGetFileStatus", "errorMessageCancelUpload", "errorMessageNoSuchFile", "errorMessageOther", "errorMessageValidatingFileExtension", "errorMessageAJAXRequestFileSize", "errorMessageTryToRemoveNonExistingFile", "errorMessageTryToStartNonExistingFile", "errorMessageMaxUploadedFiles", "errorMessageMaxSimultaneousFiles", "errorMessageDropMultipleFilesWhenSingleModel", "uploadUrl", "progressUrl", "allowedExtensions", "showFileExtensionIcon", "css", "fileExtensionIcons", "mode", "multipleFiles", "maxUploadedFiles", "maxSimultaneousFilesUploads", "fileSizeMetric", "controlId", "fileSizeDecimalDisplay", "maxFileSize"],
                outputs: ["fileSelecting", "fileSelected", "fileUploading", "fileUploaded", "fileUploadAborted", "cancelAllClicked", "onError", "fileExtensionsValidating", "onXHRLoad", "onFormDataSubmit"]
            }] }
];
/** @nocollapse */
IgUploadComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgPopoverComponent extends IgControlBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiffers, cdr) { super(el, renderer, differs, kvalDiffers, cdr); }
    /**
     * @return {?}
     */
    option() { return; }
    ;
    /**
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        var elem = jQuery(document).find("#" + this.widgetId);
        if (elem.length === 1) {
            this._el = elem;
            this._events = new Map();
            //events binding
            /** @type {?} */
            let that = this;
            /** @type {?} */
            var evtName;
            for (var propt in jQuery.ui[this._widgetName].prototype.events) {
                evtName = this._widgetName.toLowerCase() + propt.toLowerCase();
                this._events[evtName] = propt;
                jQuery(this._el).on(evtName, (/**
                 * @param {?} evt
                 * @param {?} ui
                 * @return {?}
                 */
                function (evt, ui) {
                    that[that._events[evt.type]].emit({ event: evt, ui: ui });
                }));
            }
            jQuery(this._el)[this._widgetName](this.options);
        }
        else {
            super.ngOnInit();
        }
    }
    /**
     * Destroys the popover widget.
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
    /**
     * Returns the ID of the element the popover is attached to
     * @return {?}
     */
    /* istanbul ignore next */
    id() { return; }
    ;
    /**
     * Returns the container for the popover contents
     * @return {?}
     */
    /* istanbul ignore next */
    container() { return; }
    ;
    /**
     * Shows the popover for the specified target
     *
     * @param {?=} trg     The element to show popover for.
     * @param {?=} content     The string to set for the popover to show.
     * @return {?}
     */
    /* istanbul ignore next */
    show(trg, content) { return; }
    ;
    /**
     * Hides the popover for the specified target
     * @return {?}
     */
    /* istanbul ignore next */
    hide() { return; }
    ;
    /**
     * Gets the currently set content for the popover container
     * @return {?}
     */
    /* istanbul ignore next */
    getContent() { return; }
    ;
    /**
     * Sets the content for the popover container
     *
     * @param {?} newCnt     The popover content to set.
     * @return {?}
     */
    /* istanbul ignore next */
    setContent(newCnt) { return; }
    ;
    /**
     * Gets the popover current target
     * @return {?}
     */
    /* istanbul ignore next */
    target() { return; }
    ;
    /**
     * Gets the current coordinates of the popover
     * @return {?}
     */
    /* istanbul ignore next */
    getCoordinates() { return; }
    ;
    /**
     * Sets the popover to specific coordinates.
     *
     * @param {?} pos     The popover coordinates in pixels.
     * @return {?}
     */
    /* istanbul ignore next */
    setCoordinates(pos) { return; }
    ;
}
IgPopoverComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-popover",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "closeOnBlur", "direction", "position", "width", "height", "minWidth", "maxWidth", "maxHeight", "animationDuration", "contentTemplate", "selectors", "headerTemplate", "showOn", "containment", "appendTo"],
                outputs: ["showing", "shown", "hiding", "hidden"]
            }] }
];
/** @nocollapse */
IgPopoverComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
//TODO: change the model from any to IgNotifier when added to igniteui typescript definitions
class IgNotifierComponent extends IgControlBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiffers, cdr) { super(el, renderer, differs, kvalDiffers, cdr); }
    /**
     * @return {?}
     */
    option() { return; }
    ;
    /**
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        var elem = jQuery(document).find("#" + this.widgetId);
        if (elem.length === 1) {
            this._el = elem;
            this._events = new Map();
            //events binding
            /** @type {?} */
            let that = this;
            /** @type {?} */
            var evtName;
            for (var propt in jQuery.ui[this._widgetName].prototype.events) {
                evtName = this._widgetName.toLowerCase() + propt.toLowerCase();
                this._events[evtName] = propt;
                jQuery(this._el).on(evtName, (/**
                 * @param {?} evt
                 * @param {?} ui
                 * @return {?}
                 */
                function (evt, ui) {
                    that[that._events[evt.type]].emit({ event: evt, ui: ui });
                }));
            }
            jQuery(this._el)[this._widgetName](this.options);
        }
        else {
            super.ngOnInit();
        }
    }
    /**
     * Triggers a notification with a certain state and optional message. The [notifyLevel](ui.ignotifier#options:notifyLevel) option determines if the notification will be displayed.
     *
     * @param {?} state    The state to show notification for.
     * @param {?=} message    Optional message to show, overrides defaults.
     * @return {?}
     */
    /* istanbul ignore next */
    notify(state, message) { return; }
    ;
    /**
     * Returns true if the notification is currently visible
     * @return {?}
     */
    /* istanbul ignore next */
    isVisible() { return; }
    ;
    /**
     * Destroys the widget.
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
}
IgNotifierComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-notifier",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "closeOnBlur", "direction", "position", "width", "height", "minWidth", "maxWidth", "maxHeight", "animationDuration", "contentTemplate", "selectors", "headerTemplate", "showOn", "containment", "appendTo", "state", "notifyLevel", "mode", "allowCSSOnTarget", "messages", "showIcon", "animationSlideDistance"],
                outputs: ["showing", "shown", "hiding", "hidden"]
            }] }
];
/** @nocollapse */
IgNotifierComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgRatingComponent extends IgControlBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiffers, cdr) {
        super(el, renderer, differs, kvalDiffers, cdr);
    }
    /**
     * Gets reference to [igValidator](ui.igvalidator) used by igRating.
     *
     * @param {?=} destroy     Request to destroy validator.
     * @return {?}
     */
    /* istanbul ignore next */
    validator(destroy) { return; }
    ;
    /**
     * Triggers validation.
     * @return {?}
     */
    /* istanbul ignore next */
    validate() { return; }
    ;
    /**
     * Gets/Sets (selected) value.
     *
     * @param {?} val     New value which is rendered with selected css.
     * @return {?} number|object     If parameter is not 'number', then exact value rendered with selected css is returned. Otherwise, reference to igRating is returned.
     */
    /* istanbul ignore next */
    value(val) { return; }
    ;
    /**
     * Gets/Sets hover value.
     *
     * @param {?=} val     New value which will be rendered with hover css when rating gets mouse.
     * @return {?} number|object     If parameter is not "number", then last value which was rendered with hover css is returned. Otherwise, reference to igRating is returned.
     */
    /* istanbul ignore next */
    valueHover(val) { return; }
    ;
    /**
     * Checks if igRating has focus.
     * @return {?}
     */
    /* istanbul ignore next */
    hasFocus() { return; }
    ;
    /**
     * Sets focus to igRating. That has effect only when options.focusable is enabled.
     * @return {?}
     */
    /* istanbul ignore next */
    focus() { return; }
    ;
    /**
     * Destroys igRating widget.
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
}
IgRatingComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-rating",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "vertical", "value", "valueHover", "voteCount", "voteWidth", "voteHeight", "swapDirection", "valueAsPercent", "focusable", "precision", "precisionZeroVote", "roundedDecimalPlaces", "theme", "validatorOptions", "cssVotes"],
                outputs: ["hoverChange", "valueChange"]
            }] }
];
/** @nocollapse */
IgRatingComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgVideoPlayerComponent extends IgControlBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiffers, cdr) {
        super(el, renderer, differs, kvalDiffers, cdr);
    }
    /**
     * Returns the element on which the widget was instantiated
     * @return {?}
     */
    /* istanbul ignore next */
    widget() { return; }
    ;
    /**
     * Hide the add message if shown.
     * @return {?}
     */
    /* istanbul ignore next */
    hideAdMessage() { return; }
    ;
    /**
     * Play a linked commercial for this video.
     *
     * @param {?} commercial     Specify the linked commercial to play.
     * @return {?}
     */
    /* istanbul ignore next */
    playCommercial(commercial) { return; }
    ;
    /**
     * Shows the ad banner, if there is such.
     *
     * @param {?} index    Specify the index of the banner from the banners array.
     * @return {?}
     */
    /* istanbul ignore next */
    showBanner(index) { return; }
    ;
    /**
     * Hide the ad banner, if there is such.
     *
     * @param {?} index    Specify the index of the banner from the banners array.
     * @return {?}
     */
    /* istanbul ignore next */
    hideBanner(index) { return; }
    ;
    /**
     * Resets the commercials, to be shown again.
     * @return {?}
     */
    /* istanbul ignore next */
    resetCommercialsShow() { return; }
    ;
    /**
     * Toggle control play state. If video is playing it will pause, if video is paused it will play.
     * @return {?}
     */
    /* istanbul ignore next */
    togglePlay() { return; }
    ;
    /**
     * Start playing current loaded video if any.
     * @return {?}
     */
    /* istanbul ignore next */
    play() { return; }
    ;
    /**
     * Pause the currently playing video if any.
     * @return {?}
     */
    /* istanbul ignore next */
    pause() { return; }
    ;
    /**
     * Gets/Sets the current time of the playing video.
     *
     * @param {?} val     Specify the playback position in seconds to navigate to.
     * @return {?}
     */
    /* istanbul ignore next */
    currentTime(val) { return; }
    ;
    /**
     * Get a screenshot of the current video frame. It returns a canvas object that you can position and show on the page. This depends on the browser support for canvas.
     *
     * @param {?=} scaleFactor    Specify scale factor between 0 and 1.
     * @return {?}
     */
    /* istanbul ignore next */
    screenshot(scaleFactor) { return; }
    ;
    /**
     * Get whether the current browser supports video tag.
     * @return {?}
     */
    /* istanbul ignore next */
    supportsVideo() { return; }
    ;
    /**
     * Get whether the current browser supports H.264 codec.
     * @return {?}
     */
    /* istanbul ignore next */
    supportsH264BaselineVideo() { return; }
    ;
    /**
     * Get whether the current browser supports Theora codec.
     * @return {?}
     */
    /* istanbul ignore next */
    supportsOggTheoraVideo() { return; }
    ;
    /**
     * Get whether the current browser supports WEBM codec.
     * @return {?}
     */
    /* istanbul ignore next */
    supportsWebmVideo() { return; }
    ;
    /**
     * Returns whether the currently played video is paused.
     * @return {?}
     */
    /* istanbul ignore next */
    paused() { return; }
    ;
    /**
     * Get whether the current played video has ended.
     * @return {?}
     */
    /* istanbul ignore next */
    ended() { return; }
    ;
    /**
     * Get the current duration of the played video. It may be NaN if duration is still not loaded or the video is a live stream.
     * @return {?}
     */
    /* istanbul ignore next */
    duration() { return; }
    ;
    /**
     * Get whether the player is seeking to find the new playback position specified.
     * @return {?}
     */
    /* istanbul ignore next */
    seeking() { return; }
    ;
    /**
     * Destroys the widget.
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
}
IgVideoPlayerComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-video-player",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "sources", "width", "height", "posterUrl", "preload", "autoplay", "autohide", "volumeAutohideDelay", "centerButtonHideDelay", "loop", "browserControls", "fullscreen", "volume", "muted", "title", "showSeekTime", "progressLabelFormat", "bookmarks", "relatedVideos", "banners", "commercials"],
                outputs: ["ended", "playing", "paused", "buffering", "progress", "waiting", "bookmarkHit", "bookmarkClick", "enterFullScreen", "exitFullScreen", "relatedVideoClick", "bannerVisible", "bannerHidden", "bannerClick", "browserNotSupported"]
            }] }
];
/** @nocollapse */
IgVideoPlayerComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgRadialMenuComponent extends IgControlBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiffers, cdr) {
        super(el, renderer, differs, kvalDiffers, cdr);
    }
    /* istanbul ignore next */
    /**
     * @param {?} itemKey
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    itemOption(itemKey, key, value) { return; }
    ;
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    exportVisualData() { return; }
    ;
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    flush() { return; }
    ;
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    destroy() { return; }
    ;
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    styleUpdated() { return; }
    ;
}
IgRadialMenuComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-radial-menu",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "items", "currentOpenMenuItemName", "centerButtonContentWidth", "centerButtonContentHeight", "centerButtonClosedFill", "centerButtonClosedStroke", "centerButtonFill", "centerButtonHotTrackFill", "centerButtonHotTrackStroke", "centerButtonStroke", "centerButtonStrokeThickness", "font", "isOpen", "menuBackground", "menuItemOpenCloseAnimationDuration", "menuItemOpenCloseAnimationEasingFunction", "menuOpenCloseAnimationDuration", "menuOpenCloseAnimationEasingFunction", "minWedgeCount", "outerRingFill", "outerRingThickness", "outerRingStroke", "outerRingStrokeThickness", "rotationInDegrees", "rotationAsPercentageOfWedge", "wedgePaddingInDegrees", "pixelScalingRatio"],
                outputs: ["formatLabel", "alignLabel", "valueChanged"]
            }] }
];
/** @nocollapse */
IgRadialMenuComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgSplitButtonComponent extends IgControlBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiffers, cdr) { super(el, renderer, differs, kvalDiffers, cdr); }
    /**
     * Switch to given igToolbar button.
     *
     * @param {?} button . The button jQuery element.
     * @return {?}
     */
    /* istanbul ignore next */
    switchToButton(button) { return; }
    ;
    /**
     * Toggle widget state between collapsed and expanded.
     *
     * @param {?} e The igSplitButton to be expanded/collapsed.
     * @return {?}
     */
    /* istanbul ignore next */
    toggle(e) { return; }
    ;
    /**
     * Collapse the widget.
     *
     * @param {?=} e Indicates the browser event which triggered this action (not API).
     * @return {?}
     */
    /* istanbul ignore next */
    collapse(e) { return; }
    ;
    /**
     * Expands the widget.
     *
     * @param {?=} e Indicates the browser event which triggered this action (not API).
     * @return {?}
     */
    /* istanbul ignore next */
    expand(e) { return; }
    ;
    /**
     * Destroy the widget.
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
    /* istanbul ignore next */
    /**
     * @return {?}
     */
    widget() { return; }
    ;
}
IgSplitButtonComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-split-button",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "items", "defaultItemName", "swapDefaultEnabled"],
                outputs: ["click", "expanded", "expanding", "collapsed", "collapsing"]
            }] }
];
/** @nocollapse */
IgSplitButtonComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgSpreadsheetComponent extends IgControlBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiffers, cdr) {
        super(el, renderer, differs, kvalDiffers, cdr);
    }
    /**
     * Returns an object that represents the pane with the focus.
     * @return {?}
     */
    /* istanbul ignore next */
    getActivePane() { return; }
    ;
    /**
     * Returns an object that represents the current selection of the active pane.
     * @return {?}
     */
    /* istanbul ignore next */
    getActiveSelection() { return; }
    ;
    /**
     * Returns an object used to get the formatting of the activeCell and where modifications are applied to the entire active selection.
     * 				Any changes made to this object will affect all the objects in the selection. So for example, the
     * 				Font.Name may return "Arial" because the active cell has that as its resolved font name even though the other
     * 				cells are using a different font but if you set the Font.Name of this object to "Arial" then all the objects
     * 				affected by the selection will have their Font.Name updated to that value.
     * @return {?}
     */
    /* istanbul ignore next */
    getActiveSelectionCellRangeFormat() { return; }
    ;
    /**
     * Returns a boolean indicating if the user is currently editing the name of the active worksheet.
     * @return {?}
     */
    /* istanbul ignore next */
    getIsRenamingWorksheet() { return; }
    ;
    /**
     * Returns an array of the panes for the activeWorksheet.
     *
     * 				 returnType="ig.spreadsheet.SpreadsheetPane[]"
     * @return {?}
     */
    /* istanbul ignore next */
    getPanes() { return; }
    ;
    /**
     * Executes the action associated with the specified id.
     *
     * @param {?} action An [enumeration](ig.spreadsheet.SpreadsheetAction) or string that identifies the action to execute.
     * @return {?}
     */
    /* istanbul ignore next */
    executeAction(action) { return; }
    ;
    /**
     * Forces any pending deferred work to render on the spreadsheet before continuing
     * @return {?}
     */
    /* istanbul ignore next */
    flush() { return; }
    ;
    /**
     * Destroys the widget.
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
    /**
     * Notify the spreadsheet that style information used for rendering the spreadsheet may have been updated.
     * @return {?}
     */
    /* istanbul ignore next */
    styleUpdated() { return; }
    ;
}
IgSpreadsheetComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-spreadsheet",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "width", "height", "activeCell", "isScrollLocked", "activeWorksheet", "allowAddWorksheet", "allowDeleteWorksheet", "areGridlinesVisible", "areHeadersVisible", "enterKeyNavigationDirection", "isEnterKeyNavigationEnabled", "isFormulaBarVisible", "isInEndMode", "isUndoEnabled", "nameBoxWidth", "selectionMode", "selectedWorksheets", "validationInputMessagePosition", "workbook", "zoomLevel"],
                outputs: ["actionExecuted", "actionExecuting", "activeCellChanged", "activePaneChanged", "activeWorksheetChanged", "editRangePasswordNeeded", "hyperlinkExecuting", "selectionChanged", "userPromptDisplaying", "workbookDirtied"]
            }] }
];
/** @nocollapse */
IgSpreadsheetComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgSchedulerComponent extends IgControlBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiffers, cdr) {
        super(el, renderer, differs, kvalDiffers, cdr);
    }
    /**
     * Gets reference to appointment by id
     *
     * @param {?} id
     * @return {?}
     */
    /* istanbul ignore next */
    getAppointmentById(id) { return; }
    ;
    /**
     * Creates a new appointment and renders it to the scheduler
     *
     * @param {?} appointment
     * @return {?}
     */
    /* istanbul ignore next */
    createAppointment(appointment) { return; }
    ;
    /**
     * Deletes appointment from the appointment collection
     *
     * @param {?} appointment 	appointment
     * @return {?}
     */
    /* istanbul ignore next */
    deleteAppointment(appointment) { return; }
    ;
    /**
     * Deletes appointment from the appointment collection
     *
     * @param {?} appointment 	appointment
     * @param {?} updateAppoinment 	updateAppoinment
     * @return {?}
     */
    /* istanbul ignore next */
    editAppointment(appointment, updateAppoinment) { return; }
    ;
    /**
     * Destroys the widget
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
    /**
     * Gets reference to the today UI button.
     * @return {?}
     */
    /* istanbul ignore next */
    todayButton() { return; }
    ;
    /**
     * Gets reference to the previous UI button.
     * @return {?}
     */
    /* istanbul ignore next */
    previousButton() { return; }
    ;
    /**
     * Gets reference to the date range UI button.
     * @return {?}
     */
    /* istanbul ignore next */
    dateRangeButton() { return; }
    ;
    /**
     * Gets reference to the next UI button.
     * @return {?}
     */
    /* istanbul ignore next */
    nextButton() { return; }
    ;
    /**
     * Gets reference to the jQuery calendar UI control.
     * @return {?}
     */
    /* istanbul ignore next */
    getCalendar() { return; }
    ;
}
IgSchedulerComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-scheduler",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "views", "viewMode", "selectedDate", "enableTodayButton", "width", "height", "agendaViewSettings", "monthViewSettings", "appointmentDialogSuppress"],
                outputs: ["agendaRangeChanging", "agendaRangeChanged", "daySelected", "monthChanging", "monthChanged", "rendering", "rendered", "viewChanging", "viewChanged", "appointmentDialogOpening", "appointmentDialogOpened", "appointmentDialogClosing", "appointmentDialogClosed", "appointmentCreating", "appointmentCreated", "appointmentDeleting", "appointmentDeleted", "appointmentEditing", "appointmentEdited"]
            }] }
];
/** @nocollapse */
IgSchedulerComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IgniteUIModule {
}
IgniteUIModule.decorators = [
    { type: NgModule, args: [{
                declarations: [Column, IgGridMultiColumnHeadersFeature, IgGridSortingFeature, IgGridFilteringFeature, IgGridPagingFeature, IgGridUpdatingFeature, IgGridGroupByFeature, IgGridColumnMovingFeature, IgGridHidingFeature, IgGridCellMergingFeature, IgGridResponsiveFeature, IgGridResizingFeature, IgGridSelectionFeature, IgGridRowSelectorsFeature, IgGridSummariesFeature, IgGridColumnFixingFeature, IgGridTooltipsFeature, IgGridAppendRowsOnDemandFeature, Features, IgGridComponent, IgTreeGridComponent, IgHierarchicalGridComponent, IgComboComponent, IgCheckboxEditorComponent, IgCurrencyEditorComponent, IgDateEditorComponent, IgDatePickerComponent, IgDatePickerComponent, IgTimePickerComponent, IgMaskEditorComponent, IgNumericEditorComponent, IgPercentEditorComponent, IgTextEditorComponent, IgTreeComponent, IgDialogComponent, IgSplitterComponent, IgLayoutManagerComponent, IgTileManagerComponent, IgHtmlEditorComponent, IgValidatorComponent, IgPivotDataSelectorComponent, IgPivotGridComponent, IgDataChartComponent, IgPieChartComponent, IgDoughnutChartComponent, IgFunnelChartComponent, IgRadialGaugeComponent, IgZoombarComponent, IgMapComponent, IgSparklineComponent, IgBulletGraphComponent, IgLinearGaugeComponent, IgQRCodeBarcodeComponent, IgUploadComponent, IgPopoverComponent, IgNotifierComponent, IgRatingComponent, IgVideoPlayerComponent, IgRadialMenuComponent, IgSplitButtonComponent, IgSpreadsheetComponent, IgSchedulerComponent],
                exports: [Column, IgGridMultiColumnHeadersFeature, IgGridSortingFeature, IgGridFilteringFeature, IgGridPagingFeature, IgGridUpdatingFeature, IgGridGroupByFeature, IgGridColumnMovingFeature, IgGridHidingFeature, IgGridCellMergingFeature, IgGridResponsiveFeature, IgGridResizingFeature, IgGridSelectionFeature, IgGridRowSelectorsFeature, IgGridSummariesFeature, IgGridColumnFixingFeature, IgGridTooltipsFeature, IgGridAppendRowsOnDemandFeature, Features, IgGridComponent, IgTreeGridComponent, IgHierarchicalGridComponent, IgComboComponent, IgCheckboxEditorComponent, IgCurrencyEditorComponent, IgDateEditorComponent, IgDatePickerComponent, IgDatePickerComponent, IgTimePickerComponent, IgMaskEditorComponent, IgNumericEditorComponent, IgPercentEditorComponent, IgTextEditorComponent, IgTreeComponent, IgDialogComponent, IgSplitterComponent, IgLayoutManagerComponent, IgTileManagerComponent, IgHtmlEditorComponent, IgValidatorComponent, IgPivotDataSelectorComponent, IgPivotGridComponent, IgDataChartComponent, IgPieChartComponent, IgDoughnutChartComponent, IgFunnelChartComponent, IgRadialGaugeComponent, IgZoombarComponent, IgMapComponent, IgSparklineComponent, IgBulletGraphComponent, IgLinearGaugeComponent, IgQRCodeBarcodeComponent, IgUploadComponent, IgPopoverComponent, IgNotifierComponent, IgRatingComponent, IgVideoPlayerComponent, IgRadialMenuComponent, IgSplitButtonComponent, IgSpreadsheetComponent, IgSchedulerComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { Column, Features, IgBulletGraphComponent, IgCheckboxEditorComponent, IgComboComponent, IgCurrencyEditorComponent, IgDataChartComponent, IgDateEditorComponent, IgDatePickerComponent, IgDialogComponent, IgDoughnutChartComponent, IgFunnelChartComponent, IgGridAppendRowsOnDemandFeature, IgGridCellMergingFeature, IgGridColumnFixingFeature, IgGridColumnMovingFeature, IgGridComponent, IgGridFilteringFeature, IgGridGroupByFeature, IgGridHidingFeature, IgGridMultiColumnHeadersFeature, IgGridPagingFeature, IgGridResizingFeature, IgGridResponsiveFeature, IgGridRowSelectorsFeature, IgGridSelectionFeature, IgGridSortingFeature, IgGridSummariesFeature, IgGridTooltipsFeature, IgGridUpdatingFeature, IgHierarchicalGridComponent, IgHtmlEditorComponent, IgLayoutManagerComponent, IgLinearGaugeComponent, IgMapComponent, IgMaskEditorComponent, IgNotifierComponent, IgNumericEditorComponent, IgPercentEditorComponent, IgPieChartComponent, IgPivotDataSelectorComponent, IgPivotGridComponent, IgPopoverComponent, IgQRCodeBarcodeComponent, IgRadialGaugeComponent, IgRadialMenuComponent, IgRatingComponent, IgSchedulerComponent, IgSparklineComponent, IgSplitButtonComponent, IgSplitterComponent, IgSpreadsheetComponent, IgTextEditorComponent, IgTileManagerComponent, IgTimePickerComponent, IgTreeComponent, IgTreeGridComponent, IgUploadComponent, IgValidatorComponent, IgVideoPlayerComponent, IgZoombarComponent, IgniteUIModule, Feature as ɵa, IgGridBase as ɵb, IgControlBase as ɵc, IgEditorBase as ɵd, IgContentControlBase as ɵe };
//# sourceMappingURL=igniteui-angular-wrappers.js.map
