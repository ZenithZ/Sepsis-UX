/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, Renderer, ElementRef, IterableDiffers, KeyValueDiffers, ChangeDetectorRef } from "@angular/core";
import { IgGridBase } from "../iggrid/iggridbase";
export class IgTreeGridComponent extends IgGridBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiffers, cdr) { super(el, renderer, differs, kvalDiffers, cdr); }
    /**
     * @param {?} id
     * @return {?}
     */
    deleteRow(id) {
        /** @type {?} */
        var element = jQuery(this._el);
        /** @type {?} */
        var tr = element.find("tr[data-id='" + id + "']");
        /** @type {?} */
        var dataLevel = tr.attr("aria-level");
        if (tr.length > 0) {
            element.data(this._widgetName).dataSource.deleteRow(id, true);
            element.data(this._widgetName).dataSource._removeTransactionsByRecordId(id);
            /** @type {?} */
            var trs = tr.nextUntil("tr[data-level=" + dataLevel + "]");
            if (trs.length === 0) {
                trs = tr.nextAll("tr[data-level]");
            }
            tr.remove();
            trs.remove();
        }
    }
    /**
     * @param {?} rec
     * @param {?} currValue
     * @param {?} key
     * @return {?}
     */
    updateRow(rec, currValue, key) {
        /** @type {?} */
        const element = jQuery(this._el);
        /** @type {?} */
        const grid = element.data(this._widgetName);
        /** @type {?} */
        const childDataKey = this["childDataKey"] || this.options.childDataKey;
        /** @type {?} */
        const column = element.data(this._widgetName).columnByKey(key);
        if (!column && key === childDataKey) {
            //we have an hierarchical data source and one of the nested collections has changed.
            grid.dataBind();
        }
        else {
            super.updateRow(rec, currValue, key);
        }
    }
    /**
     * @return {?}
     */
    markForCheck() {
        super.markForCheck();
        /** @type {?} */
        const childDataKey = this["childDataKey"] || this.options.childDataKey;
        if (childDataKey) {
            this.dataBind();
        }
    }
    /**
     * Clears the transaction log (delegates to igDataSource). Note that this does not update the UI. In case the UI must be updated, set the second parameter "updateUI" to true, which will trigger a call to dataBind() to re-render the contents.
     *
     * @param {?=} rowId     If specified, will only rollback the transactions with that row id.
     * @param {?=} updateUI     Whether to update the UI or not.
     * @return {?}
     */
    /* istanbul ignore next */
    rollback(rowId, updateUI) { return; }
    ;
    /**
     * Causes the treegrid to data bind to the data source (local or remote) , and re-render all of the data
     * @return {?}
     */
    /* istanbul ignore next */
    dataBind() { return; }
    ;
    /**
     * Toggle row by specified row or row identifier
     *
     * @param {?} row     jQuery table row object or a row id.
     * @param {?=} callback     Specifies a custom function to be called when row is expanded/collapsed. The callback has 4 arguments- a reference to the current context(this), object that holds 2 properties(unfixedRow - DOM representation of the unfixed row, fixedRow - DOM representation of the fixed row, if there is no fixed columns it is undefined), reference to the dataRecord, expand - specifies whether row is expanded
     * @return {?}
     */
    /* istanbul ignore next */
    toggleRow(row, callback) { return; }
    ;
    /**
     * Expands a parent row by specified row or row identifier
     *
     * @param {?} row     jQuery table row object or a row id.
     * @param {?=} callback     Specifies a custom function to be called when row is expanded/collapsed. The callback has 4 arguments- a reference to the current context(this), object that holds 2 properties(unfixedRow - DOM representation of the unfixed row, fixedRow - DOM representation of the fixed row, if there is no fixed columns it is undefined), reference to the dataRecord, expand - specifies whether row is expanded
     * @return {?}
     */
    /* istanbul ignore next */
    expandRow(row, callback) { return; }
    ;
    /**
     * Collapses a parent row by specified row or row identifier
     *
     * @param {?} row     jQuery table row object, raw DOM row object or a row id.
     * @param {?=} callback     Specifies a custom function to be called when row is expanded/collapsed. The callback has 4 arguments- a reference to the current context(this), object that holds 2 properties(unfixedRow - DOM representation of the unfixed row, fixedRow - DOM representation of the fixed row, if there is no fixed columns it is undefined), reference to the dataRecord, expand - specifies whether row is expanded
     * @return {?}
     */
    /* istanbul ignore next */
    collapseRow(row, callback) { return; }
    ;
    /**
     * Adds a new row (TR) to the grid as a child of a specific row, by taking a data row object. Assumes the record will have the primary key.
     *
     * @param {?} rec     The data row JavaScript object.
     * @param {?=} parentId     Identifier/key of the targeted parent row. If missing, then the new row is rendered to the bottom of the grid.
     * @return {?}
     */
    /* istanbul ignore next */
    renderNewChild(rec, parentId) { return; }
    ;
    /**
     * Destroys igTreeGrid
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
}
IgTreeGridComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-tree-grid",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "width", "height", "autoAdjustHeight", "avgRowHeight", "avgColumnWidth", "defaultColumnWidth", "autoGenerateColumns", "virtualization", "virtualizationMode", "requiresDataBinding", "rowVirtualization", "columnVirtualization", "virtualizationMouseWheelStep", "adjustVirtualHeights", "templatingEngine", "columns", "dataSource", "dataSourceUrl", "dataSourceType", "responseDataKey", "responseTotalRecCountKey", "requestType", "responseContentType", "showHeader", "showFooter", "fixedHeaders", "fixedFooters", "caption", "features", "tabIndex", "localSchemaTransform", "primaryKey", "serializeTransactionLog", "autoCommit", "aggregateTransactions", "autoFormat", "renderCheckboxes", "updateUrl", "restSettings", "alternateRowStyles", "autofitLastColumn", "enableHoverStyles", "enableUTCDates", "mergeUnboundColumns", "jsonpRequest", "enableResizeContainerCheck", "featureChooserIconDisplay", "scrollSettings", "indentation", "initialIndentationLevel", "showExpansionIndicator", "expandTooltipText", "collapseTooltipText", "foreignKey", "initialExpandDepth", "foreignKeyRootValue", "renderExpansionIndicatorColumn", "renderFirstDataCellFunction", "childDataKey", "renderExpansionCellFunction", "enableRemoteLoadOnDemand", "dataSourceSettings"],
                outputs: ["cellClick", "cellRightClick", "dataBinding", "dataBound", "rendering", "rendered", "dataRendering", "dataRendered", "headerRendering", "headerRendered", "footerRendering", "footerRendered", "headerCellRendered", "rowsRendering", "rowsRendered", "schemaGenerated", "columnsCollectionModified", "requestError", "created", "destroyed", "rowExpanding", "rowExpanded", "rowCollapsing", "rowCollapsed"]
            }] }
];
/** @nocollapse */
IgTreeGridComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWd0cmVlZ3JpZC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLXdyYXBwZXJzLyIsInNvdXJjZXMiOlsibGliL2lndHJlZWdyaWQvaWd0cmVlZ3JpZC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBRSxlQUFlLEVBQUUsZUFBZSxFQUFFLGlCQUFpQixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3JILE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQVFsRCxNQUFNLE9BQU8sbUJBQW9CLFNBQVEsVUFBc0I7Ozs7Ozs7O0lBQzNELFlBQVksRUFBYyxFQUFFLFFBQWtCLEVBQUUsT0FBd0IsRUFBRSxXQUE0QixFQUFFLEdBQXNCLElBQUksS0FBSyxDQUFDLEVBQUUsRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLFdBQVcsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7Ozs7O0lBRW5MLFNBQVMsQ0FBQyxFQUFFOztZQUNKLE9BQU8sR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQzs7WUFDMUIsRUFBRSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsY0FBYyxHQUFHLEVBQUUsR0FBRyxJQUFJLENBQUM7O1lBQzdDLFNBQVMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQztRQUNyQyxJQUFJLEVBQUUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBRWYsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFDOUQsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsVUFBVSxDQUFDLDZCQUE2QixDQUFDLEVBQUUsQ0FBQyxDQUFDOztn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QVUsRUFBRSxzQkFBc0IsRUFBRSxZQUFZLEVBQUUseUJBQXlCLEVBQUUsWUFBWSxFQUFFLHVCQUF1QixFQUFFLFlBQVksRUFBRSxrQkFBa0IsRUFBRSxXQUFXLEVBQUUsY0FBYyxFQUFFLG9CQUFvQixFQUFFLG1CQUFtQixFQUFFLG1CQUFtQixFQUFFLGdCQUFnQixFQUFFLHFCQUFxQixFQUFFLGNBQWMsRUFBRSw0QkFBNEIsRUFBRSwyQkFBMkIsRUFBRSxnQkFBZ0IsRUFBRSxhQUFhLEVBQUUseUJBQXlCLEVBQUUsd0JBQXdCLEVBQUUsbUJBQW1CLEVBQUUscUJBQXFCLEVBQUUsWUFBWSxFQUFFLG9CQUFvQixFQUFFLHFCQUFxQixFQUFFLGdDQUFnQyxFQUFFLDZCQUE2QixFQUFFLGNBQWMsRUFBRSw2QkFBNkIsRUFBRSwwQkFBMEIsRUFBRSxvQkFBb0IsQ0FBQztnQkFDeHlDLE9BQU8sRUFBRSxDQUFDLFdBQVcsRUFBRSxnQkFBZ0IsRUFBRSxhQUFhLEVBQUUsV0FBVyxFQUFFLFdBQVcsRUFBRSxVQUFVLEVBQUUsZUFBZSxFQUFFLGNBQWMsRUFBRSxpQkFBaUIsRUFBRSxnQkFBZ0IsRUFBRSxpQkFBaUIsRUFBRSxnQkFBZ0IsRUFBRSxvQkFBb0IsRUFBRSxlQUFlLEVBQUUsY0FBYyxFQUFFLGlCQUFpQixFQUFFLDJCQUEyQixFQUFFLGNBQWMsRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUFFLGNBQWMsRUFBRSxhQUFhLEVBQUUsZUFBZSxFQUFFLGNBQWMsQ0FBQzthQUMxWjs7OztZQVI2QixVQUFVO1lBQXBCLFFBQVE7WUFBYyxlQUFlO1lBQUUsZUFBZTtZQUFFLGlCQUFpQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgUmVuZGVyZXIsIEVsZW1lbnRSZWYsIEl0ZXJhYmxlRGlmZmVycywgS2V5VmFsdWVEaWZmZXJzLCBDaGFuZ2VEZXRlY3RvclJlZiB9IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQgeyBJZ0dyaWRCYXNlIH0gZnJvbSBcIi4uL2lnZ3JpZC9pZ2dyaWRiYXNlXCI7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiBcImlnLXRyZWUtZ3JpZFwiLFxuICAgIHRlbXBsYXRlOiBcIjxuZy1jb250ZW50PjwvbmctY29udGVudD5cIixcbiAgICBpbnB1dHM6IFtcIndpZGdldElkXCIsIFwib3B0aW9uc1wiLCBcImNoYW5nZURldGVjdGlvbkludGVydmFsXCIsIFwiZGlzYWJsZWRcIiwgXCJjcmVhdGVcIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiLCBcImF1dG9BZGp1c3RIZWlnaHRcIiwgXCJhdmdSb3dIZWlnaHRcIiwgXCJhdmdDb2x1bW5XaWR0aFwiLCBcImRlZmF1bHRDb2x1bW5XaWR0aFwiLCBcImF1dG9HZW5lcmF0ZUNvbHVtbnNcIiwgXCJ2aXJ0dWFsaXphdGlvblwiLCBcInZpcnR1YWxpemF0aW9uTW9kZVwiLCBcInJlcXVpcmVzRGF0YUJpbmRpbmdcIiwgXCJyb3dWaXJ0dWFsaXphdGlvblwiLCBcImNvbHVtblZpcnR1YWxpemF0aW9uXCIsIFwidmlydHVhbGl6YXRpb25Nb3VzZVdoZWVsU3RlcFwiLCBcImFkanVzdFZpcnR1YWxIZWlnaHRzXCIsIFwidGVtcGxhdGluZ0VuZ2luZVwiLCBcImNvbHVtbnNcIiwgXCJkYXRhU291cmNlXCIsIFwiZGF0YVNvdXJjZVVybFwiLCBcImRhdGFTb3VyY2VUeXBlXCIsIFwicmVzcG9uc2VEYXRhS2V5XCIsIFwicmVzcG9uc2VUb3RhbFJlY0NvdW50S2V5XCIsIFwicmVxdWVzdFR5cGVcIiwgXCJyZXNwb25zZUNvbnRlbnRUeXBlXCIsIFwic2hvd0hlYWRlclwiLCBcInNob3dGb290ZXJcIiwgXCJmaXhlZEhlYWRlcnNcIiwgXCJmaXhlZEZvb3RlcnNcIiwgXCJjYXB0aW9uXCIsIFwiZmVhdHVyZXNcIiwgXCJ0YWJJbmRleFwiLCBcImxvY2FsU2NoZW1hVHJhbnNmb3JtXCIsIFwicHJpbWFyeUtleVwiLCBcInNlcmlhbGl6ZVRyYW5zYWN0aW9uTG9nXCIsIFwiYXV0b0NvbW1pdFwiLCBcImFnZ3JlZ2F0ZVRyYW5zYWN0aW9uc1wiLCBcImF1dG9Gb3JtYXRcIiwgXCJyZW5kZXJDaGVja2JveGVzXCIsIFwidXBkYXRlVXJsXCIsIFwicmVzdFNldHRpbmdzXCIsIFwiYWx0ZXJuYXRlUm93U3R5bGVzXCIsIFwiYXV0b2ZpdExhc3RDb2x1bW5cIiwgXCJlbmFibGVIb3ZlclN0eWxlc1wiLCBcImVuYWJsZVVUQ0RhdGVzXCIsIFwibWVyZ2VVbmJvdW5kQ29sdW1uc1wiLCBcImpzb25wUmVxdWVzdFwiLCBcImVuYWJsZVJlc2l6ZUNvbnRhaW5lckNoZWNrXCIsIFwiZmVhdHVyZUNob29zZXJJY29uRGlzcGxheVwiLCBcInNjcm9sbFNldHRpbmdzXCIsIFwiaW5kZW50YXRpb25cIiwgXCJpbml0aWFsSW5kZW50YXRpb25MZXZlbFwiLCBcInNob3dFeHBhbnNpb25JbmRpY2F0b3JcIiwgXCJleHBhbmRUb29sdGlwVGV4dFwiLCBcImNvbGxhcHNlVG9vbHRpcFRleHRcIiwgXCJmb3JlaWduS2V5XCIsIFwiaW5pdGlhbEV4cGFuZERlcHRoXCIsIFwiZm9yZWlnbktleVJvb3RWYWx1ZVwiLCBcInJlbmRlckV4cGFuc2lvbkluZGljYXRvckNvbHVtblwiLCBcInJlbmRlckZpcnN0RGF0YUNlbGxGdW5jdGlvblwiLCBcImNoaWxkRGF0YUtleVwiLCBcInJlbmRlckV4cGFuc2lvbkNlbGxGdW5jdGlvblwiLCBcImVuYWJsZVJlbW90ZUxvYWRPbkRlbWFuZFwiLCBcImRhdGFTb3VyY2VTZXR0aW5nc1wiXSxcbiAgICBvdXRwdXRzOiBbXCJjZWxsQ2xpY2tcIiwgXCJjZWxsUmlnaHRDbGlja1wiLCBcImRhdGFCaW5kaW5nXCIsIFwiZGF0YUJvdW5kXCIsIFwicmVuZGVyaW5nXCIsIFwicmVuZGVyZWRcIiwgXCJkYXRhUmVuZGVyaW5nXCIsIFwiZGF0YVJlbmRlcmVkXCIsIFwiaGVhZGVyUmVuZGVyaW5nXCIsIFwiaGVhZGVyUmVuZGVyZWRcIiwgXCJmb290ZXJSZW5kZXJpbmdcIiwgXCJmb290ZXJSZW5kZXJlZFwiLCBcImhlYWRlckNlbGxSZW5kZXJlZFwiLCBcInJvd3NSZW5kZXJpbmdcIiwgXCJyb3dzUmVuZGVyZWRcIiwgXCJzY2hlbWFHZW5lcmF0ZWRcIiwgXCJjb2x1bW5zQ29sbGVjdGlvbk1vZGlmaWVkXCIsIFwicmVxdWVzdEVycm9yXCIsIFwiY3JlYXRlZFwiLCBcImRlc3Ryb3llZFwiLCBcInJvd0V4cGFuZGluZ1wiLCBcInJvd0V4cGFuZGVkXCIsIFwicm93Q29sbGFwc2luZ1wiLCBcInJvd0NvbGxhcHNlZFwiXVxufSlcbmV4cG9ydCBjbGFzcyBJZ1RyZWVHcmlkQ29tcG9uZW50IGV4dGVuZHMgSWdHcmlkQmFzZTxJZ1RyZWVHcmlkPiB7XG4gICAgY29uc3RydWN0b3IoZWw6IEVsZW1lbnRSZWYsIHJlbmRlcmVyOiBSZW5kZXJlciwgZGlmZmVyczogSXRlcmFibGVEaWZmZXJzLCBrdmFsRGlmZmVyczogS2V5VmFsdWVEaWZmZXJzLCBjZHI6IENoYW5nZURldGVjdG9yUmVmKSB7IHN1cGVyKGVsLCByZW5kZXJlciwgZGlmZmVycywga3ZhbERpZmZlcnMsIGNkcik7IH1cblxuICAgIGRlbGV0ZVJvdyhpZCkge1xuICAgICAgICB2YXIgZWxlbWVudCA9IGpRdWVyeSh0aGlzLl9lbCksXG4gICAgICAgICAgICB0ciA9IGVsZW1lbnQuZmluZChcInRyW2RhdGEtaWQ9J1wiICsgaWQgKyBcIiddXCIpLFxuICAgICAgICAgICAgZGF0YUxldmVsID0gdHIuYXR0cihcImFyaWEtbGV2ZWxcIik7XG4gICAgICAgIGlmICh0ci5sZW5ndGggPiAwKSB7XG5cbiAgICAgICAgICAgIGVsZW1lbnQuZGF0YSh0aGlzLl93aWRnZXROYW1lKS5kYXRhU291cmNlLmRlbGV0ZVJvdyhpZCwgdHJ1ZSk7XG4gICAgICAgICAgICBlbGVtZW50LmRhdGEodGhpcy5fd2lkZ2V0TmFtZSkuZGF0YVNvdXJjZS5fcmVtb3ZlVHJhbnNhY3Rpb25zQnlSZWNvcmRJZChpZCk7XG5cbiAgICAgICAgICAgIHZhciB0cnMgPSB0ci5uZXh0VW50aWwoXCJ0cltkYXRhLWxldmVsPVwiICsgZGF0YUxldmVsICsgXCJdXCIpO1xuICAgICAgICAgICAgaWYgKHRycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0cnMgPSB0ci5uZXh0QWxsKFwidHJbZGF0YS1sZXZlbF1cIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyLnJlbW92ZSgpO1xuICAgICAgICAgICAgdHJzLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlUm93KHJlYywgY3VyclZhbHVlLCBrZXkpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGpRdWVyeSh0aGlzLl9lbCk7XG4gICAgICAgIGNvbnN0IGdyaWQgPSBlbGVtZW50LmRhdGEodGhpcy5fd2lkZ2V0TmFtZSk7XG4gICAgICAgIGNvbnN0IGNoaWxkRGF0YUtleSA9IHRoaXNbXCJjaGlsZERhdGFLZXlcIl0gfHwgdGhpcy5vcHRpb25zLmNoaWxkRGF0YUtleTtcbiAgICAgICAgY29uc3QgY29sdW1uID0gZWxlbWVudC5kYXRhKHRoaXMuX3dpZGdldE5hbWUpLmNvbHVtbkJ5S2V5KGtleSk7XG4gICAgICAgIGlmICghY29sdW1uICYmIGtleSA9PT0gY2hpbGREYXRhS2V5KSB7XG4gICAgICAgICAgICAvL3dlIGhhdmUgYW4gaGllcmFyY2hpY2FsIGRhdGEgc291cmNlIGFuZCBvbmUgb2YgdGhlIG5lc3RlZCBjb2xsZWN0aW9ucyBoYXMgY2hhbmdlZC5cbiAgICAgICAgICAgIGdyaWQuZGF0YUJpbmQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1cGVyLnVwZGF0ZVJvdyhyZWMsIGN1cnJWYWx1ZSwga2V5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBtYXJrRm9yQ2hlY2soKSB7XG4gICAgICAgIHN1cGVyLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICBjb25zdCBjaGlsZERhdGFLZXkgPSB0aGlzW1wiY2hpbGREYXRhS2V5XCJdIHx8IHRoaXMub3B0aW9ucy5jaGlsZERhdGFLZXk7XG4gICAgICAgIGlmIChjaGlsZERhdGFLZXkpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YUJpbmQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgdHJhbnNhY3Rpb24gbG9nIChkZWxlZ2F0ZXMgdG8gaWdEYXRhU291cmNlKS4gTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgdXBkYXRlIHRoZSBVSS4gSW4gY2FzZSB0aGUgVUkgbXVzdCBiZSB1cGRhdGVkLCBzZXQgdGhlIHNlY29uZCBwYXJhbWV0ZXIgXCJ1cGRhdGVVSVwiIHRvIHRydWUsIHdoaWNoIHdpbGwgdHJpZ2dlciBhIGNhbGwgdG8gZGF0YUJpbmQoKSB0byByZS1yZW5kZXIgdGhlIGNvbnRlbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJvd0lkICAgICBJZiBzcGVjaWZpZWQsIHdpbGwgb25seSByb2xsYmFjayB0aGUgdHJhbnNhY3Rpb25zIHdpdGggdGhhdCByb3cgaWQuXG4gICAgICogQHBhcmFtIHVwZGF0ZVVJICAgICBXaGV0aGVyIHRvIHVwZGF0ZSB0aGUgVUkgb3Igbm90LlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIHJvbGxiYWNrKHJvd0lkPzogT2JqZWN0LCB1cGRhdGVVST86IGJvb2xlYW4pOiBhbnlbXSB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIENhdXNlcyB0aGUgdHJlZWdyaWQgdG8gZGF0YSBiaW5kIHRvIHRoZSBkYXRhIHNvdXJjZSAobG9jYWwgb3IgcmVtb3RlKSAsIGFuZCByZS1yZW5kZXIgYWxsIG9mIHRoZSBkYXRhXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgZGF0YUJpbmQoKTogdm9pZCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFRvZ2dsZSByb3cgYnkgc3BlY2lmaWVkIHJvdyBvciByb3cgaWRlbnRpZmllclxuICAgICAqXG4gICAgICogQHBhcmFtIHJvdyAgICAgalF1ZXJ5IHRhYmxlIHJvdyBvYmplY3Qgb3IgYSByb3cgaWQuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrICAgICBTcGVjaWZpZXMgYSBjdXN0b20gZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gcm93IGlzIGV4cGFuZGVkL2NvbGxhcHNlZC4gVGhlIGNhbGxiYWNrIGhhcyA0IGFyZ3VtZW50cy0gYSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgY29udGV4dCh0aGlzKSwgb2JqZWN0IHRoYXQgaG9sZHMgMiBwcm9wZXJ0aWVzKHVuZml4ZWRSb3cgLSBET00gcmVwcmVzZW50YXRpb24gb2YgdGhlIHVuZml4ZWQgcm93LCBmaXhlZFJvdyAtIERPTSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZml4ZWQgcm93LCBpZiB0aGVyZSBpcyBubyBmaXhlZCBjb2x1bW5zIGl0IGlzIHVuZGVmaW5lZCksIHJlZmVyZW5jZSB0byB0aGUgZGF0YVJlY29yZCwgZXhwYW5kIC0gc3BlY2lmaWVzIHdoZXRoZXIgcm93IGlzIGV4cGFuZGVkXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgdG9nZ2xlUm93KHJvdzogT2JqZWN0LCBjYWxsYmFjaz86IEZ1bmN0aW9uKTogdm9pZCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIEV4cGFuZHMgYSBwYXJlbnQgcm93IGJ5IHNwZWNpZmllZCByb3cgb3Igcm93IGlkZW50aWZpZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb3cgICAgIGpRdWVyeSB0YWJsZSByb3cgb2JqZWN0IG9yIGEgcm93IGlkLlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAgICAgU3BlY2lmaWVzIGEgY3VzdG9tIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHJvdyBpcyBleHBhbmRlZC9jb2xsYXBzZWQuIFRoZSBjYWxsYmFjayBoYXMgNCBhcmd1bWVudHMtIGEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGNvbnRleHQodGhpcyksIG9iamVjdCB0aGF0IGhvbGRzIDIgcHJvcGVydGllcyh1bmZpeGVkUm93IC0gRE9NIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB1bmZpeGVkIHJvdywgZml4ZWRSb3cgLSBET00gcmVwcmVzZW50YXRpb24gb2YgdGhlIGZpeGVkIHJvdywgaWYgdGhlcmUgaXMgbm8gZml4ZWQgY29sdW1ucyBpdCBpcyB1bmRlZmluZWQpLCByZWZlcmVuY2UgdG8gdGhlIGRhdGFSZWNvcmQsIGV4cGFuZCAtIHNwZWNpZmllcyB3aGV0aGVyIHJvdyBpcyBleHBhbmRlZFxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGV4cGFuZFJvdyhyb3c6IE9iamVjdCwgY2FsbGJhY2s/OiBGdW5jdGlvbik6IHZvaWQgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBDb2xsYXBzZXMgYSBwYXJlbnQgcm93IGJ5IHNwZWNpZmllZCByb3cgb3Igcm93IGlkZW50aWZpZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb3cgICAgIGpRdWVyeSB0YWJsZSByb3cgb2JqZWN0LCByYXcgRE9NIHJvdyBvYmplY3Qgb3IgYSByb3cgaWQuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrICAgICBTcGVjaWZpZXMgYSBjdXN0b20gZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gcm93IGlzIGV4cGFuZGVkL2NvbGxhcHNlZC4gVGhlIGNhbGxiYWNrIGhhcyA0IGFyZ3VtZW50cy0gYSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgY29udGV4dCh0aGlzKSwgb2JqZWN0IHRoYXQgaG9sZHMgMiBwcm9wZXJ0aWVzKHVuZml4ZWRSb3cgLSBET00gcmVwcmVzZW50YXRpb24gb2YgdGhlIHVuZml4ZWQgcm93LCBmaXhlZFJvdyAtIERPTSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZml4ZWQgcm93LCBpZiB0aGVyZSBpcyBubyBmaXhlZCBjb2x1bW5zIGl0IGlzIHVuZGVmaW5lZCksIHJlZmVyZW5jZSB0byB0aGUgZGF0YVJlY29yZCwgZXhwYW5kIC0gc3BlY2lmaWVzIHdoZXRoZXIgcm93IGlzIGV4cGFuZGVkXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgY29sbGFwc2VSb3cocm93OiBPYmplY3QsIGNhbGxiYWNrPzogRnVuY3Rpb24pOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyByb3cgKFRSKSB0byB0aGUgZ3JpZCBhcyBhIGNoaWxkIG9mIGEgc3BlY2lmaWMgcm93LCBieSB0YWtpbmcgYSBkYXRhIHJvdyBvYmplY3QuIEFzc3VtZXMgdGhlIHJlY29yZCB3aWxsIGhhdmUgdGhlIHByaW1hcnkga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlYyAgICAgVGhlIGRhdGEgcm93IEphdmFTY3JpcHQgb2JqZWN0LlxuICAgICAqIEBwYXJhbSBwYXJlbnRJZCAgICAgSWRlbnRpZmllci9rZXkgb2YgdGhlIHRhcmdldGVkIHBhcmVudCByb3cuIElmIG1pc3NpbmcsIHRoZW4gdGhlIG5ldyByb3cgaXMgcmVuZGVyZWQgdG8gdGhlIGJvdHRvbSBvZiB0aGUgZ3JpZC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyByZW5kZXJOZXdDaGlsZChyZWM6IE9iamVjdCwgcGFyZW50SWQ/OiBzdHJpbmcpOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgaWdUcmVlR3JpZFxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGRlc3Ryb3koKTogT2JqZWN0IHsgcmV0dXJuOyB9O1xufSJdfQ==