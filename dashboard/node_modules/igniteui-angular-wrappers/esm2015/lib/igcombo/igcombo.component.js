/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, Optional, ElementRef, Renderer, IterableDiffers, KeyValueDiffers, ChangeDetectorRef, Input } from "@angular/core";
import { IgControlBase } from "../igcontrolbase/igcontrolbase";
import { NgModel } from "@angular/forms";
export class IgComboComponent extends IgControlBase {
    /**
     * @param {?} model
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(model, el, renderer, differs, kvalDiffers, cdr) {
        super(el, renderer, differs, kvalDiffers, cdr);
        this.model = model;
        this.onChange = (/**
         * @param {?} _
         * @return {?}
         */
        (_) => {
        });
        this.onTouched = (/**
         * @return {?}
         */
        () => {
        });
        if (model) {
            model.valueAccessor = this;
            this._model = model;
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set dataSource(value) {
        this._dataSource = value;
    }
    ;
    /**
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        let that = this;
        if (this._dataSource === null || this._dataSource === undefined) {
            this._dataSource = this.options["dataSource"];
        }
        if (!this.options["dataSource"] && this._dataSource) {
            this.options["dataSource"] = this._dataSource;
        }
        super.ngOnInit();
        if (this._model) {
            if (this.options.allowCustomValue) {
                jQuery(this._el).on("input", (/**
                 * @param {?} evt
                 * @return {?}
                 */
                function (evt) {
                    that._model.viewToModelUpdate(evt.target.value);
                }));
                jQuery(this._el).closest(".ui-igcombo-wrapper").find(".ui-igcombo-clear").on("click", (/**
                 * @return {?}
                 */
                function () {
                    if (that.options.multiSelection && that.options.multiSelection.enabled) {
                        that._model.viewToModelUpdate([]);
                    }
                    else {
                        that._model.viewToModelUpdate(null);
                    }
                }));
            }
            // D.P. #244 only attach selectionchanged handler if there's a model to update
            jQuery(this._el).on(this._widgetName.toLowerCase() + "selectionchanged", (/**
             * @param {?} evt
             * @param {?} ui
             * @return {?}
             */
            function (evt, ui) {
                /** @type {?} */
                var items = ui.items;
                /** @type {?} */
                const valueKey = ui.owner.options.valueKey;
                if (items.length <= 0 && !ui.owner.options.multiSelection.enabled) {
                    if (!ui.owner.options.allowCustomValue) {
                        that._model.viewToModelUpdate(null);
                    }
                    return;
                }
                if (ui.owner.options.multiSelection.enabled) {
                    that._model.viewToModelUpdate(items.map((/**
                     * @param {?} item
                     * @return {?}
                     */
                    function (item) {
                        return item.data[valueKey];
                    })));
                }
                else {
                    that._model.viewToModelUpdate(items[0].data[valueKey]);
                }
            }));
            //manually call writeValue, because the LifeCycle has been changed and writeValue is executed before ngOnInit
            this.writeValue(this._model.value);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (!!jQuery(this._el).data(this._widgetName)) {
            jQuery(this._el)[this._widgetName]("value", value);
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    dataSourceApplyChanges(changes) {
        //dataSource has changed.
        /** @type {?} */
        const element = jQuery(this._el);
        if (element[this._widgetName]) {
            element[this._widgetName]("option", "dataSource", this._dataSource);
        }
        if (this.model && this.model.value) {
            this.writeValue(this.model.value);
        }
    }
    /**
     * @param {?} rec
     * @param {?} val
     * @param {?} key
     * @param {?} index
     * @return {?}
     */
    updateComboItem(rec, val, key, index) {
        /** @type {?} */
        const element = jQuery(this._el);
        /** @type {?} */
        const comboItem = element.data("igCombo").itemsFromIndex(index);
        element.data("igCombo")._updateItem(comboItem.element, rec);
        if (element.data("igCombo").isSelected(comboItem.element)) {
            //should update the input
            element.data("igCombo")._updateInputValues(false);
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const ds = "dataSource";
        if (ds in changes) {
            /** @type {?} */
            const value = changes[ds].currentValue;
            if (value) {
                try {
                    this._differ = this._differs.find(value).create();
                    this._changes = [];
                    for (var i = 0; i < this._dataSource.length; i++) {
                        this._changes.push(this.kvalDiffers.find({}).create());
                    }
                }
                catch (e) {
                    throw new Error("Only binding to arrays is supported.");
                }
            }
        }
        super.ngOnChanges(changes);
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this._differ) {
            /** @type {?} */
            const changes = this._differ.diff(this._dataSource);
            //check if grid is initialized
            /** @type {?} */
            const combo = jQuery(this._el).data(this._widgetName);
            if (changes && combo) {
                this.dataSourceApplyChanges(changes);
            }
            if (this._changes && combo) {
                //check recs
                for (var i = 0; i < this._dataSource.length; i++) {
                    /** @type {?} */
                    var item = this._dataSource[i];
                    /** @type {?} */
                    var recChanges = this._changes[i].diff(item);
                    if (recChanges) {
                        recChanges.forEachChangedItem((/**
                         * @param {?} change
                         * @return {?}
                         */
                        (change) => {
                            this.updateComboItem(item, change.currentValue, change.key, i);
                        }));
                    }
                }
            }
        }
        super.ngDoCheck();
    }
    /**
     * Performs databinding on the combo box. The [databinding](ui.igcombo#events:dataBinding) and [dataBound](ui.igcombo#events:dataBound) events are always raised.
     * @return {?}
     */
    /* istanbul ignore next */
    dataBind() { return; }
    ;
    /**
     * Forces an update of the igCombo value according to the current text in the igCombo input.
     *
     * 				The refresh is primarily intended to be used with [allowCustomValue](ui.igcombo#options:allowCustomValue) set to true.
     * 				The refresh will take the current text and, if no selection is applied, will set it as igCombo value provided that [allowCustomValue](ui.igcombo#options:allowCustomValue) true.
     * @return {?}
     */
    /* istanbul ignore next */
    refreshValue() { return; }
    ;
    /**
     * Gets the associated data of an item by value matching it's [valueKey](ui.igcombo#options:valueKey) property.
     *
     * @param {?} value Value matching the valueKey property of item to be tested if it is selected
     * @return {?}
     */
    /* istanbul ignore next */
    dataForValue(value) { return; }
    ;
    /**
     * Gets the associated data of li element in the combo.
     *
     * @param {?} $element jQuery element of item in the drop down list
     * @return {?}
     */
    /* istanbul ignore next */
    dataForElement($element) { return; }
    ;
    /**
     * Gets object/s containing data and list item in the combo by element/s.
     *
     * @param {?} $element jQuery object with drop down list item element or elements
     * @return {?}
     */
    /* istanbul ignore next */
    itemsFromElement($element) { return; }
    ;
    /**
     * Gets object/s containing data and list item in the combo by value/s.
     *
     * @param {?} value Value of item in the drop down list or array with values.
     * @return {?}
     */
    /* istanbul ignore next */
    itemsFromValue(value) { return; }
    ;
    /**
     * Gets object/s containing data and list item in the combo by index/es.
     *
     * @param {?} index Index or array of indexes of items in the drop down list
     * @return {?}
     */
    /* istanbul ignore next */
    itemsFromIndex(index) { return; }
    ;
    /**
     * Gets array with data and objects representing li elements in combo box.
     * @return {?}
     */
    /* istanbul ignore next */
    items() { return; }
    ;
    /**
     * Gets array with objects representing the filtered li elements in combo box.
     * @return {?}
     */
    /* istanbul ignore next */
    filteredItems() { return; }
    ;
    /**
     * Gets array with objects representing selected li elements in combo box.
     * @return {?}
     */
    /* istanbul ignore next */
    selectedItems() { return; }
    ;
    /**
     * Triggers filtering.
     *
     * @param {?=} texts Filter by string, or array of strings.
     * @param {?=} event Indicates the browser event which triggered this action (not API). Calling the method with this param set to "true" will trigger [filtering](ui.igcombo#events:filtering) and [filtered](ui.igcombo#events:filtered) events.
     * @return {?}
     */
    /* istanbul ignore next */
    filter(texts, event) { return; }
    ;
    /**
     * Clears filtering.
     *
     * @param {?=} event Indicates the browser event which triggered this action (not API). Calling the method with this param set to "true" will trigger [filtering](ui.igcombo#events:filtering) and [filtered](ui.igcombo#events:filtered) events.
     * @return {?}
     */
    /* istanbul ignore next */
    clearFiltering(event) { return; }
    ;
    /**
     * Opens the drop-down.
     *
     * @param {?=} callback Specifies callback function to be executed when open animation is completed.
     * @param {?=} focusCombo Set to false to not focus combo"s text input after the drop down is opened. By default the combo's input is focused.
     * @param {?=} event Indicates the browser event which triggered this action (not API). Calling the method with this param set to "true" will trigger [dropDownOpening](ui.igcombo#events:dropDownOpening) and [dropDownOpened](ui.igcombo#events:dropDownOpened) events.
     * @return {?}
     */
    /* istanbul ignore next */
    openDropDown(callback, focusCombo, event) { return; }
    ;
    /**
     * Closes the drop down.
     *
     * @param {?=} callback Specifies callback function to be executed when close animation is completed.
     * @param {?=} event Indicates the browser event which triggered this action (not API). Calling the method with this param set to "true" will trigger [dropDownClosing](ui.igcombo#events:dropDownClosing) and [dropDownClosed](ui.igcombo#events:dropDownClosed) events.
     * @return {?}
     */
    /* istanbul ignore next */
    closeDropDown(callback, event) { return; }
    ;
    /**
     * Clears the input text, resets highlighting, filtering and selection.
     *
     * @param {?=} options     Object with set of options controlling the behavior of this api method.
     * focusCombo (boolean): Set to true to focus combo after clearing the input.
     * @param {?=} event Indicates the browser event which triggered this action (not API). Calling the method with this param set to "true" will trigger [selectionChanging](ui.igcombo#events:selectionChanging) and [selectionChanged](ui.igcombo#events:selectionChanged) events.
     * @return {?}
     */
    /* istanbul ignore next */
    clearInput(options, event) { return; }
    ;
    /**
     * Verifies whether a specified value is selected.
     *
     * @param {?} value Value matching the [valueKey](ui.igcombo#options:valueKey) property of item to be tested if it is selected
     * @return {?}
     */
    /* istanbul ignore next */
    isValueSelected(value) { return; }
    ;
    /**
     * Verifies whether the li representing the data source's record at the specified index is selected.
     *
     * @param {?} index Index of data source record
     * @return {?}
     */
    /* istanbul ignore next */
    isIndexSelected(index) { return; }
    ;
    /**
     * Selects list item/items from the drop-down list by specified value or array of values. When called witout params will return the value of the selected item or if [multiSelection](ui.igcombo#options:multiSelection) is enabled array of selected values.
     *
     * @param {?=} value Value or array of values matching the valueKey property of item/items to be selected
     * @param {?=} options Object with set of options controlling the behavior of this api method.
     * closeDropDown (boolean): Set to true to close the drop down list after the selection.
     * focusCombo (boolean): Set to true to focus combo after the selection.
     * additive (boolean): Set to true to select the item without losing other selection. Works only when multi selection is enabled.
     * keepFiltering (boolean): Set to true to keep filtering after the selection. By default the filtering is cleared.
     * keepInputText (boolean): Set to true to keep input text unchanged after the selection. By default input text is updated.
     * keepHighlighting (boolean): Set to true to keep highlighting unchanged after the selection. By default highlighting is removed.
     * keepNavItem (boolean): Set to true to keep current navigation item unchanged after the selection. By default the navigation item is changed to the new selected item.
     * keepScrollPosition (boolean): Set to true to keep current scroll position. By default the scroll position will change so that the last selected item is visible.
     * @param {?=} event Indicates the browser event which triggered this action (not API). Calling the method with this param set to "true" will trigger [selectionChanging](ui.igcombo#events:selectionChanging) and [selectionChanged](ui.igcombo#events:selectionChanged) events.
     * @return {?}
     */
    /* istanbul ignore next */
    value(value, options, event) { return; }
    ;
    /**
     * Selects a list item from the drop-down list.
     *
     * @param {?} $items jQuery object with item or items to be selected.
     * @param {?=} options Object with set of options controlling the behavior of this api method.
     * closeDropDown (boolean): Set to true to close the drop down list after the selection.
     * focusCombo (boolean): Set to true to focus combo after the selection.
     * additive (boolean): Set to true to select the item without losing other selection. Works only when multi selection is enabled.
     * keepFiltering (boolean): Set to true to keep filtering after the selection. By default the filtering is cleared.
     * keepInputText (boolean): Set to true to keep input text unchanged after the selection. By default input text is updated.
     * keepHighlighting (boolean): Set to true to keep highlighting unchanged after the selection. By default highlighting is removed.
     * keepNavItem (boolean): Set to true to keep current navigation item unchanged after the selection. By default the navigation item is changed to the new selected item.
     * keepScrollPosition (boolean): Set to true to keep current scroll position. By default the scroll position will change so that the last selected item is visible.
     * @param {?=} event Indicates the browser event which triggered this action (not API). Calling the method with this param set to "true" will trigger [selectionChanging](ui.igcombo#events:selectionChanging) and [selectionChanged](ui.igcombo#events:selectionChanged) events.
     * @return {?}
     */
    /* istanbul ignore next */
    select($items, options, event) { return; }
    ;
    /**
     * Gets/Sets selected item/s from the drop-down list by specified index.
     *
     * @param {?=} index Index or array of indexes of items to be selected
     * @param {?=} options Object with set of options controlling the behavior of this api method.
     * closeDropDown (boolean): Set to true to close the drop down list after the selection.
     * focusCombo (boolean): Set to true to focus combo after the selection.
     * additive (boolean): Set to true to select the item without losing other selection. Works only when multi selection is enabled.
     * keepFiltering (boolean): Set to true to keep filtering after the selection. By default the filtering is cleared.
     * keepInputText (boolean): Set to true to keep input text unchanged after the selection. By default input text is updated.
     * keepHighlighting (boolean): Set to true to keep highlighting unchanged after the selection. By default highlighting is removed.
     * keepNavItem (boolean): Set to true to keep current navigation item unchanged after the selection. By default the navigation item is changed to the new selected item.
     * keepScrollPosition (boolean): Set to true to keep current scroll position. By default the scroll position will change so that the last selected item is visible.
     * @param {?=} event Indicates the browser event which triggered this action (not API). Calling the method with this param set to "true" will trigger [selectionChanging](ui.igcombo#events:selectionChanging) and [selectionChanged](ui.igcombo#events:selectionChanged) events.
     * @return {?}
     */
    /* istanbul ignore next */
    index(index, options, event) { return; }
    ;
    /**
     * Selects all items from the drop-down list.
     *
     * @param {?=} options Object with set of options controlling the behavior of this api method.
     * closeDropDown (boolean): Set to true to close the drop down list after the selection.
     * focusCombo (boolean): Set to true to focus combo after the selection.
     * keepFiltering (boolean): Set to true to keep filtering after the selection. By default the filtering is cleared.
     * keepInputText (boolean): Set to true to keep input text unchanged after the selection. By default input text is updated.
     * keepHighlighting (boolean): Set to true to keep highlighting unchanged after the selection. By default highlighting is removed.
     * keepNavItem (boolean): Set to true to keep current navigation item unchanged after the selection. By default the navigation item is changed to the new selected item.
     * keepScrollPosition (boolean): Set to true to keep current scroll position. By default the scroll position will change so that the last selected item is visible.
     * @param {?=} event Indicates the browser event which triggered this action (not API). Calling the method with this param set to "true" will trigger [selectionChanging](ui.igcombo#events:selectionChanging) and [selectionChanged](ui.igcombo#events:selectionChanged) events.
     * @return {?}
     */
    /* istanbul ignore next */
    selectAll(options, event) { return; }
    ;
    /**
     * Deselects a list item from the drop down list by value.
     *
     * @param {?} value Value or array of values matching the [valueKey](ui.igcombo#options:valueKey) property of item/items to be deselected
     * @param {?=} options Object with set of options controlling the behavior of this api method.
     * focusCombo (boolean): Set to true to focus combo after the deselection.
     * keepInputText (boolean): Set to true to keep input text unchanged after the deselection. By default input text is updated.
     * @param {?=} event Indicates the browser event which triggered this action (not API). Calling the method with this param set to "true" will trigger [selectionChanging](ui.igcombo#events:selectionChanging) and [selectionChanged](ui.igcombo#events:selectionChanged) events.
     * @return {?}
     */
    /* istanbul ignore next */
    deselectByValue(value, options, event) { return; }
    ;
    /**
     * Deselects a list item from the drop down list.
     *
     * @param {?} $items jQuery object with item or items to be deselected
     * @param {?=} options Object with set of options controlling the behavior of this api method.
     * focusCombo (boolean): Set to true to focus combo after the deselection.
     * keepInputText (boolean): Set to true to keep input text unchanged after the deselection. By default input text is updated.
     * @param {?=} event Indicates the browser event which triggered this action (not API). Calling the method with this param set to "true" will trigger [selectionChanging](ui.igcombo#events:selectionChanging) and [selectionChanged](ui.igcombo#events:selectionChanged) events.
     * @return {?}
     */
    /* istanbul ignore next */
    deselect($items, options, event) { return; }
    ;
    /**
     * Deselects a list item from the drop down list by index.
     *
     * @param {?} index Index or array of indexes of items to be selected
     * @param {?=} options Object with set of options controlling the behavior of this api method.
     * focusCombo (boolean): Set to true to focus combo after the deselection.
     * keepInputText (boolean): Set to true to keep input text unchanged after the deselection. By default input text is updated.
     * @param {?=} event Indicates the browser event which triggered this action (not API). Calling the method with this param set to "true" will trigger [selectionChanging](ui.igcombo#events:selectionChanging) and [selectionChanged](ui.igcombo#events:selectionChanged) events.
     * @return {?}
     */
    /* istanbul ignore next */
    deselectByIndex(index, options, event) { return; }
    ;
    /**
     * Deselects all selected items from the drop down list.
     *
     * @param {?=} options Object with set of options controlling the behavior of this api method.
     * focusCombo (boolean): Set to true to focus combo after the deselection.
     * keepInputText (boolean): Set to true to keep input text unchanged after the deselection. By default input text is updated.
     * @param {?=} event Indicates the browser event which triggered this action (not API). Calling the method with this param set to "true" will trigger [selectionChanging](ui.igcombo#events:selectionChanging) and [selectionChanged](ui.igcombo#events:selectionChanged) events.
     * @return {?}
     */
    /* istanbul ignore next */
    deselectAll(options, event) { return; }
    ;
    /**
     * Gets/Sets index of active item in list.
     *
     * @param {?=} index New active index for list. In order to clear active item, use -1.
     * @return {?} number|object Returns index of active item in list or -1, if parameter is undefined. Otherwise, it returns reference to this igCombo.
     */
    /* istanbul ignore next */
    activeIndex(index) { return; }
    ;
    /**
     * Gets/Sets text in text input field.
     *
     * @param {?=} text New text value for combo's input field.
     * @return {?} string|object If parameter is undefined, then current text in field is returned. Otherwise, it returns reference to this igCombo.
     */
    /* istanbul ignore next */
    text(text) { return; }
    ;
    /**
     * Gets/Sets scrollTop attribute of html element, which scrolls drop-down list of items.
     *
     * @param {?=} value New value for scroll top in list. Note: if list is closed and new value is provided, then openDropDown() is called automatically.
     * @return {?} number|object If parameter is undefined, then scrollTop is returned. Otherwise, it returns reference to this igCombo.
     */
    /* istanbul ignore next */
    listScrollTop(value) { return; }
    ;
    /**
     * Gets jQuery objects representing all rendered list items in the combo drop down list.
     * @return {?}
     */
    /* istanbul ignore next */
    listItems() { return; }
    ;
    /**
     * Gets jQuery object of the outer element of the combo.
     * @return {?}
     */
    /* istanbul ignore next */
    comboWrapper() { return; }
    ;
    /**
     * Gets jQuery object of the drop down associated with this combo widget
     * @return {?}
     */
    /* istanbul ignore next */
    dropDown() { return; }
    ;
    /**
     * Gets jQuery object of the container that holds the list with items.
     * @return {?}
     */
    /* istanbul ignore next */
    list() { return; }
    ;
    /**
     * Gets jQuery object of the text input associated with this combo widget.
     * @return {?}
     */
    /* istanbul ignore next */
    textInput() { return; }
    ;
    /**
     * Gets jQuery object of the value input associated with this combo widget.
     * @return {?}
     */
    /* istanbul ignore next */
    valueInput() { return; }
    ;
    /**
     * Gets reference to [igValidator](ui.igvalidator) used by igCombo.
     *
     * @param {?=} destroy Request to destroy validator.
     * @return {?}
     */
    /* istanbul ignore next */
    validator(destroy) { return; }
    ;
    /**
     * Trigger validation.
     * @return {?}
     */
    /* istanbul ignore next */
    validate() { return; }
    ;
    /**
     * Returns boolean representing whether the combo drop down list is opened.
     * @return {?}
     */
    /* istanbul ignore next */
    dropDownOpened() { return; }
    ;
    /**
     * Repositions drop down under combo input. Has effect only when the drop down is attached to body.
     * @return {?}
     */
    /* istanbul ignore next */
    positionDropDown() { return; }
    ;
    /**
     * Destroys the igCombo widget.
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
}
IgComboComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-combo",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "width", "height", "dropDownWidth", "dataSource", "dataSourceType", "dataSourceUrl", "responseTotalRecCountKey", "responseDataKey", "responseDataType", "responseContentType", "requestType", "valueKey", "textKey", "itemTemplate", "headerTemplate", "footerTemplate", "inputName", "animationShowDuration", "animationHideDuration", "dropDownAttachedToBody", "filteringType", "filterExprUrlKey", "filteringCondition", "filteringLogic", "noMatchFoundText", "loadOnDemandSettings", "visibleItemsCount", "placeHolder", "mode", "virtualization", "multiSelection", "grouping", "validatorOptions", "highlightMatchesMode", "caseSensitive", "autoSelectFirstMatch", "autoComplete", "allowCustomValue", "closeDropDownOnBlur", "delayInputChangeProcessing", "tabIndex", "dropDownOnFocus", "closeDropDownOnSelect", "selectItemBySpaceKey", "initialSelectedItems", "preventSubmitOnEnter", "format", "suppressKeyboard", "enableClearButton", "dropDownButtonTitle", "clearButtonTitle", "dropDownOrientation"],
                outputs: ["rendered", "dataBinding", "dataBound", "filtering", "filtered", "itemsRendering", "itemsRendered", "dropDownOpening", "dropDownOpened", "dropDownClosing", "dropDownClosed", "selectionChanging", "selectionChanged"]
            }] }
];
/** @nocollapse */
IgComboComponent.ctorParameters = () => [
    { type: NgModel, decorators: [{ type: Optional }] },
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];
IgComboComponent.propDecorators = {
    dataSource: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    IgComboComponent.prototype._dataSource;
    /**
     * @type {?}
     * @protected
     */
    IgComboComponent.prototype._model;
    /**
     * @type {?}
     * @private
     */
    IgComboComponent.prototype._changes;
    /** @type {?} */
    IgComboComponent.prototype.onChange;
    /** @type {?} */
    IgComboComponent.prototype.onTouched;
    /** @type {?} */
    IgComboComponent.prototype.model;
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWdjb21iby5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLXdyYXBwZXJzLyIsInNvdXJjZXMiOlsibGliL2lnY29tYm8vaWdjb21iby5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsZUFBZSxFQUFFLGVBQWUsRUFBRSxpQkFBaUIsRUFBaUIsS0FBSyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3JKLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUMvRCxPQUFPLEVBQXdCLE9BQU8sRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBVS9ELE1BQU0sT0FBTyxnQkFBaUIsU0FBUSxhQUFzQjs7Ozs7Ozs7O0lBWXhELFlBQStCLEtBQWMsRUFBRSxFQUFjLEVBQUUsUUFBa0IsRUFBRSxPQUF3QixFQUFFLFdBQTRCLEVBQUUsR0FBc0I7UUFDN0osS0FBSyxDQUFDLEVBQUUsRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLFdBQVcsRUFBRSxHQUFHLENBQUMsQ0FBQztRQURwQixVQUFLLEdBQUwsS0FBSyxDQUFTO1FBK0Q3QyxhQUFROzs7O1FBQUcsQ0FBQyxDQUFNLEVBQUUsRUFBRTtRQUN0QixDQUFDLEVBQUM7UUFDRixjQUFTOzs7UUFBRyxHQUFHLEVBQUU7UUFDakIsQ0FBQyxFQUFDO1FBaEVFLElBQUksS0FBSyxFQUFFO1lBQ1AsS0FBSyxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUM7WUFDM0IsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7U0FDdkI7SUFDTCxDQUFDOzs7OztJQWhCRCxJQUNXLFVBQVUsQ0FBQyxLQUFVO1FBQzVCLElBQUksQ0FBQyxXQUFXLEdBQUcsS0FBSyxDQUFDO0lBQzdCLENBQUM7SUFBQSxDQUFDOzs7O0lBZUYsUUFBUTs7WUFDQSxJQUFJLEdBQUcsSUFB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QUFFLGtCQUFrQixFQUFFLHNCQUFzQixFQUFFLGVBQWUsRUFBRSxzQkFBc0IsRUFBRSxjQUFjLEVBQUUsa0JBQWtCLEVBQUUscUJBQXFCLEVBQUUsNEJBQTRCLEVBQUUsVUFBVSxFQUFFLGlCQUFpQixFQUFFLHVCQUF1QixFQUFFLHNCQUFzQixFQUFFLHNCQUFzQixFQUFFLHNCQUFzQixFQUFFLFFBQVEsRUFBRSxrQkFBa0IsRUFBRSxtQkFBbUIsRUFBRSxxQkFBcUIsRUFBRSxrQkFBa0IsRUFBRSxxQkFBcUIsQ0FBQztnQkFDMWlDLE9BQU8sRUFBRSxDQUFDLFVBQVUsRUFBRSxhQUFhLEVBQUUsV0FBVyxFQUFFLFdBQVcsRUFBRSxVQUFVLEVBQUUsZ0JBQWdCLEVBQUUsZUFBZSxFQUFFLGlCQUFpQixFQUFFLGdCQUFnQixFQUFFLGlCQUFpQixFQUFFLGdCQUFnQixFQUFFLG1CQUFtQixFQUFFLGtCQUFrQixDQUFDO2FBQ25POzs7O1lBVDhCLE9BQU8sdUJBc0JyQixRQUFRO1lBeEJLLFVBQVU7WUFBRSxRQUFRO1lBQUUsZUFBZTtZQUFFLGVBQWU7WUFBRSxpQkFBaUI7Ozt5QkFjbEcsS0FBSzs7Ozs7OztJQUtOLHVDQUF5Qjs7Ozs7SUFFekIsa0NBQXNCOzs7OztJQUN0QixvQ0FBc0I7O0lBaUV0QixvQ0FDRTs7SUFDRixxQ0FDRTs7SUFsRVUsaUNBQWlDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBPcHRpb25hbCwgRWxlbWVudFJlZiwgUmVuZGVyZXIsIEl0ZXJhYmxlRGlmZmVycywgS2V5VmFsdWVEaWZmZXJzLCBDaGFuZ2VEZXRlY3RvclJlZiwgU2ltcGxlQ2hhbmdlcywgSW5wdXQgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgSWdDb250cm9sQmFzZSB9IGZyb20gXCIuLi9pZ2NvbnRyb2xiYXNlL2lnY29udHJvbGJhc2VcIjtcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOZ01vZGVsIH0gZnJvbSBcIkBhbmd1bGFyL2Zvcm1zXCI7XG5cbmRlY2xhcmUgdmFyIGpRdWVyeTogYW55O1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogXCJpZy1jb21ib1wiLFxuICAgIHRlbXBsYXRlOiBcIjxuZy1jb250ZW50PjwvbmctY29udGVudD5cIixcbiAgICBpbnB1dHM6IFtcIndpZGdldElkXCIsIFwib3B0aW9uc1wiLCBcImNoYW5nZURldGVjdGlvbkludGVydmFsXCIsIFwiZGlzYWJsZWRcIiwgXCJjcmVhdGVcIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiLCBcImRyb3BEb3duV2lkdGhcIiwgXCJkYXRhU291cmNlXCIsIFwiZGF0YVNvdXJjZVR5cGVcIiwgXCJkYXRhU291cmNlVXJsXCIsIFwicmVzcG9uc2VUb3RhbFJlY0NvdW50S2V5XCIsIFwicmVzcG9uc2VEYXRhS2V5XCIsIFwicmVzcG9uc2VEYXRhVHlwZVwiLCBcInJlc3BvbnNlQ29udGVudFR5cGVcIiwgXCJyZXF1ZXN0VHlwZVwiLCBcInZhbHVlS2V5XCIsIFwidGV4dEtleVwiLCBcIml0ZW1UZW1wbGF0ZVwiLCBcImhlYWRlclRlbXBsYXRlXCIsIFwiZm9vdGVyVGVtcGxhdGVcIiwgXCJpbnB1dE5hbWVcIiwgXCJhbmltYXRpb25TaG93RHVyYXRpb25cIiwgXCJhbmltYXRpb25IaWRlRHVyYXRpb25cIiwgXCJkcm9wRG93bkF0dGFjaGVkVG9Cb2R5XCIsIFwiZmlsdGVyaW5nVHlwZVwiLCBcImZpbHRlckV4cHJVcmxLZXlcIiwgXCJmaWx0ZXJpbmdDb25kaXRpb25cIiwgXCJmaWx0ZXJpbmdMb2dpY1wiLCBcIm5vTWF0Y2hGb3VuZFRleHRcIiwgXCJsb2FkT25EZW1hbmRTZXR0aW5nc1wiLCBcInZpc2libGVJdGVtc0NvdW50XCIsIFwicGxhY2VIb2xkZXJcIiwgXCJtb2RlXCIsIFwidmlydHVhbGl6YXRpb25cIiwgXCJtdWx0aVNlbGVjdGlvblwiLCBcImdyb3VwaW5nXCIsIFwidmFsaWRhdG9yT3B0aW9uc1wiLCBcImhpZ2hsaWdodE1hdGNoZXNNb2RlXCIsIFwiY2FzZVNlbnNpdGl2ZVwiLCBcImF1dG9TZWxlY3RGaXJzdE1hdGNoXCIsIFwiYXV0b0NvbXBsZXRlXCIsIFwiYWxsb3dDdXN0b21WYWx1ZVwiLCBcImNsb3NlRHJvcERvd25PbkJsdXJcIiwgXCJkZWxheUlucHV0Q2hhbmdlUHJvY2Vzc2luZ1wiLCBcInRhYkluZGV4XCIsIFwiZHJvcERvd25PbkZvY3VzXCIsIFwiY2xvc2VEcm9wRG93bk9uU2VsZWN0XCIsIFwic2VsZWN0SXRlbUJ5U3BhY2VLZXlcIiwgXCJpbml0aWFsU2VsZWN0ZWRJdGVtc1wiLCBcInByZXZlbnRTdWJtaXRPbkVudGVyXCIsIFwiZm9ybWF0XCIsIFwic3VwcHJlc3NLZXlib2FyZFwiLCBcImVuYWJsZUNsZWFyQnV0dG9uXCIsIFwiZHJvcERvd25CdXR0b25UaXRsZVwiLCBcImNsZWFyQnV0dG9uVGl0bGVcIiwgXCJkcm9wRG93bk9yaWVudGF0aW9uXCJdLFxuICAgIG91dHB1dHM6IFtcInJlbmRlcmVkXCIsIFwiZGF0YUJpbmRpbmdcIiwgXCJkYXRhQm91bmRcIiwgXCJmaWx0ZXJpbmdcIiwgXCJmaWx0ZXJlZFwiLCBcIml0ZW1zUmVuZGVyaW5nXCIsIFwiaXRlbXNSZW5kZXJlZFwiLCBcImRyb3BEb3duT3BlbmluZ1wiLCBcImRyb3BEb3duT3BlbmVkXCIsIFwiZHJvcERvd25DbG9zaW5nXCIsIFwiZHJvcERvd25DbG9zZWRcIiwgXCJzZWxlY3Rpb25DaGFuZ2luZ1wiLCBcInNlbGVjdGlvbkNoYW5nZWRcIl1cbn0pXG5leHBvcnQgY2xhc3MgSWdDb21ib0NvbXBvbmVudCBleHRlbmRzIElnQ29udHJvbEJhc2U8SWdDb21ibz4gaW1wbGVtZW50cyBDb250cm9sVmFsdWVBY2Nlc3NvciB7XG5cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZXQgZGF0YVNvdXJjZSh2YWx1ZTogYW55KSB7XG4gICAgICAgIHRoaXMuX2RhdGFTb3VyY2UgPSB2YWx1ZTtcbiAgICB9O1xuXG4gICAgcHJpdmF0ZSBfZGF0YVNvdXJjZTogYW55O1xuXG4gICAgcHJvdGVjdGVkIF9tb2RlbDogYW55O1xuICAgIHByaXZhdGUgX2NoYW5nZXM6IGFueTtcblxuICAgIGNvbnN0cnVjdG9yKEBPcHRpb25hbCgpIHB1YmxpYyBtb2RlbDogTmdNb2RlbCwgZWw6IEVsZW1lbnRSZWYsIHJlbmRlcmVyOiBSZW5kZXJlciwgZGlmZmVyczogSXRlcmFibGVEaWZmZXJzLCBrdmFsRGlmZmVyczogS2V5VmFsdWVEaWZmZXJzLCBjZHI6IENoYW5nZURldGVjdG9yUmVmKSB7XG4gICAgICAgIHN1cGVyKGVsLCByZW5kZXJlciwgZGlmZmVycywga3ZhbERpZmZlcnMsIGNkcik7XG4gICAgICAgIGlmIChtb2RlbCkge1xuICAgICAgICAgICAgbW9kZWwudmFsdWVBY2Nlc3NvciA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl9tb2RlbCA9IG1vZGVsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGxldCB0aGF0ID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX2RhdGFTb3VyY2UgPT09IG51bGwgfHwgdGhpcy5fZGF0YVNvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9kYXRhU291cmNlID0gdGhpcy5vcHRpb25zW1wiZGF0YVNvdXJjZVwiXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMub3B0aW9uc1tcImRhdGFTb3VyY2VcIl0gJiYgdGhpcy5fZGF0YVNvdXJjZSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zW1wiZGF0YVNvdXJjZVwiXSA9IHRoaXMuX2RhdGFTb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcblxuICAgICAgICBpZiAodGhpcy5fbW9kZWwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWxsb3dDdXN0b21WYWx1ZSkge1xuICAgICAgICAgICAgICAgIGpRdWVyeSh0aGlzLl9lbCkub24oXCJpbnB1dFwiLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuX21vZGVsLnZpZXdUb01vZGVsVXBkYXRlKGV2dC50YXJnZXQudmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgIFxuICAgICAgICAgICAgICAgIGpRdWVyeSh0aGlzLl9lbCkuY2xvc2VzdChcIi51aS1pZ2NvbWJvLXdyYXBwZXJcIikuZmluZChcIi51aS1pZ2NvbWJvLWNsZWFyXCIpLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGF0Lm9wdGlvbnMubXVsdGlTZWxlY3Rpb24gJiYgdGhhdC5vcHRpb25zLm11bHRpU2VsZWN0aW9uLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX21vZGVsLnZpZXdUb01vZGVsVXBkYXRlKFtdKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX21vZGVsLnZpZXdUb01vZGVsVXBkYXRlKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEQuUC4gIzI0NCBvbmx5IGF0dGFjaCBzZWxlY3Rpb25jaGFuZ2VkIGhhbmRsZXIgaWYgdGhlcmUncyBhIG1vZGVsIHRvIHVwZGF0ZVxuICAgICAgICAgICAgalF1ZXJ5KHRoaXMuX2VsKS5vbih0aGlzLl93aWRnZXROYW1lLnRvTG93ZXJDYXNlKCkgKyBcInNlbGVjdGlvbmNoYW5nZWRcIiwgZnVuY3Rpb24gKGV2dCwgdWkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbXMgPSB1aS5pdGVtcztcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZUtleSA9IHVpLm93bmVyLm9wdGlvbnMudmFsdWVLZXk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoIDw9IDAgJiYgIXVpLm93bmVyLm9wdGlvbnMubXVsdGlTZWxlY3Rpb24uZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXVpLm93bmVyLm9wdGlvbnMuYWxsb3dDdXN0b21WYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fbW9kZWwudmlld1RvTW9kZWxVcGRhdGUobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh1aS5vd25lci5vcHRpb25zLm11bHRpU2VsZWN0aW9uLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5fbW9kZWwudmlld1RvTW9kZWxVcGRhdGUoaXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5kYXRhW3ZhbHVlS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuX21vZGVsLnZpZXdUb01vZGVsVXBkYXRlKGl0ZW1zWzBdLmRhdGFbdmFsdWVLZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vbWFudWFsbHkgY2FsbCB3cml0ZVZhbHVlLCBiZWNhdXNlIHRoZSBMaWZlQ3ljbGUgaGFzIGJlZW4gY2hhbmdlZCBhbmQgd3JpdGVWYWx1ZSBpcyBleGVjdXRlZCBiZWZvcmUgbmdPbkluaXRcbiAgICAgICAgICAgIHRoaXMud3JpdGVWYWx1ZSh0aGlzLl9tb2RlbC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd3JpdGVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAoISFqUXVlcnkodGhpcy5fZWwpLmRhdGEodGhpcy5fd2lkZ2V0TmFtZSkpIHtcbiAgICAgICAgICAgIGpRdWVyeSh0aGlzLl9lbClbdGhpcy5fd2lkZ2V0TmFtZV0oXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkNoYW5nZSA9IChfOiBhbnkpID0+IHtcbiAgICB9O1xuICAgIG9uVG91Y2hlZCA9ICgpID0+IHtcbiAgICB9O1xuXG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbjogKCkgPT4gYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSBmbjtcbiAgICB9XG5cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbjogKCkgPT4gYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkID0gZm47XG4gICAgfVxuXG4gICAgZGF0YVNvdXJjZUFwcGx5Q2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIC8vZGF0YVNvdXJjZSBoYXMgY2hhbmdlZC5cbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGpRdWVyeSh0aGlzLl9lbCk7XG4gICAgICAgIGlmIChlbGVtZW50W3RoaXMuX3dpZGdldE5hbWVdKSB7XG4gICAgICAgICAgICBlbGVtZW50W3RoaXMuX3dpZGdldE5hbWVdKFwib3B0aW9uXCIsIFwiZGF0YVNvdXJjZVwiLCB0aGlzLl9kYXRhU291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tb2RlbCAmJiB0aGlzLm1vZGVsLnZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlVmFsdWUodGhpcy5tb2RlbC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlQ29tYm9JdGVtKHJlYywgdmFsLCBrZXksIGluZGV4KSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBqUXVlcnkodGhpcy5fZWwpO1xuICAgICAgICBjb25zdCBjb21ib0l0ZW0gPSBlbGVtZW50LmRhdGEoXCJpZ0NvbWJvXCIpLml0ZW1zRnJvbUluZGV4KGluZGV4KTtcbiAgICAgICAgZWxlbWVudC5kYXRhKFwiaWdDb21ib1wiKS5fdXBkYXRlSXRlbShjb21ib0l0ZW0uZWxlbWVudCwgcmVjKTtcbiAgICAgICAgaWYgKGVsZW1lbnQuZGF0YShcImlnQ29tYm9cIikuaXNTZWxlY3RlZChjb21ib0l0ZW0uZWxlbWVudCkpIHtcbiAgICAgICAgICAgIC8vc2hvdWxkIHVwZGF0ZSB0aGUgaW5wdXRcbiAgICAgICAgICAgIGVsZW1lbnQuZGF0YShcImlnQ29tYm9cIikuX3VwZGF0ZUlucHV0VmFsdWVzKGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgfVxuICAgIHB1YmxpYyBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGRzID0gXCJkYXRhU291cmNlXCI7XG4gICAgICAgIGlmIChkcyBpbiBjaGFuZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGNoYW5nZXNbZHNdLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpZmZlciA9IHRoaXMuX2RpZmZlcnMuZmluZCh2YWx1ZSkuY3JlYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9kYXRhU291cmNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VzLnB1c2godGhpcy5rdmFsRGlmZmVycy5maW5kKHt9KS5jcmVhdGUoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSBiaW5kaW5nIHRvIGFycmF5cyBpcyBzdXBwb3J0ZWQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdXBlci5uZ09uQ2hhbmdlcyhjaGFuZ2VzKTtcbiAgICB9XG4gICAgbmdEb0NoZWNrKCkge1xuICAgICAgICBpZiAodGhpcy5fZGlmZmVyKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VzID0gdGhpcy5fZGlmZmVyLmRpZmYodGhpcy5fZGF0YVNvdXJjZSk7XG4gICAgICAgICAgICAvL2NoZWNrIGlmIGdyaWQgaXMgaW5pdGlhbGl6ZWRcbiAgICAgICAgICAgIGNvbnN0IGNvbWJvID0galF1ZXJ5KHRoaXMuX2VsKS5kYXRhKHRoaXMuX3dpZGdldE5hbWUpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZXMgJiYgY29tYm8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2VBcHBseUNoYW5nZXMoY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fY2hhbmdlcyAmJiBjb21ibykge1xuICAgICAgICAgICAgICAgIC8vY2hlY2sgcmVjc1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZGF0YVNvdXJjZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuX2RhdGFTb3VyY2VbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWNDaGFuZ2VzID0gdGhpcy5fY2hhbmdlc1tpXS5kaWZmKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjQ2hhbmdlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjQ2hhbmdlcy5mb3JFYWNoQ2hhbmdlZEl0ZW0oKGNoYW5nZTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDb21ib0l0ZW0oaXRlbSwgY2hhbmdlLmN1cnJlbnRWYWx1ZSwgY2hhbmdlLmtleSwgaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdXBlci5uZ0RvQ2hlY2soKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBkYXRhYmluZGluZyBvbiB0aGUgY29tYm8gYm94LiBUaGUgW2RhdGFiaW5kaW5nXSh1aS5pZ2NvbWJvI2V2ZW50czpkYXRhQmluZGluZykgYW5kIFtkYXRhQm91bmRdKHVpLmlnY29tYm8jZXZlbnRzOmRhdGFCb3VuZCkgZXZlbnRzIGFyZSBhbHdheXMgcmFpc2VkLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGRhdGFCaW5kKCk6IE9iamVjdCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIEZvcmNlcyBhbiB1cGRhdGUgb2YgdGhlIGlnQ29tYm8gdmFsdWUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHRleHQgaW4gdGhlIGlnQ29tYm8gaW5wdXQuXG4gICAgICogICAgICAgICAgICAgXG4gICAgICogXHRcdFx0XHRUaGUgcmVmcmVzaCBpcyBwcmltYXJpbHkgaW50ZW5kZWQgdG8gYmUgdXNlZCB3aXRoIFthbGxvd0N1c3RvbVZhbHVlXSh1aS5pZ2NvbWJvI29wdGlvbnM6YWxsb3dDdXN0b21WYWx1ZSkgc2V0IHRvIHRydWUuXG4gICAgICogXHRcdFx0XHRUaGUgcmVmcmVzaCB3aWxsIHRha2UgdGhlIGN1cnJlbnQgdGV4dCBhbmQsIGlmIG5vIHNlbGVjdGlvbiBpcyBhcHBsaWVkLCB3aWxsIHNldCBpdCBhcyBpZ0NvbWJvIHZhbHVlIHByb3ZpZGVkIHRoYXQgW2FsbG93Q3VzdG9tVmFsdWVdKHVpLmlnY29tYm8jb3B0aW9uczphbGxvd0N1c3RvbVZhbHVlKSB0cnVlLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIHJlZnJlc2hWYWx1ZSgpOiBPYmplY3QgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhc3NvY2lhdGVkIGRhdGEgb2YgYW4gaXRlbSBieSB2YWx1ZSBtYXRjaGluZyBpdCdzIFt2YWx1ZUtleV0odWkuaWdjb21ibyNvcHRpb25zOnZhbHVlS2V5KSBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSBtYXRjaGluZyB0aGUgdmFsdWVLZXkgcHJvcGVydHkgb2YgaXRlbSB0byBiZSB0ZXN0ZWQgaWYgaXQgaXMgc2VsZWN0ZWRcbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBkYXRhRm9yVmFsdWUodmFsdWU6IE9iamVjdCk6IE9iamVjdCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFzc29jaWF0ZWQgZGF0YSBvZiBsaSBlbGVtZW50IGluIHRoZSBjb21iby5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAkZWxlbWVudCBqUXVlcnkgZWxlbWVudCBvZiBpdGVtIGluIHRoZSBkcm9wIGRvd24gbGlzdFxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGRhdGFGb3JFbGVtZW50KCRlbGVtZW50OiBPYmplY3QpOiBPYmplY3QgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIG9iamVjdC9zIGNvbnRhaW5pbmcgZGF0YSBhbmQgbGlzdCBpdGVtIGluIHRoZSBjb21ibyBieSBlbGVtZW50L3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gJGVsZW1lbnQgalF1ZXJ5IG9iamVjdCB3aXRoIGRyb3AgZG93biBsaXN0IGl0ZW0gZWxlbWVudCBvciBlbGVtZW50c1xuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGl0ZW1zRnJvbUVsZW1lbnQoJGVsZW1lbnQ6IE9iamVjdCk6IE9iamVjdCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgb2JqZWN0L3MgY29udGFpbmluZyBkYXRhIGFuZCBsaXN0IGl0ZW0gaW4gdGhlIGNvbWJvIGJ5IHZhbHVlL3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgVmFsdWUgb2YgaXRlbSBpbiB0aGUgZHJvcCBkb3duIGxpc3Qgb3IgYXJyYXkgd2l0aCB2YWx1ZXMuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgaXRlbXNGcm9tVmFsdWUodmFsdWU6IE9iamVjdCk6IE9iamVjdCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgb2JqZWN0L3MgY29udGFpbmluZyBkYXRhIGFuZCBsaXN0IGl0ZW0gaW4gdGhlIGNvbWJvIGJ5IGluZGV4L2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4IEluZGV4IG9yIGFycmF5IG9mIGluZGV4ZXMgb2YgaXRlbXMgaW4gdGhlIGRyb3AgZG93biBsaXN0XG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgaXRlbXNGcm9tSW5kZXgoaW5kZXg6IG51bWJlcik6IE9iamVjdCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgYXJyYXkgd2l0aCBkYXRhIGFuZCBvYmplY3RzIHJlcHJlc2VudGluZyBsaSBlbGVtZW50cyBpbiBjb21ibyBib3guXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgaXRlbXMoKTogYW55W10geyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFycmF5IHdpdGggb2JqZWN0cyByZXByZXNlbnRpbmcgdGhlIGZpbHRlcmVkIGxpIGVsZW1lbnRzIGluIGNvbWJvIGJveC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBmaWx0ZXJlZEl0ZW1zKCk6IGFueVtdIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyBhcnJheSB3aXRoIG9iamVjdHMgcmVwcmVzZW50aW5nIHNlbGVjdGVkIGxpIGVsZW1lbnRzIGluIGNvbWJvIGJveC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBzZWxlY3RlZEl0ZW1zKCk6IGFueVtdIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcnMgZmlsdGVyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRleHRzIEZpbHRlciBieSBzdHJpbmcsIG9yIGFycmF5IG9mIHN0cmluZ3MuXG4gICAgICogQHBhcmFtIGV2ZW50IEluZGljYXRlcyB0aGUgYnJvd3NlciBldmVudCB3aGljaCB0cmlnZ2VyZWQgdGhpcyBhY3Rpb24gKG5vdCBBUEkpLiBDYWxsaW5nIHRoZSBtZXRob2Qgd2l0aCB0aGlzIHBhcmFtIHNldCB0byBcInRydWVcIiB3aWxsIHRyaWdnZXIgW2ZpbHRlcmluZ10odWkuaWdjb21ibyNldmVudHM6ZmlsdGVyaW5nKSBhbmQgW2ZpbHRlcmVkXSh1aS5pZ2NvbWJvI2V2ZW50czpmaWx0ZXJlZCkgZXZlbnRzLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGZpbHRlcih0ZXh0cz86IE9iamVjdCwgZXZlbnQ/OiBPYmplY3QpOiBPYmplY3QgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgZmlsdGVyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IEluZGljYXRlcyB0aGUgYnJvd3NlciBldmVudCB3aGljaCB0cmlnZ2VyZWQgdGhpcyBhY3Rpb24gKG5vdCBBUEkpLiBDYWxsaW5nIHRoZSBtZXRob2Qgd2l0aCB0aGlzIHBhcmFtIHNldCB0byBcInRydWVcIiB3aWxsIHRyaWdnZXIgW2ZpbHRlcmluZ10odWkuaWdjb21ibyNldmVudHM6ZmlsdGVyaW5nKSBhbmQgW2ZpbHRlcmVkXSh1aS5pZ2NvbWJvI2V2ZW50czpmaWx0ZXJlZCkgZXZlbnRzLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGNsZWFyRmlsdGVyaW5nKGV2ZW50PzogT2JqZWN0KTogT2JqZWN0IHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogT3BlbnMgdGhlIGRyb3AtZG93bi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBTcGVjaWZpZXMgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgd2hlbiBvcGVuIGFuaW1hdGlvbiBpcyBjb21wbGV0ZWQuXG4gICAgICogQHBhcmFtIGZvY3VzQ29tYm8gU2V0IHRvIGZhbHNlIHRvIG5vdCBmb2N1cyBjb21ib1wicyB0ZXh0IGlucHV0IGFmdGVyIHRoZSBkcm9wIGRvd24gaXMgb3BlbmVkLiBCeSBkZWZhdWx0IHRoZSBjb21ibydzIGlucHV0IGlzIGZvY3VzZWQuXG4gICAgICogQHBhcmFtIGV2ZW50IEluZGljYXRlcyB0aGUgYnJvd3NlciBldmVudCB3aGljaCB0cmlnZ2VyZWQgdGhpcyBhY3Rpb24gKG5vdCBBUEkpLiBDYWxsaW5nIHRoZSBtZXRob2Qgd2l0aCB0aGlzIHBhcmFtIHNldCB0byBcInRydWVcIiB3aWxsIHRyaWdnZXIgW2Ryb3BEb3duT3BlbmluZ10odWkuaWdjb21ibyNldmVudHM6ZHJvcERvd25PcGVuaW5nKSBhbmQgW2Ryb3BEb3duT3BlbmVkXSh1aS5pZ2NvbWJvI2V2ZW50czpkcm9wRG93bk9wZW5lZCkgZXZlbnRzLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIG9wZW5Ecm9wRG93bihjYWxsYmFjaz86IEZ1bmN0aW9uLCBmb2N1c0NvbWJvPzogYm9vbGVhbiwgZXZlbnQ/OiBPYmplY3QpOiBPYmplY3QgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIGRyb3AgZG93bi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBTcGVjaWZpZXMgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgd2hlbiBjbG9zZSBhbmltYXRpb24gaXMgY29tcGxldGVkLlxuICAgICAqIEBwYXJhbSBldmVudCBJbmRpY2F0ZXMgdGhlIGJyb3dzZXIgZXZlbnQgd2hpY2ggdHJpZ2dlcmVkIHRoaXMgYWN0aW9uIChub3QgQVBJKS4gQ2FsbGluZyB0aGUgbWV0aG9kIHdpdGggdGhpcyBwYXJhbSBzZXQgdG8gXCJ0cnVlXCIgd2lsbCB0cmlnZ2VyIFtkcm9wRG93bkNsb3NpbmddKHVpLmlnY29tYm8jZXZlbnRzOmRyb3BEb3duQ2xvc2luZykgYW5kIFtkcm9wRG93bkNsb3NlZF0odWkuaWdjb21ibyNldmVudHM6ZHJvcERvd25DbG9zZWQpIGV2ZW50cy5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBjbG9zZURyb3BEb3duKGNhbGxiYWNrPzogRnVuY3Rpb24sIGV2ZW50PzogT2JqZWN0KTogT2JqZWN0IHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBpbnB1dCB0ZXh0LCByZXNldHMgaGlnaGxpZ2h0aW5nLCBmaWx0ZXJpbmcgYW5kIHNlbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zICAgICBPYmplY3Qgd2l0aCBzZXQgb2Ygb3B0aW9ucyBjb250cm9sbGluZyB0aGUgYmVoYXZpb3Igb2YgdGhpcyBhcGkgbWV0aG9kLlxuICAgICBmb2N1c0NvbWJvIChib29sZWFuKTogU2V0IHRvIHRydWUgdG8gZm9jdXMgY29tYm8gYWZ0ZXIgY2xlYXJpbmcgdGhlIGlucHV0LlxuICAgICogQHBhcmFtIGV2ZW50IEluZGljYXRlcyB0aGUgYnJvd3NlciBldmVudCB3aGljaCB0cmlnZ2VyZWQgdGhpcyBhY3Rpb24gKG5vdCBBUEkpLiBDYWxsaW5nIHRoZSBtZXRob2Qgd2l0aCB0aGlzIHBhcmFtIHNldCB0byBcInRydWVcIiB3aWxsIHRyaWdnZXIgW3NlbGVjdGlvbkNoYW5naW5nXSh1aS5pZ2NvbWJvI2V2ZW50czpzZWxlY3Rpb25DaGFuZ2luZykgYW5kIFtzZWxlY3Rpb25DaGFuZ2VkXSh1aS5pZ2NvbWJvI2V2ZW50czpzZWxlY3Rpb25DaGFuZ2VkKSBldmVudHMuXG4gICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBjbGVhcklucHV0KG9wdGlvbnM/OiBPYmplY3QsIGV2ZW50PzogT2JqZWN0KTogT2JqZWN0IHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgd2hldGhlciBhIHNwZWNpZmllZCB2YWx1ZSBpcyBzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSBtYXRjaGluZyB0aGUgW3ZhbHVlS2V5XSh1aS5pZ2NvbWJvI29wdGlvbnM6dmFsdWVLZXkpIHByb3BlcnR5IG9mIGl0ZW0gdG8gYmUgdGVzdGVkIGlmIGl0IGlzIHNlbGVjdGVkXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgaXNWYWx1ZVNlbGVjdGVkKHZhbHVlOiBPYmplY3QpOiBib29sZWFuIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgd2hldGhlciB0aGUgbGkgcmVwcmVzZW50aW5nIHRoZSBkYXRhIHNvdXJjZSdzIHJlY29yZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4IGlzIHNlbGVjdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4IEluZGV4IG9mIGRhdGEgc291cmNlIHJlY29yZFxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGlzSW5kZXhTZWxlY3RlZChpbmRleDogT2JqZWN0KTogYm9vbGVhbiB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgbGlzdCBpdGVtL2l0ZW1zIGZyb20gdGhlIGRyb3AtZG93biBsaXN0IGJ5IHNwZWNpZmllZCB2YWx1ZSBvciBhcnJheSBvZiB2YWx1ZXMuIFdoZW4gY2FsbGVkIHdpdG91dCBwYXJhbXMgd2lsbCByZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBzZWxlY3RlZCBpdGVtIG9yIGlmIFttdWx0aVNlbGVjdGlvbl0odWkuaWdjb21ibyNvcHRpb25zOm11bHRpU2VsZWN0aW9uKSBpcyBlbmFibGVkIGFycmF5IG9mIHNlbGVjdGVkIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSBvciBhcnJheSBvZiB2YWx1ZXMgbWF0Y2hpbmcgdGhlIHZhbHVlS2V5IHByb3BlcnR5IG9mIGl0ZW0vaXRlbXMgdG8gYmUgc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPYmplY3Qgd2l0aCBzZXQgb2Ygb3B0aW9ucyBjb250cm9sbGluZyB0aGUgYmVoYXZpb3Igb2YgdGhpcyBhcGkgbWV0aG9kLlxuICAgICAgICAgICAgICAgICAgICBjbG9zZURyb3BEb3duIChib29sZWFuKTogU2V0IHRvIHRydWUgdG8gY2xvc2UgdGhlIGRyb3AgZG93biBsaXN0IGFmdGVyIHRoZSBzZWxlY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgIGZvY3VzQ29tYm8gKGJvb2xlYW4pOiBTZXQgdG8gdHJ1ZSB0byBmb2N1cyBjb21ibyBhZnRlciB0aGUgc2VsZWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICBhZGRpdGl2ZSAoYm9vbGVhbik6IFNldCB0byB0cnVlIHRvIHNlbGVjdCB0aGUgaXRlbSB3aXRob3V0IGxvc2luZyBvdGhlciBzZWxlY3Rpb24uIFdvcmtzIG9ubHkgd2hlbiBtdWx0aSBzZWxlY3Rpb24gaXMgZW5hYmxlZC5cbiAgICAgICAgICAgICAgICAgICAga2VlcEZpbHRlcmluZyAoYm9vbGVhbik6IFNldCB0byB0cnVlIHRvIGtlZXAgZmlsdGVyaW5nIGFmdGVyIHRoZSBzZWxlY3Rpb24uIEJ5IGRlZmF1bHQgdGhlIGZpbHRlcmluZyBpcyBjbGVhcmVkLlxuICAgICAgICAgICAgICAgICAgICBrZWVwSW5wdXRUZXh0IChib29sZWFuKTogU2V0IHRvIHRydWUgdG8ga2VlcCBpbnB1dCB0ZXh0IHVuY2hhbmdlZCBhZnRlciB0aGUgc2VsZWN0aW9uLiBCeSBkZWZhdWx0IGlucHV0IHRleHQgaXMgdXBkYXRlZC5cbiAgICAgICAgICAgICAgICAgICAga2VlcEhpZ2hsaWdodGluZyAoYm9vbGVhbik6IFNldCB0byB0cnVlIHRvIGtlZXAgaGlnaGxpZ2h0aW5nIHVuY2hhbmdlZCBhZnRlciB0aGUgc2VsZWN0aW9uLiBCeSBkZWZhdWx0IGhpZ2hsaWdodGluZyBpcyByZW1vdmVkLlxuICAgICAgICAgICAgICAgICAgICBrZWVwTmF2SXRlbSAoYm9vbGVhbik6IFNldCB0byB0cnVlIHRvIGtlZXAgY3VycmVudCBuYXZpZ2F0aW9uIGl0ZW0gdW5jaGFuZ2VkIGFmdGVyIHRoZSBzZWxlY3Rpb24uIEJ5IGRlZmF1bHQgdGhlIG5hdmlnYXRpb24gaXRlbSBpcyBjaGFuZ2VkIHRvIHRoZSBuZXcgc2VsZWN0ZWQgaXRlbS5cbiAgICAgICAgICAgICAgICAgICAga2VlcFNjcm9sbFBvc2l0aW9uIChib29sZWFuKTogU2V0IHRvIHRydWUgdG8ga2VlcCBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbi4gQnkgZGVmYXVsdCB0aGUgc2Nyb2xsIHBvc2l0aW9uIHdpbGwgY2hhbmdlIHNvIHRoYXQgdGhlIGxhc3Qgc2VsZWN0ZWQgaXRlbSBpcyB2aXNpYmxlLlxuICAgICogQHBhcmFtIGV2ZW50IEluZGljYXRlcyB0aGUgYnJvd3NlciBldmVudCB3aGljaCB0cmlnZ2VyZWQgdGhpcyBhY3Rpb24gKG5vdCBBUEkpLiBDYWxsaW5nIHRoZSBtZXRob2Qgd2l0aCB0aGlzIHBhcmFtIHNldCB0byBcInRydWVcIiB3aWxsIHRyaWdnZXIgW3NlbGVjdGlvbkNoYW5naW5nXSh1aS5pZ2NvbWJvI2V2ZW50czpzZWxlY3Rpb25DaGFuZ2luZykgYW5kIFtzZWxlY3Rpb25DaGFuZ2VkXSh1aS5pZ2NvbWJvI2V2ZW50czpzZWxlY3Rpb25DaGFuZ2VkKSBldmVudHMuXG4gICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyB2YWx1ZSh2YWx1ZT86IE9iamVjdCwgb3B0aW9ucz86IE9iamVjdCwgZXZlbnQ/OiBPYmplY3QpOiBPYmplY3QgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIGEgbGlzdCBpdGVtIGZyb20gdGhlIGRyb3AtZG93biBsaXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtICRpdGVtcyBqUXVlcnkgb2JqZWN0IHdpdGggaXRlbSBvciBpdGVtcyB0byBiZSBzZWxlY3RlZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPYmplY3Qgd2l0aCBzZXQgb2Ygb3B0aW9ucyBjb250cm9sbGluZyB0aGUgYmVoYXZpb3Igb2YgdGhpcyBhcGkgbWV0aG9kLlxuICAgICAgICAgICAgICAgICAgICBjbG9zZURyb3BEb3duIChib29sZWFuKTogU2V0IHRvIHRydWUgdG8gY2xvc2UgdGhlIGRyb3AgZG93biBsaXN0IGFmdGVyIHRoZSBzZWxlY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgIGZvY3VzQ29tYm8gKGJvb2xlYW4pOiBTZXQgdG8gdHJ1ZSB0byBmb2N1cyBjb21ibyBhZnRlciB0aGUgc2VsZWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICBhZGRpdGl2ZSAoYm9vbGVhbik6IFNldCB0byB0cnVlIHRvIHNlbGVjdCB0aGUgaXRlbSB3aXRob3V0IGxvc2luZyBvdGhlciBzZWxlY3Rpb24uIFdvcmtzIG9ubHkgd2hlbiBtdWx0aSBzZWxlY3Rpb24gaXMgZW5hYmxlZC5cbiAgICAgICAgICAgICAgICAgICAga2VlcEZpbHRlcmluZyAoYm9vbGVhbik6IFNldCB0byB0cnVlIHRvIGtlZXAgZmlsdGVyaW5nIGFmdGVyIHRoZSBzZWxlY3Rpb24uIEJ5IGRlZmF1bHQgdGhlIGZpbHRlcmluZyBpcyBjbGVhcmVkLlxuICAgICAgICAgICAgICAgICAgICBrZWVwSW5wdXRUZXh0IChib29sZWFuKTogU2V0IHRvIHRydWUgdG8ga2VlcCBpbnB1dCB0ZXh0IHVuY2hhbmdlZCBhZnRlciB0aGUgc2VsZWN0aW9uLiBCeSBkZWZhdWx0IGlucHV0IHRleHQgaXMgdXBkYXRlZC5cbiAgICAgICAgICAgICAgICAgICAga2VlcEhpZ2hsaWdodGluZyAoYm9vbGVhbik6IFNldCB0byB0cnVlIHRvIGtlZXAgaGlnaGxpZ2h0aW5nIHVuY2hhbmdlZCBhZnRlciB0aGUgc2VsZWN0aW9uLiBCeSBkZWZhdWx0IGhpZ2hsaWdodGluZyBpcyByZW1vdmVkLlxuICAgICAgICAgICAgICAgICAgICBrZWVwTmF2SXRlbSAoYm9vbGVhbik6IFNldCB0byB0cnVlIHRvIGtlZXAgY3VycmVudCBuYXZpZ2F0aW9uIGl0ZW0gdW5jaGFuZ2VkIGFmdGVyIHRoZSBzZWxlY3Rpb24uIEJ5IGRlZmF1bHQgdGhlIG5hdmlnYXRpb24gaXRlbSBpcyBjaGFuZ2VkIHRvIHRoZSBuZXcgc2VsZWN0ZWQgaXRlbS5cbiAgICAgICAgICAgICAgICAgICAga2VlcFNjcm9sbFBvc2l0aW9uIChib29sZWFuKTogU2V0IHRvIHRydWUgdG8ga2VlcCBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbi4gQnkgZGVmYXVsdCB0aGUgc2Nyb2xsIHBvc2l0aW9uIHdpbGwgY2hhbmdlIHNvIHRoYXQgdGhlIGxhc3Qgc2VsZWN0ZWQgaXRlbSBpcyB2aXNpYmxlLlxuICAgICogQHBhcmFtIGV2ZW50IEluZGljYXRlcyB0aGUgYnJvd3NlciBldmVudCB3aGljaCB0cmlnZ2VyZWQgdGhpcyBhY3Rpb24gKG5vdCBBUEkpLiBDYWxsaW5nIHRoZSBtZXRob2Qgd2l0aCB0aGlzIHBhcmFtIHNldCB0byBcInRydWVcIiB3aWxsIHRyaWdnZXIgW3NlbGVjdGlvbkNoYW5naW5nXSh1aS5pZ2NvbWJvI2V2ZW50czpzZWxlY3Rpb25DaGFuZ2luZykgYW5kIFtzZWxlY3Rpb25DaGFuZ2VkXSh1aS5pZ2NvbWJvI2V2ZW50czpzZWxlY3Rpb25DaGFuZ2VkKSBldmVudHMuXG4gICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBzZWxlY3QoJGl0ZW1zOiBPYmplY3QsIG9wdGlvbnM/OiBPYmplY3QsIGV2ZW50PzogT2JqZWN0KTogT2JqZWN0IHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHNlbGVjdGVkIGl0ZW0vcyBmcm9tIHRoZSBkcm9wLWRvd24gbGlzdCBieSBzcGVjaWZpZWQgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kZXggSW5kZXggb3IgYXJyYXkgb2YgaW5kZXhlcyBvZiBpdGVtcyB0byBiZSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9iamVjdCB3aXRoIHNldCBvZiBvcHRpb25zIGNvbnRyb2xsaW5nIHRoZSBiZWhhdmlvciBvZiB0aGlzIGFwaSBtZXRob2QuXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlRHJvcERvd24gKGJvb2xlYW4pOiBTZXQgdG8gdHJ1ZSB0byBjbG9zZSB0aGUgZHJvcCBkb3duIGxpc3QgYWZ0ZXIgdGhlIHNlbGVjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgZm9jdXNDb21ibyAoYm9vbGVhbik6IFNldCB0byB0cnVlIHRvIGZvY3VzIGNvbWJvIGFmdGVyIHRoZSBzZWxlY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgIGFkZGl0aXZlIChib29sZWFuKTogU2V0IHRvIHRydWUgdG8gc2VsZWN0IHRoZSBpdGVtIHdpdGhvdXQgbG9zaW5nIG90aGVyIHNlbGVjdGlvbi4gV29ya3Mgb25seSB3aGVuIG11bHRpIHNlbGVjdGlvbiBpcyBlbmFibGVkLlxuICAgICAgICAgICAgICAgICAgICBrZWVwRmlsdGVyaW5nIChib29sZWFuKTogU2V0IHRvIHRydWUgdG8ga2VlcCBmaWx0ZXJpbmcgYWZ0ZXIgdGhlIHNlbGVjdGlvbi4gQnkgZGVmYXVsdCB0aGUgZmlsdGVyaW5nIGlzIGNsZWFyZWQuXG4gICAgICAgICAgICAgICAgICAgIGtlZXBJbnB1dFRleHQgKGJvb2xlYW4pOiBTZXQgdG8gdHJ1ZSB0byBrZWVwIGlucHV0IHRleHQgdW5jaGFuZ2VkIGFmdGVyIHRoZSBzZWxlY3Rpb24uIEJ5IGRlZmF1bHQgaW5wdXQgdGV4dCBpcyB1cGRhdGVkLlxuICAgICAgICAgICAgICAgICAgICBrZWVwSGlnaGxpZ2h0aW5nIChib29sZWFuKTogU2V0IHRvIHRydWUgdG8ga2VlcCBoaWdobGlnaHRpbmcgdW5jaGFuZ2VkIGFmdGVyIHRoZSBzZWxlY3Rpb24uIEJ5IGRlZmF1bHQgaGlnaGxpZ2h0aW5nIGlzIHJlbW92ZWQuXG4gICAgICAgICAgICAgICAgICAgIGtlZXBOYXZJdGVtIChib29sZWFuKTogU2V0IHRvIHRydWUgdG8ga2VlcCBjdXJyZW50IG5hdmlnYXRpb24gaXRlbSB1bmNoYW5nZWQgYWZ0ZXIgdGhlIHNlbGVjdGlvbi4gQnkgZGVmYXVsdCB0aGUgbmF2aWdhdGlvbiBpdGVtIGlzIGNoYW5nZWQgdG8gdGhlIG5ldyBzZWxlY3RlZCBpdGVtLlxuICAgICAgICAgICAgICAgICAgICBrZWVwU2Nyb2xsUG9zaXRpb24gKGJvb2xlYW4pOiBTZXQgdG8gdHJ1ZSB0byBrZWVwIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uLiBCeSBkZWZhdWx0IHRoZSBzY3JvbGwgcG9zaXRpb24gd2lsbCBjaGFuZ2Ugc28gdGhhdCB0aGUgbGFzdCBzZWxlY3RlZCBpdGVtIGlzIHZpc2libGUuXG4gICAgKiBAcGFyYW0gZXZlbnQgSW5kaWNhdGVzIHRoZSBicm93c2VyIGV2ZW50IHdoaWNoIHRyaWdnZXJlZCB0aGlzIGFjdGlvbiAobm90IEFQSSkuIENhbGxpbmcgdGhlIG1ldGhvZCB3aXRoIHRoaXMgcGFyYW0gc2V0IHRvIFwidHJ1ZVwiIHdpbGwgdHJpZ2dlciBbc2VsZWN0aW9uQ2hhbmdpbmddKHVpLmlnY29tYm8jZXZlbnRzOnNlbGVjdGlvbkNoYW5naW5nKSBhbmQgW3NlbGVjdGlvbkNoYW5nZWRdKHVpLmlnY29tYm8jZXZlbnRzOnNlbGVjdGlvbkNoYW5nZWQpIGV2ZW50cy5cbiAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGluZGV4KGluZGV4PzogT2JqZWN0LCBvcHRpb25zPzogT2JqZWN0LCBldmVudD86IE9iamVjdCk6IE9iamVjdCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgYWxsIGl0ZW1zIGZyb20gdGhlIGRyb3AtZG93biBsaXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT2JqZWN0IHdpdGggc2V0IG9mIG9wdGlvbnMgY29udHJvbGxpbmcgdGhlIGJlaGF2aW9yIG9mIHRoaXMgYXBpIG1ldGhvZC5cbiAgICAgICAgICAgICAgICAgICAgY2xvc2VEcm9wRG93biAoYm9vbGVhbik6IFNldCB0byB0cnVlIHRvIGNsb3NlIHRoZSBkcm9wIGRvd24gbGlzdCBhZnRlciB0aGUgc2VsZWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICBmb2N1c0NvbWJvIChib29sZWFuKTogU2V0IHRvIHRydWUgdG8gZm9jdXMgY29tYm8gYWZ0ZXIgdGhlIHNlbGVjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAga2VlcEZpbHRlcmluZyAoYm9vbGVhbik6IFNldCB0byB0cnVlIHRvIGtlZXAgZmlsdGVyaW5nIGFmdGVyIHRoZSBzZWxlY3Rpb24uIEJ5IGRlZmF1bHQgdGhlIGZpbHRlcmluZyBpcyBjbGVhcmVkLlxuICAgICAgICAgICAgICAgICAgICBrZWVwSW5wdXRUZXh0IChib29sZWFuKTogU2V0IHRvIHRydWUgdG8ga2VlcCBpbnB1dCB0ZXh0IHVuY2hhbmdlZCBhZnRlciB0aGUgc2VsZWN0aW9uLiBCeSBkZWZhdWx0IGlucHV0IHRleHQgaXMgdXBkYXRlZC5cbiAgICAgICAgICAgICAgICAgICAga2VlcEhpZ2hsaWdodGluZyAoYm9vbGVhbik6IFNldCB0byB0cnVlIHRvIGtlZXAgaGlnaGxpZ2h0aW5nIHVuY2hhbmdlZCBhZnRlciB0aGUgc2VsZWN0aW9uLiBCeSBkZWZhdWx0IGhpZ2hsaWdodGluZyBpcyByZW1vdmVkLlxuICAgICAgICAgICAgICAgICAgICBrZWVwTmF2SXRlbSAoYm9vbGVhbik6IFNldCB0byB0cnVlIHRvIGtlZXAgY3VycmVudCBuYXZpZ2F0aW9uIGl0ZW0gdW5jaGFuZ2VkIGFmdGVyIHRoZSBzZWxlY3Rpb24uIEJ5IGRlZmF1bHQgdGhlIG5hdmlnYXRpb24gaXRlbSBpcyBjaGFuZ2VkIHRvIHRoZSBuZXcgc2VsZWN0ZWQgaXRlbS5cbiAgICAgICAgICAgICAgICAgICAga2VlcFNjcm9sbFBvc2l0aW9uIChib29sZWFuKTogU2V0IHRvIHRydWUgdG8ga2VlcCBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbi4gQnkgZGVmYXVsdCB0aGUgc2Nyb2xsIHBvc2l0aW9uIHdpbGwgY2hhbmdlIHNvIHRoYXQgdGhlIGxhc3Qgc2VsZWN0ZWQgaXRlbSBpcyB2aXNpYmxlLlxuICAgICogQHBhcmFtIGV2ZW50IEluZGljYXRlcyB0aGUgYnJvd3NlciBldmVudCB3aGljaCB0cmlnZ2VyZWQgdGhpcyBhY3Rpb24gKG5vdCBBUEkpLiBDYWxsaW5nIHRoZSBtZXRob2Qgd2l0aCB0aGlzIHBhcmFtIHNldCB0byBcInRydWVcIiB3aWxsIHRyaWdnZXIgW3NlbGVjdGlvbkNoYW5naW5nXSh1aS5pZ2NvbWJvI2V2ZW50czpzZWxlY3Rpb25DaGFuZ2luZykgYW5kIFtzZWxlY3Rpb25DaGFuZ2VkXSh1aS5pZ2NvbWJvI2V2ZW50czpzZWxlY3Rpb25DaGFuZ2VkKSBldmVudHMuXG4gICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBzZWxlY3RBbGwob3B0aW9ucz86IE9iamVjdCwgZXZlbnQ/OiBPYmplY3QpOiBPYmplY3QgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBEZXNlbGVjdHMgYSBsaXN0IGl0ZW0gZnJvbSB0aGUgZHJvcCBkb3duIGxpc3QgYnkgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgVmFsdWUgb3IgYXJyYXkgb2YgdmFsdWVzIG1hdGNoaW5nIHRoZSBbdmFsdWVLZXldKHVpLmlnY29tYm8jb3B0aW9uczp2YWx1ZUtleSkgcHJvcGVydHkgb2YgaXRlbS9pdGVtcyB0byBiZSBkZXNlbGVjdGVkXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT2JqZWN0IHdpdGggc2V0IG9mIG9wdGlvbnMgY29udHJvbGxpbmcgdGhlIGJlaGF2aW9yIG9mIHRoaXMgYXBpIG1ldGhvZC5cbiAgICAgICAgICAgICAgICAgICAgZm9jdXNDb21ibyAoYm9vbGVhbik6IFNldCB0byB0cnVlIHRvIGZvY3VzIGNvbWJvIGFmdGVyIHRoZSBkZXNlbGVjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAga2VlcElucHV0VGV4dCAoYm9vbGVhbik6IFNldCB0byB0cnVlIHRvIGtlZXAgaW5wdXQgdGV4dCB1bmNoYW5nZWQgYWZ0ZXIgdGhlIGRlc2VsZWN0aW9uLiBCeSBkZWZhdWx0IGlucHV0IHRleHQgaXMgdXBkYXRlZC5cbiAgICAqIEBwYXJhbSBldmVudCBJbmRpY2F0ZXMgdGhlIGJyb3dzZXIgZXZlbnQgd2hpY2ggdHJpZ2dlcmVkIHRoaXMgYWN0aW9uIChub3QgQVBJKS4gQ2FsbGluZyB0aGUgbWV0aG9kIHdpdGggdGhpcyBwYXJhbSBzZXQgdG8gXCJ0cnVlXCIgd2lsbCB0cmlnZ2VyIFtzZWxlY3Rpb25DaGFuZ2luZ10odWkuaWdjb21ibyNldmVudHM6c2VsZWN0aW9uQ2hhbmdpbmcpIGFuZCBbc2VsZWN0aW9uQ2hhbmdlZF0odWkuaWdjb21ibyNldmVudHM6c2VsZWN0aW9uQ2hhbmdlZCkgZXZlbnRzLlxuICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgZGVzZWxlY3RCeVZhbHVlKHZhbHVlOiBPYmplY3QsIG9wdGlvbnM/OiBPYmplY3QsIGV2ZW50PzogT2JqZWN0KTogT2JqZWN0IHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogRGVzZWxlY3RzIGEgbGlzdCBpdGVtIGZyb20gdGhlIGRyb3AgZG93biBsaXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtICRpdGVtcyBqUXVlcnkgb2JqZWN0IHdpdGggaXRlbSBvciBpdGVtcyB0byBiZSBkZXNlbGVjdGVkXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT2JqZWN0IHdpdGggc2V0IG9mIG9wdGlvbnMgY29udHJvbGxpbmcgdGhlIGJlaGF2aW9yIG9mIHRoaXMgYXBpIG1ldGhvZC5cbiAgICAgICAgICAgICAgICAgICAgZm9jdXNDb21ibyAoYm9vbGVhbik6IFNldCB0byB0cnVlIHRvIGZvY3VzIGNvbWJvIGFmdGVyIHRoZSBkZXNlbGVjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAga2VlcElucHV0VGV4dCAoYm9vbGVhbik6IFNldCB0byB0cnVlIHRvIGtlZXAgaW5wdXQgdGV4dCB1bmNoYW5nZWQgYWZ0ZXIgdGhlIGRlc2VsZWN0aW9uLiBCeSBkZWZhdWx0IGlucHV0IHRleHQgaXMgdXBkYXRlZC5cbiAgICAqIEBwYXJhbSBldmVudCBJbmRpY2F0ZXMgdGhlIGJyb3dzZXIgZXZlbnQgd2hpY2ggdHJpZ2dlcmVkIHRoaXMgYWN0aW9uIChub3QgQVBJKS4gQ2FsbGluZyB0aGUgbWV0aG9kIHdpdGggdGhpcyBwYXJhbSBzZXQgdG8gXCJ0cnVlXCIgd2lsbCB0cmlnZ2VyIFtzZWxlY3Rpb25DaGFuZ2luZ10odWkuaWdjb21ibyNldmVudHM6c2VsZWN0aW9uQ2hhbmdpbmcpIGFuZCBbc2VsZWN0aW9uQ2hhbmdlZF0odWkuaWdjb21ibyNldmVudHM6c2VsZWN0aW9uQ2hhbmdlZCkgZXZlbnRzLlxuICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgZGVzZWxlY3QoJGl0ZW1zOiBPYmplY3QsIG9wdGlvbnM/OiBPYmplY3QsIGV2ZW50PzogT2JqZWN0KTogT2JqZWN0IHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogRGVzZWxlY3RzIGEgbGlzdCBpdGVtIGZyb20gdGhlIGRyb3AgZG93biBsaXN0IGJ5IGluZGV4LlxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4IEluZGV4IG9yIGFycmF5IG9mIGluZGV4ZXMgb2YgaXRlbXMgdG8gYmUgc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPYmplY3Qgd2l0aCBzZXQgb2Ygb3B0aW9ucyBjb250cm9sbGluZyB0aGUgYmVoYXZpb3Igb2YgdGhpcyBhcGkgbWV0aG9kLlxuICAgICAgICAgICAgICAgICAgICBmb2N1c0NvbWJvIChib29sZWFuKTogU2V0IHRvIHRydWUgdG8gZm9jdXMgY29tYm8gYWZ0ZXIgdGhlIGRlc2VsZWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICBrZWVwSW5wdXRUZXh0IChib29sZWFuKTogU2V0IHRvIHRydWUgdG8ga2VlcCBpbnB1dCB0ZXh0IHVuY2hhbmdlZCBhZnRlciB0aGUgZGVzZWxlY3Rpb24uIEJ5IGRlZmF1bHQgaW5wdXQgdGV4dCBpcyB1cGRhdGVkLlxuICAgICogQHBhcmFtIGV2ZW50IEluZGljYXRlcyB0aGUgYnJvd3NlciBldmVudCB3aGljaCB0cmlnZ2VyZWQgdGhpcyBhY3Rpb24gKG5vdCBBUEkpLiBDYWxsaW5nIHRoZSBtZXRob2Qgd2l0aCB0aGlzIHBhcmFtIHNldCB0byBcInRydWVcIiB3aWxsIHRyaWdnZXIgW3NlbGVjdGlvbkNoYW5naW5nXSh1aS5pZ2NvbWJvI2V2ZW50czpzZWxlY3Rpb25DaGFuZ2luZykgYW5kIFtzZWxlY3Rpb25DaGFuZ2VkXSh1aS5pZ2NvbWJvI2V2ZW50czpzZWxlY3Rpb25DaGFuZ2VkKSBldmVudHMuXG4gICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBkZXNlbGVjdEJ5SW5kZXgoaW5kZXg6IE9iamVjdCwgb3B0aW9ucz86IE9iamVjdCwgZXZlbnQ/OiBPYmplY3QpOiBPYmplY3QgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBEZXNlbGVjdHMgYWxsIHNlbGVjdGVkIGl0ZW1zIGZyb20gdGhlIGRyb3AgZG93biBsaXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT2JqZWN0IHdpdGggc2V0IG9mIG9wdGlvbnMgY29udHJvbGxpbmcgdGhlIGJlaGF2aW9yIG9mIHRoaXMgYXBpIG1ldGhvZC5cbiAgICAgICAgICAgICAgICAgICAgZm9jdXNDb21ibyAoYm9vbGVhbik6IFNldCB0byB0cnVlIHRvIGZvY3VzIGNvbWJvIGFmdGVyIHRoZSBkZXNlbGVjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAga2VlcElucHV0VGV4dCAoYm9vbGVhbik6IFNldCB0byB0cnVlIHRvIGtlZXAgaW5wdXQgdGV4dCB1bmNoYW5nZWQgYWZ0ZXIgdGhlIGRlc2VsZWN0aW9uLiBCeSBkZWZhdWx0IGlucHV0IHRleHQgaXMgdXBkYXRlZC5cbiAgICAqIEBwYXJhbSBldmVudCBJbmRpY2F0ZXMgdGhlIGJyb3dzZXIgZXZlbnQgd2hpY2ggdHJpZ2dlcmVkIHRoaXMgYWN0aW9uIChub3QgQVBJKS4gQ2FsbGluZyB0aGUgbWV0aG9kIHdpdGggdGhpcyBwYXJhbSBzZXQgdG8gXCJ0cnVlXCIgd2lsbCB0cmlnZ2VyIFtzZWxlY3Rpb25DaGFuZ2luZ10odWkuaWdjb21ibyNldmVudHM6c2VsZWN0aW9uQ2hhbmdpbmcpIGFuZCBbc2VsZWN0aW9uQ2hhbmdlZF0odWkuaWdjb21ibyNldmVudHM6c2VsZWN0aW9uQ2hhbmdlZCkgZXZlbnRzLlxuICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgZGVzZWxlY3RBbGwob3B0aW9ucz86IE9iamVjdCwgZXZlbnQ/OiBPYmplY3QpOiBPYmplY3QgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzL1NldHMgaW5kZXggb2YgYWN0aXZlIGl0ZW0gaW4gbGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmRleCBOZXcgYWN0aXZlIGluZGV4IGZvciBsaXN0LiBJbiBvcmRlciB0byBjbGVhciBhY3RpdmUgaXRlbSwgdXNlIC0xLlxuICAgICAqIEByZXR1cm4gbnVtYmVyfG9iamVjdCBSZXR1cm5zIGluZGV4IG9mIGFjdGl2ZSBpdGVtIGluIGxpc3Qgb3IgLTEsIGlmIHBhcmFtZXRlciBpcyB1bmRlZmluZWQuIE90aGVyd2lzZSwgaXQgcmV0dXJucyByZWZlcmVuY2UgdG8gdGhpcyBpZ0NvbWJvLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGFjdGl2ZUluZGV4KGluZGV4PzogbnVtYmVyKTogbnVtYmVyIHwgT2JqZWN0IHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHRleHQgaW4gdGV4dCBpbnB1dCBmaWVsZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0ZXh0IE5ldyB0ZXh0IHZhbHVlIGZvciBjb21ibydzIGlucHV0IGZpZWxkLlxuICAgICAqIEByZXR1cm4gc3RyaW5nfG9iamVjdCBJZiBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkLCB0aGVuIGN1cnJlbnQgdGV4dCBpbiBmaWVsZCBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlLCBpdCByZXR1cm5zIHJlZmVyZW5jZSB0byB0aGlzIGlnQ29tYm8uXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgdGV4dCh0ZXh0Pzogc3RyaW5nKTogc3RyaW5nIHwgT2JqZWN0IHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHNjcm9sbFRvcCBhdHRyaWJ1dGUgb2YgaHRtbCBlbGVtZW50LCB3aGljaCBzY3JvbGxzIGRyb3AtZG93biBsaXN0IG9mIGl0ZW1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIE5ldyB2YWx1ZSBmb3Igc2Nyb2xsIHRvcCBpbiBsaXN0LiBOb3RlOiBpZiBsaXN0IGlzIGNsb3NlZCBhbmQgbmV3IHZhbHVlIGlzIHByb3ZpZGVkLCB0aGVuIG9wZW5Ecm9wRG93bigpIGlzIGNhbGxlZCBhdXRvbWF0aWNhbGx5LlxuICAgICAqIEByZXR1cm4gbnVtYmVyfG9iamVjdCBJZiBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkLCB0aGVuIHNjcm9sbFRvcCBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlLCBpdCByZXR1cm5zIHJlZmVyZW5jZSB0byB0aGlzIGlnQ29tYm8uXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgbGlzdFNjcm9sbFRvcCh2YWx1ZT86IG51bWJlcik6IG51bWJlciB8IE9iamVjdCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgalF1ZXJ5IG9iamVjdHMgcmVwcmVzZW50aW5nIGFsbCByZW5kZXJlZCBsaXN0IGl0ZW1zIGluIHRoZSBjb21ibyBkcm9wIGRvd24gbGlzdC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBsaXN0SXRlbXMoKTogT2JqZWN0IHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyBqUXVlcnkgb2JqZWN0IG9mIHRoZSBvdXRlciBlbGVtZW50IG9mIHRoZSBjb21iby5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBjb21ib1dyYXBwZXIoKTogT2JqZWN0IHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyBqUXVlcnkgb2JqZWN0IG9mIHRoZSBkcm9wIGRvd24gYXNzb2NpYXRlZCB3aXRoIHRoaXMgY29tYm8gd2lkZ2V0XG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgZHJvcERvd24oKTogT2JqZWN0IHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyBqUXVlcnkgb2JqZWN0IG9mIHRoZSBjb250YWluZXIgdGhhdCBob2xkcyB0aGUgbGlzdCB3aXRoIGl0ZW1zLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGxpc3QoKTogT2JqZWN0IHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyBqUXVlcnkgb2JqZWN0IG9mIHRoZSB0ZXh0IGlucHV0IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbWJvIHdpZGdldC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyB0ZXh0SW5wdXQoKTogT2JqZWN0IHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyBqUXVlcnkgb2JqZWN0IG9mIHRoZSB2YWx1ZSBpbnB1dCBhc3NvY2lhdGVkIHdpdGggdGhpcyBjb21ibyB3aWRnZXQuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgdmFsdWVJbnB1dCgpOiBPYmplY3QgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHJlZmVyZW5jZSB0byBbaWdWYWxpZGF0b3JdKHVpLmlndmFsaWRhdG9yKSB1c2VkIGJ5IGlnQ29tYm8uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGVzdHJveSBSZXF1ZXN0IHRvIGRlc3Ryb3kgdmFsaWRhdG9yLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIHZhbGlkYXRvcihkZXN0cm95PzogYm9vbGVhbik6IE9iamVjdCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXIgdmFsaWRhdGlvbi5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyB2YWxpZGF0ZSgpOiBib29sZWFuIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBib29sZWFuIHJlcHJlc2VudGluZyB3aGV0aGVyIHRoZSBjb21ibyBkcm9wIGRvd24gbGlzdCBpcyBvcGVuZWQuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgZHJvcERvd25PcGVuZWQoKTogYm9vbGVhbiB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFJlcG9zaXRpb25zIGRyb3AgZG93biB1bmRlciBjb21ibyBpbnB1dC4gSGFzIGVmZmVjdCBvbmx5IHdoZW4gdGhlIGRyb3AgZG93biBpcyBhdHRhY2hlZCB0byBib2R5LlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIHBvc2l0aW9uRHJvcERvd24oKTogT2JqZWN0IHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhlIGlnQ29tYm8gd2lkZ2V0LlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGRlc3Ryb3koKTogT2JqZWN0IHsgcmV0dXJuOyB9O1xufSJdfQ==