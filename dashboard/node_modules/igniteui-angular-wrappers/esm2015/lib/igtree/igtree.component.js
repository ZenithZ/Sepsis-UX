/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, Renderer, ElementRef, IterableDiffers, KeyValueDiffers, ChangeDetectorRef, Input } from "@angular/core";
import { IgControlBase } from "../igcontrolbase/igcontrolbase";
export class IgTreeComponent extends IgControlBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiffers, cdr) {
        super(el, renderer, differs, kvalDiffers, cdr);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set dataSource(value) {
        this._dataSource = value;
    }
    ;
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.options["dataSource"] && this._dataSource) {
            this.options["dataSource"] = this._dataSource;
        }
        super.ngOnInit();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        /** @type {?} */
        const ds = "dataSource";
        //const options = "options";
        if (ds in changes) {
            /** @type {?} */
            const value = changes[ds].currentValue;
            if (!this._differ && value) {
                try {
                    this._differ = this._differs.find(value).create();
                    this._changes = [];
                    for (var i = 0; i < this._dataSource.length; i++) {
                        this._changes.push(this.kvalDiffers.find({}).create());
                    }
                }
                catch (e) {
                    throw new Error("Only binding to arrays is supported.");
                }
            }
        }
        super.ngOnChanges(changes);
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this._differ) {
            /** @type {?} */
            const changes = this._differ.diff(this._dataSource);
            //check if grid is initialized
            /** @type {?} */
            const elem = jQuery(this._el).data(this._widgetName);
            if (changes && elem) {
                this.dataSourceApplyChanges(changes);
            }
            if (this._changes && elem) {
                //check recs
                for (var i = 0; i < this._dataSource.length; i++) {
                    /** @type {?} */
                    var item = this._dataSource[i];
                    /** @type {?} */
                    var rowChanges = this._changes[i].diff(item);
                    if (rowChanges) {
                        rowChanges.forEachChangedItem((/**
                         * @param {?} change
                         * @return {?}
                         */
                        (change) => {
                            this.updateItem(item, change.currentValue, change.key);
                        }));
                    }
                }
            }
        }
        super.ngDoCheck();
    }
    /**
     * @param {?} item
     * @param {?} index
     * @return {?}
     */
    addItem(item, index) {
        this.dataBind();
        this._changes.push(this.kvalDiffers.find({}).create());
    }
    /**
     * @param {?} item
     * @param {?} index
     * @return {?}
     */
    deleteItem(item, index) {
        this.dataBind();
        this._changes.splice(index, 1);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    dataSourceApplyChanges(changes) {
        changes.forEachAddedItem((/**
         * @param {?} r
         * @return {?}
         */
        r => this.addItem(r.item, r.currentIndex)));
        changes.forEachRemovedItem((/**
         * @param {?} r
         * @return {?}
         */
        r => { this.deleteItem(r.item, r.previousIndex); }));
    }
    /**
     * @param {?} item
     * @param {?} value
     * @param {?} key
     * @return {?}
     */
    updateItem(item, value, key) {
        this.dataBind();
    }
    /**
     * @return {?}
     */
    markForCheck() {
        super.markForCheck();
        /** @type {?} */
        const bindings = this["bindings"] || this.options.bindings;
        if (bindings && bindings.childDataProperty) {
            this.dataBind();
        }
    }
    // optionChange(options?) {
    // 	var opts = options || jQuery.extend(true, {}, this._config);
    // 	// Bindings are modified internally by the tree. Excluding them from the change detection
    // 	if (opts.bindings) {
    // 		delete opts.bindings;
    // 	}
    // 	super.optionChange(opts);
    // }
    /**
     * Performs databinding on the igTree.
     * @return {?}
     */
    /* istanbul ignore next */
    dataBind() { return; }
    ;
    /**
     * Toggles the checkstate of a node if checkboxMode is not set to off, otherwise does nothing.
     *
     * @param {?} node     Specifies the node element the checkbox of which would be toggled.
     * @param {?=} event     Indicates the browser event which triggered this action, if this is not an API call.
     * @return {?}
     */
    /* istanbul ignore next */
    toggleCheckstate(node, event) { return; }
    ;
    /**
     * Toggles the collapse/expand state for the specified node.
     *
     * @param {?} node     Specifies the node element the checkbox of which would be toggled.
     * @param {?=} event     Indicates the browser event which triggered this action, if this is not an API call.
     * @return {?}
     */
    /* istanbul ignore next */
    toggle(node, event) { return; }
    ;
    /**
     * Expands the tree down to the specified node and selects the node if specified.
     *
     * @param {?} node     Specifies the node element down to which the tree would be expanded.
     * @param {?=} toSelect     Specifies the whether to select the node after expanding to it.
     * @return {?}
     */
    /* istanbul ignore next */
    expandToNode(node, toSelect) { return; }
    ;
    /**
     * Expands the specified node.
     *
     * @param {?} node     Specifies the node element to expand.
     * @return {?}
     */
    /* istanbul ignore next */
    expand(node) { return; }
    ;
    /**
     * Collapses the specified node.
     *
     * @param {?} node     Specifies the node element to collapse.
     * @return {?}
     */
    /* istanbul ignore next */
    collapse(node) { return; }
    ;
    /**
     * Retrieves the parent node element of the specified node element.
     *
     * @param {?} node     Specifies the jQuery selected node element to collapse.
     * @return {?}
     */
    /* istanbul ignore next */
    parentNode(node) { return; }
    ;
    /**
     * Retrieves the jQuery element of the node with the specified path.
     *
     * @param {?} nodePath     Specifies the path to the required node.
     * @return {?}
     */
    /* istanbul ignore next */
    nodeByPath(nodePath) { return; }
    ;
    /**
     * Retrieves the jQuery element of the node with the specified value.
     *
     * @param {?} value     Specifies the value of the required node.
     * @return {?}
     */
    /* istanbul ignore next */
    nodesByValue(value) { return; }
    ;
    /**
     * Retrieves all the node objects for the nodes that have their checkboxes checked.
     * @return {?}
     */
    /* istanbul ignore next */
    checkedNodes() { return; }
    ;
    /**
     * Retrieves all the node objects for the nodes that have their checkboxes unchecked.
     * @return {?}
     */
    /* istanbul ignore next */
    uncheckedNodes() { return; }
    ;
    /**
     * Retrieves all the node objects for the nodes that have their checkboxes partially checked.
     * @return {?}
     */
    /* istanbul ignore next */
    partiallyCheckedNodes() { return; }
    ;
    /**
     * Selects a node.
     *
     * @param {?} node     Specifies the node element to be selected.
     * @param {?=} event     Indicates the browser event which triggered this action, if this is not an API call.
     * @return {?}
     */
    /* istanbul ignore next */
    select(node, event) { return; }
    ;
    /**
     * Deselects the specified node.
     *
     * @param {?} node     Specifies the node element to be deselected.
     * @return {?}
     */
    /* istanbul ignore next */
    deselect(node) { return; }
    ;
    /**
     * Deselects all the selected nodes.
     * @return {?}
     */
    /* istanbul ignore next */
    clearSelection() { return; }
    ;
    /**
     * Retrieves the node object for the selected node.
     * @return {?}
     */
    /* istanbul ignore next */
    selectedNode() { return; }
    ;
    /**
     * Retrieves all node objects with the specified text (case sensitive).
     *
     * @param {?} text     The text to search for.
     * @param {?=} parent     The node element to start the search from. If not specified then search would start from the root of the tree.
     * @return {?}
     */
    /* istanbul ignore next */
    findNodesByText(text, parent) { return; }
    ;
    /**
     * Retrieves all node objects for the immediate children of the specified parent with the specified text (case sensitive).
     *
     * @param {?} text     The text to search for.
     * @param {?=} parent     The node element the children of which would be searched.
     * @return {?}
     */
    /* istanbul ignore next */
    findImmediateNodesByText(text, parent) { return; }
    ;
    /**
     * Retrieves the n-th jQuery node element child of the specified parent.
     *
     * @param {?} index     Specifies the index the node at which to be retrieved.
     * @param {?=} parent     The parent node element to start the search from.
     * @return {?}
     */
    /* istanbul ignore next */
    nodeByIndex(index, parent) { return; }
    ;
    /**
     * Retrieves a node object for the specified node element.
     *
     * @param {?} element     Specifies the node element.
     * @return {?}
     */
    /* istanbul ignore next */
    nodeFromElement(element) { return; }
    ;
    /**
     * Retrieves a node object collection of the immediate children of the provided node element.
     *
     * @param {?} parent     Specifies the node element.
     * @return {?}
     */
    /* istanbul ignore next */
    children(parent) { return; }
    ;
    /**
     * Retrieves a node object collection of the immediate children of the node with the provided path.
     *
     * @param {?} path     Specifies the path of the node the children of which are to be retrieved.
     * @return {?}
     */
    /* istanbul ignore next */
    childrenByPath(path) { return; }
    ;
    /**
     * Returns true if the provided node element is selected and false otherwise.
     *
     * @param {?} node     Specifies the node element.
     * @return {?}
     */
    /* istanbul ignore next */
    isSelected(node) { return; }
    ;
    /**
     * Returns true if the provided node element is expanded and false otherwise.
     *
     * @param {?} node     Specifies the node element.
     * @return {?}
     */
    /* istanbul ignore next */
    isExpanded(node) { return; }
    ;
    /**
     * Returns true if the provided node element has its checkbox checkstate checked and false otherwise.
     *
     * @param {?} node     Specifies the node element.
     * @return {?}
     */
    /* istanbul ignore next */
    isChecked(node) { return; }
    ;
    /**
     * Returns the specified node checkstate.
     *
     * @param {?} node     Specifies the node element.
     * @return {?}
     */
    /* istanbul ignore next */
    checkState(node) { return; }
    ;
    /**
     * Adds a new array of nodes to the tree. New nodes are appended to the root or to a specified parent node, at a specified index.
     *
     * @param {?} node     Specifies the data used to create the new node—Å.
     * @param {?=} parent     Specifies the element of the parent node the nodes are to be appended to.
     * @param {?=} nodeIndex     Specifies the index at which the nodes to be inserted.
     * @return {?}
     */
    /* istanbul ignore next */
    addNode(node, parent, nodeIndex) { return; }
    ;
    /**
     * Removes the node with with the specified path and all of its children.
     *
     * @param {?} path     Specifies the path of the node to be removed.
     * @return {?}
     */
    /* istanbul ignore next */
    removeAt(path) { return; }
    ;
    /**
     * Removing all the nodes with the specified value.
     *
     * @param {?} value     Specifies the value of the nodes to be removed.
     * @return {?}
     */
    /* istanbul ignore next */
    removeNodesByValue(value) { return; }
    ;
    /**
     * Performs a UI update on the provided node element with the provided data.
     *
     * @param {?} element     Specifies the node to be updated.
     * @param {?} data     Specifies the new data item the node would update according to.
     * @return {?}
     */
    /* istanbul ignore next */
    applyChangesToNode(element, data) { return; }
    ;
    /**
     * Returns the transaction log stack.
     * @return {?}
     */
    /* istanbul ignore next */
    transactionLog() { return; }
    ;
    /**
     * Returns the data for the node with specified path.
     *
     * @param {?} path     Specifies the node path for which the data is returned.
     * @return {?}
     */
    /* istanbul ignore next */
    nodeDataFor(path) { return; }
    ;
    /**
     * Destructor for the igTree widget.
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
}
IgTreeComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-tree",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "width", "height", "checkboxMode", "singleBranchExpand", "hotTracking", "parentNodeImageUrl", "parentNodeImageClass", "parentNodeImageTooltip", "leafNodeImageUrl", "leafNodeImageClass", "leafNodeImageTooltip", "animationDuration", "pathSeparator", "dataSource", "dataSourceUrl", "dataSourceType", "responseDataKey", "responseDataType", "requestType", "responseContentType", "initialExpandDepth", "loadOnDemand", "bindings", "defaultNodeTarget", "dragAndDrop", "updateUrl", "dragAndDropSettings"],
                outputs: ["dataBinding", "dataBound", "rendering", "rendered", "selectionChanging", "selectionChanged", "nodeCheckstateChanging", "nodeCheckstateChanged", "nodePopulating", "nodePopulated", "nodeCollapsing", "nodeCollapsed", "nodeExpanding", "nodeExpanded", "nodeClick", "nodeDoubleClick", "dragStart", "drag", "dragStop", "nodeDropping", "nodeDropped"]
            }] }
];
/** @nocollapse */
IgTreeComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];
IgTreeComponent.propDecorators = {
    dataSource: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    IgTreeComponent.prototype._dataSource;
    /**
     * @type {?}
     * @private
     */
    IgTreeComponent.prototype._changes;
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWd0cmVlLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXItd3JhcHBlcnMvIiwic291cmNlcyI6WyJsaWIvaWd0cmVlL2lndHJlZS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBRSxlQUFlLEVBQUUsZUFBZSxFQUFFLGlCQUFpQixFQUFpQixLQUFLLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0ksT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBUS9ELE1BQU0sT0FBTyxlQUFnQixTQUFRLGFBQXFCOzs7Ozs7OztJQVF0RCxZQUFZLEVBQWMsRUFBRSxRQUFrQixFQUFFLE9BQXdCLEVBQUUsV0FBNEIsRUFBRSxHQUFzQjtRQUMxSCxLQUFLLENBQUMsRUFBRSxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsV0FBVyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQ25ELENBQUM7Ozs7O0lBUEQsSUFDVyxVQUFVLENBQUMsS0FBVTtRQUM1QixJQUFJLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQztJQUM3QixDQUFDO0lBQUEsQ0FBQzs7OztJQU1GLFFBQVE7UUFDSixJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsSUFBSSxJQUFJLENBQUMsV0FBVyxFQUFFO1lBQ2pELElBQUksQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQztTQUNqRDtRQUNELEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUNyQixDQUFDOzs7OztJQUNNLFdBQVcsQ0FBQyxPQUFzQjs7Y0FDL0IsRUFBRSxHQUFHLFlBQVk7UUFDdkIsNEJBQTRCO1FBQzVCLElBQUksRUFBRSxJQUFJLE9BQU8sRUFBRTs7a0JBQ1QsS0FBSyxHQUFHLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQyxZ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QUFxQixFQUFFLG9CQUFvQixFQUFFLGNBQWMsRUFBRSxVQUFVLEVBQUUsbUJBQW1CLEVBQUUsYUFBYSxFQUFFLFdBQVcsRUFBRSxxQkFBcUIsQ0FBQztnQkFDaGtCLE9BQU8sRUFBRSxDQUFDLGFBQWEsRUFBRSxXQUFXLEVBQUUsV0FBVyxFQUFFLFVBQVUsRUFBRSxtQkFBbUIsRUFBRSxrQkFBa0IsRUFBRSx3QkFBd0IsRUFBRSx1QkFBdUIsRUFBRSxnQkFBZ0IsRUFBRSxlQUFlLEVBQUUsZ0JBQWdCLEVBQUUsZUFBZSxFQUFFLGVBQWUsRUFBRSxjQUFjLEVBQUUsV0FBVyxFQUFFLGlCQUFpQixFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLGNBQWMsRUFBRSxhQUFhLENBQUM7YUFDcFc7Ozs7WUFSNkIsVUFBVTtZQUFwQixRQUFRO1lBQWMsZUFBZTtZQUFFLGVBQWU7WUFBRSxpQkFBaUI7Ozt5QkFZeEYsS0FBSzs7Ozs7OztJQUZOLHNDQUF5Qjs7Ozs7SUFDekIsbUNBQXNCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBSZW5kZXJlciwgRWxlbWVudFJlZiwgSXRlcmFibGVEaWZmZXJzLCBLZXlWYWx1ZURpZmZlcnMsIENoYW5nZURldGVjdG9yUmVmLCBTaW1wbGVDaGFuZ2VzLCBJbnB1dCB9IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQgeyBJZ0NvbnRyb2xCYXNlIH0gZnJvbSBcIi4uL2lnY29udHJvbGJhc2UvaWdjb250cm9sYmFzZVwiO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogXCJpZy10cmVlXCIsXG4gICAgdGVtcGxhdGU6IFwiPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlwiLFxuICAgIGlucHV0czogW1wid2lkZ2V0SWRcIiwgXCJvcHRpb25zXCIsIFwiY2hhbmdlRGV0ZWN0aW9uSW50ZXJ2YWxcIiwgXCJkaXNhYmxlZFwiLCBcImNyZWF0ZVwiLCBcIndpZHRoXCIsIFwiaGVpZ2h0XCIsIFwiY2hlY2tib3hNb2RlXCIsIFwic2luZ2xlQnJhbmNoRXhwYW5kXCIsIFwiaG90VHJhY2tpbmdcIiwgXCJwYXJlbnROb2RlSW1hZ2VVcmxcIiwgXCJwYXJlbnROb2RlSW1hZ2VDbGFzc1wiLCBcInBhcmVudE5vZGVJbWFnZVRvb2x0aXBcIiwgXCJsZWFmTm9kZUltYWdlVXJsXCIsIFwibGVhZk5vZGVJbWFnZUNsYXNzXCIsIFwibGVhZk5vZGVJbWFnZVRvb2x0aXBcIiwgXCJhbmltYXRpb25EdXJhdGlvblwiLCBcInBhdGhTZXBhcmF0b3JcIiwgXCJkYXRhU291cmNlXCIsIFwiZGF0YVNvdXJjZVVybFwiLCBcImRhdGFTb3VyY2VUeXBlXCIsIFwicmVzcG9uc2VEYXRhS2V5XCIsIFwicmVzcG9uc2VEYXRhVHlwZVwiLCBcInJlcXVlc3RUeXBlXCIsIFwicmVzcG9uc2VDb250ZW50VHlwZVwiLCBcImluaXRpYWxFeHBhbmREZXB0aFwiLCBcImxvYWRPbkRlbWFuZFwiLCBcImJpbmRpbmdzXCIsIFwiZGVmYXVsdE5vZGVUYXJnZXRcIiwgXCJkcmFnQW5kRHJvcFwiLCBcInVwZGF0ZVVybFwiLCBcImRyYWdBbmREcm9wU2V0dGluZ3NcIl0sXG4gICAgb3V0cHV0czogW1wiZGF0YUJpbmRpbmdcIiwgXCJkYXRhQm91bmRcIiwgXCJyZW5kZXJpbmdcIiwgXCJyZW5kZXJlZFwiLCBcInNlbGVjdGlvbkNoYW5naW5nXCIsIFwic2VsZWN0aW9uQ2hhbmdlZFwiLCBcIm5vZGVDaGVja3N0YXRlQ2hhbmdpbmdcIiwgXCJub2RlQ2hlY2tzdGF0ZUNoYW5nZWRcIiwgXCJub2RlUG9wdWxhdGluZ1wiLCBcIm5vZGVQb3B1bGF0ZWRcIiwgXCJub2RlQ29sbGFwc2luZ1wiLCBcIm5vZGVDb2xsYXBzZWRcIiwgXCJub2RlRXhwYW5kaW5nXCIsIFwibm9kZUV4cGFuZGVkXCIsIFwibm9kZUNsaWNrXCIsIFwibm9kZURvdWJsZUNsaWNrXCIsIFwiZHJhZ1N0YXJ0XCIsIFwiZHJhZ1wiLCBcImRyYWdTdG9wXCIsIFwibm9kZURyb3BwaW5nXCIsIFwibm9kZURyb3BwZWRcIl1cbn0pXG5leHBvcnQgY2xhc3MgSWdUcmVlQ29tcG9uZW50IGV4dGVuZHMgSWdDb250cm9sQmFzZTxJZ1RyZWU+IHtcbiAgICBwcml2YXRlIF9kYXRhU291cmNlOiBhbnk7XG4gICAgcHJpdmF0ZSBfY2hhbmdlczogYW55O1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNldCBkYXRhU291cmNlKHZhbHVlOiBhbnkpIHtcbiAgICAgICAgdGhpcy5fZGF0YVNvdXJjZSA9IHZhbHVlO1xuICAgIH07XG5cbiAgICBjb25zdHJ1Y3RvcihlbDogRWxlbWVudFJlZiwgcmVuZGVyZXI6IFJlbmRlcmVyLCBkaWZmZXJzOiBJdGVyYWJsZURpZmZlcnMsIGt2YWxEaWZmZXJzOiBLZXlWYWx1ZURpZmZlcnMsIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYpIHtcbiAgICAgICAgc3VwZXIoZWwsIHJlbmRlcmVyLCBkaWZmZXJzLCBrdmFsRGlmZmVycywgY2RyKTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnNbXCJkYXRhU291cmNlXCJdICYmIHRoaXMuX2RhdGFTb3VyY2UpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc1tcImRhdGFTb3VyY2VcIl0gPSB0aGlzLl9kYXRhU291cmNlO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgfVxuICAgIHB1YmxpYyBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGRzID0gXCJkYXRhU291cmNlXCI7XG4gICAgICAgIC8vY29uc3Qgb3B0aW9ucyA9IFwib3B0aW9uc1wiO1xuICAgICAgICBpZiAoZHMgaW4gY2hhbmdlcykge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjaGFuZ2VzW2RzXS5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2RpZmZlciAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpZmZlciA9IHRoaXMuX2RpZmZlcnMuZmluZCh2YWx1ZSkuY3JlYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9kYXRhU291cmNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VzLnB1c2godGhpcy5rdmFsRGlmZmVycy5maW5kKHt9KS5jcmVhdGUoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSBiaW5kaW5nIHRvIGFycmF5cyBpcyBzdXBwb3J0ZWQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdXBlci5uZ09uQ2hhbmdlcyhjaGFuZ2VzKTtcbiAgICB9XG4gICAgbmdEb0NoZWNrKCkge1xuICAgICAgICBpZiAodGhpcy5fZGlmZmVyKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VzID0gdGhpcy5fZGlmZmVyLmRpZmYodGhpcy5fZGF0YVNvdXJjZSk7XG4gICAgICAgICAgICAvL2NoZWNrIGlmIGdyaWQgaXMgaW5pdGlhbGl6ZWRcbiAgICAgICAgICAgIGNvbnN0IGVsZW0gPSBqUXVlcnkodGhpcy5fZWwpLmRhdGEodGhpcy5fd2lkZ2V0TmFtZSk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlcyAmJiBlbGVtKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhU291cmNlQXBwbHlDaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2NoYW5nZXMgJiYgZWxlbSkge1xuICAgICAgICAgICAgICAgIC8vY2hlY2sgcmVjc1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZGF0YVNvdXJjZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuX2RhdGFTb3VyY2VbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciByb3dDaGFuZ2VzID0gdGhpcy5fY2hhbmdlc1tpXS5kaWZmKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocm93Q2hhbmdlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93Q2hhbmdlcy5mb3JFYWNoQ2hhbmdlZEl0ZW0oKGNoYW5nZTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVJdGVtKGl0ZW0sIGNoYW5nZS5jdXJyZW50VmFsdWUsIGNoYW5nZS5rZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIubmdEb0NoZWNrKCk7XG4gICAgfVxuXG4gICAgYWRkSXRlbShpdGVtLCBpbmRleCkge1xuICAgICAgICB0aGlzLmRhdGFCaW5kKCk7XG4gICAgICAgIHRoaXMuX2NoYW5nZXMucHVzaCh0aGlzLmt2YWxEaWZmZXJzLmZpbmQoe30pLmNyZWF0ZSgpKTtcblxuICAgIH1cbiAgICBkZWxldGVJdGVtKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHRoaXMuZGF0YUJpbmQoKTtcbiAgICAgICAgdGhpcy5fY2hhbmdlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICBkYXRhU291cmNlQXBwbHlDaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgY2hhbmdlcy5mb3JFYWNoQWRkZWRJdGVtKHIgPT4gdGhpcy5hZGRJdGVtKHIuaXRlbSwgci5jdXJyZW50SW5kZXgpKTtcbiAgICAgICAgY2hhbmdlcy5mb3JFYWNoUmVtb3ZlZEl0ZW0ociA9PiB7IHRoaXMuZGVsZXRlSXRlbShyLml0ZW0sIHIucHJldmlvdXNJbmRleCk7IH0pO1xuXG4gICAgfVxuICAgIHVwZGF0ZUl0ZW0oaXRlbSwgdmFsdWUsIGtleSkge1xuICAgICAgICB0aGlzLmRhdGFCaW5kKCk7XG4gICAgfVxuXG4gICAgcHVibGljIG1hcmtGb3JDaGVjaygpIHtcbiAgICAgICAgc3VwZXIubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIGNvbnN0IGJpbmRpbmdzID0gdGhpc1tcImJpbmRpbmdzXCJdIHx8IHRoaXMub3B0aW9ucy5iaW5kaW5ncztcbiAgICAgICAgaWYgKGJpbmRpbmdzICYmIGJpbmRpbmdzLmNoaWxkRGF0YVByb3BlcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFCaW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gb3B0aW9uQ2hhbmdlKG9wdGlvbnM/KSB7XG4gICAgLy8gXHR2YXIgb3B0cyA9IG9wdGlvbnMgfHwgalF1ZXJ5LmV4dGVuZCh0cnVlLCB7fSwgdGhpcy5fY29uZmlnKTtcbiAgICAvLyBcdC8vIEJpbmRpbmdzIGFyZSBtb2RpZmllZCBpbnRlcm5hbGx5IGJ5IHRoZSB0cmVlLiBFeGNsdWRpbmcgdGhlbSBmcm9tIHRoZSBjaGFuZ2UgZGV0ZWN0aW9uXG4gICAgLy8gXHRpZiAob3B0cy5iaW5kaW5ncykge1xuICAgIC8vIFx0XHRkZWxldGUgb3B0cy5iaW5kaW5ncztcbiAgICAvLyBcdH1cbiAgICAvLyBcdHN1cGVyLm9wdGlvbkNoYW5nZShvcHRzKTtcbiAgICAvLyB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBkYXRhYmluZGluZyBvbiB0aGUgaWdUcmVlLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGRhdGFCaW5kKCk6IHZvaWQgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSBjaGVja3N0YXRlIG9mIGEgbm9kZSBpZiBjaGVja2JveE1vZGUgaXMgbm90IHNldCB0byBvZmYsIG90aGVyd2lzZSBkb2VzIG5vdGhpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbm9kZSAgICAgU3BlY2lmaWVzIHRoZSBub2RlIGVsZW1lbnQgdGhlIGNoZWNrYm94IG9mIHdoaWNoIHdvdWxkIGJlIHRvZ2dsZWQuXG4gICAgICogQHBhcmFtIGV2ZW50ICAgICBJbmRpY2F0ZXMgdGhlIGJyb3dzZXIgZXZlbnQgd2hpY2ggdHJpZ2dlcmVkIHRoaXMgYWN0aW9uLCBpZiB0aGlzIGlzIG5vdCBhbiBBUEkgY2FsbC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyB0b2dnbGVDaGVja3N0YXRlKG5vZGU6IE9iamVjdCwgZXZlbnQ/OiBPYmplY3QpOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgY29sbGFwc2UvZXhwYW5kIHN0YXRlIGZvciB0aGUgc3BlY2lmaWVkIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbm9kZSAgICAgU3BlY2lmaWVzIHRoZSBub2RlIGVsZW1lbnQgdGhlIGNoZWNrYm94IG9mIHdoaWNoIHdvdWxkIGJlIHRvZ2dsZWQuXG4gICAgICogQHBhcmFtIGV2ZW50ICAgICBJbmRpY2F0ZXMgdGhlIGJyb3dzZXIgZXZlbnQgd2hpY2ggdHJpZ2dlcmVkIHRoaXMgYWN0aW9uLCBpZiB0aGlzIGlzIG5vdCBhbiBBUEkgY2FsbC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyB0b2dnbGUobm9kZTogT2JqZWN0LCBldmVudD86IE9iamVjdCk6IHZvaWQgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBFeHBhbmRzIHRoZSB0cmVlIGRvd24gdG8gdGhlIHNwZWNpZmllZCBub2RlIGFuZCBzZWxlY3RzIHRoZSBub2RlIGlmIHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBub2RlICAgICBTcGVjaWZpZXMgdGhlIG5vZGUgZWxlbWVudCBkb3duIHRvIHdoaWNoIHRoZSB0cmVlIHdvdWxkIGJlIGV4cGFuZGVkLlxuICAgICAqIEBwYXJhbSB0b1NlbGVjdCAgICAgU3BlY2lmaWVzIHRoZSB3aGV0aGVyIHRvIHNlbGVjdCB0aGUgbm9kZSBhZnRlciBleHBhbmRpbmcgdG8gaXQuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgZXhwYW5kVG9Ob2RlKG5vZGU6IE9iamVjdCwgdG9TZWxlY3Q/OiBib29sZWFuKTogdm9pZCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIEV4cGFuZHMgdGhlIHNwZWNpZmllZCBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5vZGUgICAgIFNwZWNpZmllcyB0aGUgbm9kZSBlbGVtZW50IHRvIGV4cGFuZC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBleHBhbmQobm9kZTogT2JqZWN0KTogdm9pZCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIENvbGxhcHNlcyB0aGUgc3BlY2lmaWVkIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbm9kZSAgICAgU3BlY2lmaWVzIHRoZSBub2RlIGVsZW1lbnQgdG8gY29sbGFwc2UuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgY29sbGFwc2Uobm9kZTogT2JqZWN0KTogdm9pZCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgcGFyZW50IG5vZGUgZWxlbWVudCBvZiB0aGUgc3BlY2lmaWVkIG5vZGUgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBub2RlICAgICBTcGVjaWZpZXMgdGhlIGpRdWVyeSBzZWxlY3RlZCBub2RlIGVsZW1lbnQgdG8gY29sbGFwc2UuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgcGFyZW50Tm9kZShub2RlOiBPYmplY3QpOiBPYmplY3QgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGpRdWVyeSBlbGVtZW50IG9mIHRoZSBub2RlIHdpdGggdGhlIHNwZWNpZmllZCBwYXRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5vZGVQYXRoICAgICBTcGVjaWZpZXMgdGhlIHBhdGggdG8gdGhlIHJlcXVpcmVkIG5vZGUuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgbm9kZUJ5UGF0aChub2RlUGF0aDogc3RyaW5nKTogT2JqZWN0IHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBqUXVlcnkgZWxlbWVudCBvZiB0aGUgbm9kZSB3aXRoIHRoZSBzcGVjaWZpZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgICAgIFNwZWNpZmllcyB0aGUgdmFsdWUgb2YgdGhlIHJlcXVpcmVkIG5vZGUuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgbm9kZXNCeVZhbHVlKHZhbHVlOiBzdHJpbmcpOiBPYmplY3QgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYWxsIHRoZSBub2RlIG9iamVjdHMgZm9yIHRoZSBub2RlcyB0aGF0IGhhdmUgdGhlaXIgY2hlY2tib3hlcyBjaGVja2VkLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGNoZWNrZWROb2RlcygpOiBhbnlbXSB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhbGwgdGhlIG5vZGUgb2JqZWN0cyBmb3IgdGhlIG5vZGVzIHRoYXQgaGF2ZSB0aGVpciBjaGVja2JveGVzIHVuY2hlY2tlZC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyB1bmNoZWNrZWROb2RlcygpOiBhbnlbXSB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhbGwgdGhlIG5vZGUgb2JqZWN0cyBmb3IgdGhlIG5vZGVzIHRoYXQgaGF2ZSB0aGVpciBjaGVja2JveGVzIHBhcnRpYWxseSBjaGVja2VkLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIHBhcnRpYWxseUNoZWNrZWROb2RlcygpOiBhbnlbXSB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgYSBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5vZGUgICAgIFNwZWNpZmllcyB0aGUgbm9kZSBlbGVtZW50IHRvIGJlIHNlbGVjdGVkLlxuICAgICAqIEBwYXJhbSBldmVudCAgICAgSW5kaWNhdGVzIHRoZSBicm93c2VyIGV2ZW50IHdoaWNoIHRyaWdnZXJlZCB0aGlzIGFjdGlvbiwgaWYgdGhpcyBpcyBub3QgYW4gQVBJIGNhbGwuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgc2VsZWN0KG5vZGU6IE9iamVjdCwgZXZlbnQ/OiBPYmplY3QpOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogRGVzZWxlY3RzIHRoZSBzcGVjaWZpZWQgbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBub2RlICAgICBTcGVjaWZpZXMgdGhlIG5vZGUgZWxlbWVudCB0byBiZSBkZXNlbGVjdGVkLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGRlc2VsZWN0KG5vZGU6IE9iamVjdCk6IHZvaWQgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBEZXNlbGVjdHMgYWxsIHRoZSBzZWxlY3RlZCBub2Rlcy5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBjbGVhclNlbGVjdGlvbigpOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBub2RlIG9iamVjdCBmb3IgdGhlIHNlbGVjdGVkIG5vZGUuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgc2VsZWN0ZWROb2RlKCk6IE9iamVjdCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhbGwgbm9kZSBvYmplY3RzIHdpdGggdGhlIHNwZWNpZmllZCB0ZXh0IChjYXNlIHNlbnNpdGl2ZSkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGV4dCAgICAgVGhlIHRleHQgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0gcGFyZW50ICAgICBUaGUgbm9kZSBlbGVtZW50IHRvIHN0YXJ0IHRoZSBzZWFyY2ggZnJvbS4gSWYgbm90IHNwZWNpZmllZCB0aGVuIHNlYXJjaCB3b3VsZCBzdGFydCBmcm9tIHRoZSByb290IG9mIHRoZSB0cmVlLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGZpbmROb2Rlc0J5VGV4dCh0ZXh0OiBzdHJpbmcsIHBhcmVudD86IE9iamVjdCk6IGFueVtdIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGFsbCBub2RlIG9iamVjdHMgZm9yIHRoZSBpbW1lZGlhdGUgY2hpbGRyZW4gb2YgdGhlIHNwZWNpZmllZCBwYXJlbnQgd2l0aCB0aGUgc3BlY2lmaWVkIHRleHQgKGNhc2Ugc2Vuc2l0aXZlKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0ZXh0ICAgICBUaGUgdGV4dCB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSBwYXJlbnQgICAgIFRoZSBub2RlIGVsZW1lbnQgdGhlIGNoaWxkcmVuIG9mIHdoaWNoIHdvdWxkIGJlIHNlYXJjaGVkLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGZpbmRJbW1lZGlhdGVOb2Rlc0J5VGV4dCh0ZXh0OiBzdHJpbmcsIHBhcmVudD86IE9iamVjdCk6IGFueVtdIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBuLXRoIGpRdWVyeSBub2RlIGVsZW1lbnQgY2hpbGQgb2YgdGhlIHNwZWNpZmllZCBwYXJlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kZXggICAgIFNwZWNpZmllcyB0aGUgaW5kZXggdGhlIG5vZGUgYXQgd2hpY2ggdG8gYmUgcmV0cmlldmVkLlxuICAgICAqIEBwYXJhbSBwYXJlbnQgICAgIFRoZSBwYXJlbnQgbm9kZSBlbGVtZW50IHRvIHN0YXJ0IHRoZSBzZWFyY2ggZnJvbS5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBub2RlQnlJbmRleChpbmRleDogbnVtYmVyLCBwYXJlbnQ/OiBPYmplY3QpOiBPYmplY3QgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBub2RlIG9iamVjdCBmb3IgdGhlIHNwZWNpZmllZCBub2RlIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbWVudCAgICAgU3BlY2lmaWVzIHRoZSBub2RlIGVsZW1lbnQuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgbm9kZUZyb21FbGVtZW50KGVsZW1lbnQ6IE9iamVjdCk6IE9iamVjdCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIG5vZGUgb2JqZWN0IGNvbGxlY3Rpb24gb2YgdGhlIGltbWVkaWF0ZSBjaGlsZHJlbiBvZiB0aGUgcHJvdmlkZWQgbm9kZSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmVudCAgICAgU3BlY2lmaWVzIHRoZSBub2RlIGVsZW1lbnQuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgY2hpbGRyZW4ocGFyZW50OiBPYmplY3QpOiBhbnlbXSB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIG5vZGUgb2JqZWN0IGNvbGxlY3Rpb24gb2YgdGhlIGltbWVkaWF0ZSBjaGlsZHJlbiBvZiB0aGUgbm9kZSB3aXRoIHRoZSBwcm92aWRlZCBwYXRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdGggICAgIFNwZWNpZmllcyB0aGUgcGF0aCBvZiB0aGUgbm9kZSB0aGUgY2hpbGRyZW4gb2Ygd2hpY2ggYXJlIHRvIGJlIHJldHJpZXZlZC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBjaGlsZHJlbkJ5UGF0aChwYXRoOiBzdHJpbmcpOiBhbnlbXSB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgbm9kZSBlbGVtZW50IGlzIHNlbGVjdGVkIGFuZCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbm9kZSAgICAgU3BlY2lmaWVzIHRoZSBub2RlIGVsZW1lbnQuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgaXNTZWxlY3RlZChub2RlOiBPYmplY3QpOiBib29sZWFuIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCBub2RlIGVsZW1lbnQgaXMgZXhwYW5kZWQgYW5kIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBub2RlICAgICBTcGVjaWZpZXMgdGhlIG5vZGUgZWxlbWVudC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBpc0V4cGFuZGVkKG5vZGU6IE9iamVjdCk6IGJvb2xlYW4geyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGVkIG5vZGUgZWxlbWVudCBoYXMgaXRzIGNoZWNrYm94IGNoZWNrc3RhdGUgY2hlY2tlZCBhbmQgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5vZGUgICAgIFNwZWNpZmllcyB0aGUgbm9kZSBlbGVtZW50LlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGlzQ2hlY2tlZChub2RlOiBPYmplY3QpOiBib29sZWFuIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3BlY2lmaWVkIG5vZGUgY2hlY2tzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBub2RlICAgICBTcGVjaWZpZXMgdGhlIG5vZGUgZWxlbWVudC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBjaGVja1N0YXRlKG5vZGU6IE9iamVjdCk6IHN0cmluZyB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgYXJyYXkgb2Ygbm9kZXMgdG8gdGhlIHRyZWUuIE5ldyBub2RlcyBhcmUgYXBwZW5kZWQgdG8gdGhlIHJvb3Qgb3IgdG8gYSBzcGVjaWZpZWQgcGFyZW50IG5vZGUsIGF0IGEgc3BlY2lmaWVkIGluZGV4LlxuICAgICAqXG4gICAgICogQHBhcmFtIG5vZGUgICAgIFNwZWNpZmllcyB0aGUgZGF0YSB1c2VkIHRvIGNyZWF0ZSB0aGUgbmV3IG5vZGXRgS5cbiAgICAgKiBAcGFyYW0gcGFyZW50ICAgICBTcGVjaWZpZXMgdGhlIGVsZW1lbnQgb2YgdGhlIHBhcmVudCBub2RlIHRoZSBub2RlcyBhcmUgdG8gYmUgYXBwZW5kZWQgdG8uXG4gICAgICogQHBhcmFtIG5vZGVJbmRleCAgICAgU3BlY2lmaWVzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgbm9kZXMgdG8gYmUgaW5zZXJ0ZWQuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgYWRkTm9kZShub2RlOiBPYmplY3QsIHBhcmVudD86IE9iamVjdCwgbm9kZUluZGV4PzogbnVtYmVyKTogdm9pZCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIG5vZGUgd2l0aCB3aXRoIHRoZSBzcGVjaWZpZWQgcGF0aCBhbmQgYWxsIG9mIGl0cyBjaGlsZHJlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoICAgICBTcGVjaWZpZXMgdGhlIHBhdGggb2YgdGhlIG5vZGUgdG8gYmUgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyByZW1vdmVBdChwYXRoOiBzdHJpbmcpOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZpbmcgYWxsIHRoZSBub2RlcyB3aXRoIHRoZSBzcGVjaWZpZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgICAgIFNwZWNpZmllcyB0aGUgdmFsdWUgb2YgdGhlIG5vZGVzIHRvIGJlIHJlbW92ZWQuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgcmVtb3ZlTm9kZXNCeVZhbHVlKHZhbHVlOiBzdHJpbmcpOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBVSSB1cGRhdGUgb24gdGhlIHByb3ZpZGVkIG5vZGUgZWxlbWVudCB3aXRoIHRoZSBwcm92aWRlZCBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1lbnQgICAgIFNwZWNpZmllcyB0aGUgbm9kZSB0byBiZSB1cGRhdGVkLlxuICAgICAqIEBwYXJhbSBkYXRhICAgICBTcGVjaWZpZXMgdGhlIG5ldyBkYXRhIGl0ZW0gdGhlIG5vZGUgd291bGQgdXBkYXRlIGFjY29yZGluZyB0by5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBhcHBseUNoYW5nZXNUb05vZGUoZWxlbWVudDogT2JqZWN0LCBkYXRhOiBPYmplY3QpOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdHJhbnNhY3Rpb24gbG9nIHN0YWNrLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIHRyYW5zYWN0aW9uTG9nKCk6IGFueVtdIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGF0YSBmb3IgdGhlIG5vZGUgd2l0aCBzcGVjaWZpZWQgcGF0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoICAgICBTcGVjaWZpZXMgdGhlIG5vZGUgcGF0aCBmb3Igd2hpY2ggdGhlIGRhdGEgaXMgcmV0dXJuZWQuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgbm9kZURhdGFGb3IocGF0aDogc3RyaW5nKTogT2JqZWN0IHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogRGVzdHJ1Y3RvciBmb3IgdGhlIGlnVHJlZSB3aWRnZXQuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgZGVzdHJveSgpOiB2b2lkIHsgcmV0dXJuOyB9O1xufSJdfQ==