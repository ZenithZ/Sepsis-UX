/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ElementRef, Renderer, KeyValueDiffers, IterableDiffers, ChangeDetectionStrategy, ChangeDetectorRef } from '@angular/core';
import { IgGridBase } from './iggridbase';
export class IgGridComponent extends IgGridBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiff
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiff, cdr) { super(el, renderer, differs, kvalDiff, cdr); }
    /**
     * Returns the element holding the data records
     * @return {?}
     */
    /* istanbul ignore next */
    widget() { return; }
    ;
    /**
     * Returns whether grid has non-data fixed columns(e.g. row selectors column)
     * @return {?}
     */
    /* istanbul ignore next */
    hasFixedDataSkippedColumns() { return; }
    ;
    /**
     * Returns true if grid has at least one fixed columns(even if a non-data column - like row-selectors column)
     * @return {?}
     */
    /* istanbul ignore next */
    hasFixedColumns() { return; }
    ;
    /**
     * Returns the current fixing direction. NOTE - use only if ColumnFixing feature is enabled
     * @return {?} left|right
     */
    /* istanbul ignore next */
    fixingDirection() { return; }
    ;
    /**
     * Returns whether the column with identifier colKey is fixed
     *
     * @param {?} colKey     An identifier of the column which should be checked. It can be a key or visible index.
     * @return {?}
     */
    /* istanbul ignore next */
    isFixedColumn(colKey) { return; }
    ;
    /**
     * Called to detect whether grid container is resized. When autoAdjustHeight is true and height of the grid is changed then the height of grid is re-set.
     * @return {?}
     */
    /* istanbul ignore next */
    resizeContainer() { return; }
    ;
    /**
     * Returns whether the header identified by colKey is multicolumn header(has children)
     *
     * @param {?} colKey     value of the column key
     * @return {?}
     */
    /* istanbul ignore next */
    isGroupHeader(colKey) { return; }
    ;
    /**
     * Returns an object that contains information on the passed Dom element
     *
     * 				rowId - the id of the record associated with the element - if primaryKey is not set this will be null.
     * 				rowIndex - the index (in the DOM) of the row associated with the element.
     * 				recordIndex - index of the data record associated with this element in the current dataView.
     * 				columnObject  - the column object associated with this element ( if the element is tr this will be null)
     *
     * @param {?} elem    The Dom element or jQuery object which can be a TD or TR element from the grid.
     * @return {?}
     */
    /* istanbul ignore next */
    getElementInfo(elem) { return; }
    ;
    /**
     * Returns the ID of the TABLE element where data records are rendered
     * @return {?}
     */
    /* istanbul ignore next */
    id() { return; }
    ;
    /**
     * Returns the DIV that is the topmost container of the grid widget
     * @return {?}
     */
    /* istanbul ignore next */
    container() { return; }
    ;
    /**
     * Returns the table that contains the header cells
     * @return {?}
     */
    /* istanbul ignore next */
    headersTable() { return; }
    ;
    /**
     * Returns the table that contains the footer cells
     * @return {?}
     */
    /* istanbul ignore next */
    footersTable() { return; }
    ;
    /**
     * Returns the DIV that is used as a scroll container for the grid contents
     * @return {?}
     */
    /* istanbul ignore next */
    scrollContainer() { return; }
    ;
    /**
     * Returns the DIV that is the topmost container of the fixed grid - contains fixed columns(in ColumnFixing scenario)
     * @return {?}
     */
    /* istanbul ignore next */
    fixedContainer() { return; }
    ;
    /**
     * Returns the DIV that is the topmost container of the fixed body grid - contains fixed columns(in ColumnFixing scenario)
     * @return {?}
     */
    /* istanbul ignore next */
    fixedBodyContainer() { return; }
    ;
    /**
     * Returns container(jQuery representation) containing fixed footer - contains fixed columns(in ColumnFixing scenario)
     * @return {?}
     */
    /* istanbul ignore next */
    fixedFooterContainer() { return; }
    ;
    /**
     * Returns container(jQuery representation) containing fixed header - contains fixed columns(in ColumnFixing scenario)
     * @return {?}
     */
    /* istanbul ignore next */
    fixedHeaderContainer() { return; }
    ;
    /**
     * Returns the table that contains the FIXED header cells - contains fixed columns(in ColumnFixing scenario)
     * @return {?}
     */
    /* istanbul ignore next */
    fixedHeadersTable() { return; }
    ;
    /**
     * Returns the table that contains the footer cells - contains fixed columns(in ColumnFixing scenario)
     * @return {?}
     */
    /* istanbul ignore next */
    fixedFootersTable() { return; }
    ;
    /**
     * Returns the cell TD element at the specified location
     *
     * @param {?} x     The column index.
     * @param {?} y     The row index.
     * @param {?} isFixed     Optional parameter - if true get cell TD at the specified location from the fixed table
     * @return {?}
     */
    /* istanbul ignore next */
    cellAt(x, y, isFixed) { return; }
    ;
    /**
     * Returns the cell TD element by row id and column key
     *
     * @param {?} rowId     The id of the row.
     * @param {?} columnKey     The column key.
     * @return {?}
     */
    /* istanbul ignore next */
    cellById(rowId, columnKey) { return; }
    ;
    /**
     * Returns the fixed table - contains fixed columns(in ColumnFixing scenario). If there aren't fixed columns returns the grid table
     * @return {?}
     */
    /* istanbul ignore next */
    fixedTable() { return; }
    ;
    /**
     * Gets all immediate children of the current grid
     * @return {?}
     */
    /* istanbul ignore next */
    immediateChildrenWidgets() { return; }
    ;
    /**
     * Gets all children of the current grid, recursively
     * @return {?}
     */
    /* istanbul ignore next */
    childrenWidgets() { return; }
    ;
    /**
     * Gets all children's elements of the current grid, recursively
     * @return {?}
     */
    /* istanbul ignore next */
    children() { return; }
    ;
    /**
     * Gets all immediate children's elements of the current grid
     * @return {?}
     */
    /* istanbul ignore next */
    immediateChildren() { return; }
    ;
    /**
     * Returns the row (TR element) at the specified index. jQuery selectors aren't used for performance reasons
     *
     * @param {?} i     The row index.
     * @return {?}
     */
    /* istanbul ignore next */
    rowAt(i) { return; }
    ;
    /**
     * Returns the row TR element by row id
     *
     * @param {?} rowId     The id of the row.
     * @param {?=} isFixed     Specify search in the fixed container.
     * @return {?}
     */
    /* istanbul ignore next */
    rowById(rowId, isFixed) { return; }
    ;
    /**
     * Returns the fixed row (TR element) at the specified index. jQuery selectors aren't used for performance reasons(in ColumnFixing scenario - only when there is at least one fixed column)
     *
     * @param {?} i     The row index.
     * @return {?}
     */
    /* istanbul ignore next */
    fixedRowAt(i) { return; }
    ;
    /**
     * Returns a list of all fixed TR elements holding data in the grid(in ColumnFixing scenario - only when there is at least one fixed column)
     * @return {?}
     */
    /* istanbul ignore next */
    fixedRows() { return; }
    ;
    /**
     * Returns a list of all TR elements holding data in the grid(when there is at least one fixed column returns rows only in the UNFIXED table)
     * @return {?}
     */
    /* istanbul ignore next */
    rows() { return; }
    ;
    /**
     * Returns all data fixed rows recursively, not only the immediate ones(in ColumnFixing scenario - only when there is at least one fixed column)
     * @return {?}
     */
    /* istanbul ignore next */
    allFixedRows() { return; }
    ;
    /**
     * Returns all data rows recursively, not only the immediate ones(when there is at least one fixed column returns rows only in the UNFIXED table)
     * @return {?}
     */
    /* istanbul ignore next */
    allRows() { return; }
    ;
    /**
     * Returns a column object by the specified column key
     *
     * @param {?} key     The column key.
     * @return {?}
     */
    /* istanbul ignore next */
    columnByKey(key) { return; }
    ;
    /**
     * Returns a column object by the specified header text. If there are multiple matches, returns the first one.
     *
     * @param {?} text     The column header text.
     * @return {?}
     */
    /* istanbul ignore next */
    columnByText(text) { return; }
    ;
    /**
     * Returns an array of selected cells in arbitrary order where every objects has the format { element: , row: , index: , rowIndex: , columnKey: } .
     * 				If multiple selection is disabled the function will return null.
     * @return {?}
     */
    /* istanbul ignore next */
    selectedCells() { return; }
    ;
    /**
     * Returns an array of selected rows in arbitrary order where every object has the format { element: , index: } .
     * 				If multiple selection is disabled the function will return null.
     * @return {?}
     */
    /* istanbul ignore next */
    selectedRows() { return; }
    ;
    /**
     * Returns the currently selected cell that has the format { element: , row: , index: , rowIndex: , columnKey: }, if any.
     * 				If multiple selection is enabled the function will return null.
     * @return {?}
     */
    /* istanbul ignore next */
    selectedCell() { return; }
    ;
    /**
     * Returns the currently selected row that has the format { element: , index: }, if any.
     * 				If multiple selection is enabled the function will return null.
     * @return {?}
     */
    /* istanbul ignore next */
    selectedRow() { return; }
    ;
    /**
     * Returns the currently active (focused) cell that has the format { element: , row: , index: , rowIndex: , columnKey: }, if any.
     * @return {?}
     */
    /* istanbul ignore next */
    activeCell() { return; }
    ;
    /**
     * Returns the currently active (focused) row that has the format { element: , index: }, if any.
     * @return {?}
     */
    /* istanbul ignore next */
    activeRow() { return; }
    ;
    /**
     * Retrieves a cell value using the row index and the column key. If a primaryKey is defined, rowId is assumed to be the row Key (not index).
     * 				If primary key is not defined, then rowId is converted to a number and is used as a row index.
     *
     * @param {?} rowId     Row index or row key (primary key).
     * @param {?} colKey     The column key.
     * @return {?}
     */
    /* istanbul ignore next */
    getCellValue(rowId, colKey) { return; }
    ;
    /**
     * Returns the cell text. If colKey is a number, the index of the column is used (instead of a column name)- does not apply when using a Multi-Row Layout grid.
     * 				This is the actual text (or HTML string) for the contents of the cell.
     *
     * @param {?} rowId     Row index or row data key (primary key)
     * @param {?} colKey     Column key.
     * @return {?}
     */
    /* istanbul ignore next */
    getCellText(rowId, colKey) { return; }
    ;
    /**
     * Sets a new template for a column after initialization and renders the grid if not explicitly disabled. This method will replace any existing explicitly set row template and will build one anew from the column ones.
     *
     * @param {?} col     An identifier of the column to set template for (index or key)
     * @param {?} tmpl     The column template to set
     * @param {?=} render     Should the grid rerender after template is set
     * @return {?}
     */
    /* istanbul ignore next */
    setColumnTemplate(col, tmpl, render) { return; }
    ;
    /**
     * Commits all pending transactions to the client data source. Note that there won't be anything to commit on the UI, since it is updated instantly. In order to rollback the actual UI, a call to dataBind() is required.
     *
     * @param {?=} rowId     If specified, will commit only that transaction corresponding to the specified record key.
     * @return {?}
     */
    /* istanbul ignore next */
    commit(rowId) { return; }
    ;
    /**
     * Clears the transaction log (delegates to igDataSource). Note that this does not update the UI. In case the UI must be updated, set the second parameter "updateUI" to true, which will trigger a call to dataBind() to re-render the contents.
     *
     * @param {?=} rowId     If specified, will only rollback the transactions with that row id.
     * @param {?=} updateUI     Whether to update the UI or not.
     * @return {?}
     */
    /* istanbul ignore next */
    rollback(rowId, updateUI) { return; }
    ;
    /**
     * Returns a record by a specified key (requires that primaryKey is set in the settings).
     * 				That is a wrapper for this.dataSource.findRecordByKey(key).
     *
     * @param {?} key     Primary key of the record
     * @return {?}
     */
    /* istanbul ignore next */
    findRecordByKey(key) { return; }
    ;
    /**
     * Returns a standalone object (copy) that represents the committed transactions, but detached from the data source.
     * 				That is a wrapper for this.dataSource.getDetachedRecord(t).
     *
     * @param {?} t     A transaction object.
     * @return {?}
     */
    /* istanbul ignore next */
    getDetachedRecord(t) { return; }
    ;
    /**
     * Returns a list of all transaction objects that are pending to be committed or rolled back to the data source.
     * 				That is a wrapper for this.dataSource.pendingTransactions().
     * @return {?}
     */
    /* istanbul ignore next */
    pendingTransactions() { return; }
    ;
    /**
     * Returns a list of all transaction objects that are either pending, or have been committed in the data source.
     * 				That is a wrapper for this.dataSource.allTransactions().
     * @return {?}
     */
    /* istanbul ignore next */
    allTransactions() { return; }
    ;
    /**
     * Returns the accumulated transaction log as a string. The purpose of this is to be passed to URLs or used conveniently.
     * 				That is a wrapper for this.dataSource.transactionsAsString().
     * @return {?}
     */
    /* istanbul ignore next */
    transactionsAsString() { return; }
    ;
    /**
     * Invokes an AJAX request to the updateUrl option (if specified) and passes the serialized transaction log (a serialized JSON string) as part of the POST request.
     *
     * @param {?} success    Specifies a custom function to be called when AJAX request to the updateUrl option succeeds(optional)
     * @param {?} error    Specifies a custom function to be called when AJAX request to the updateUrl option fails(optional)
     * @return {?}
     */
    /* istanbul ignore next */
    saveChanges(success, error) { return; }
    ;
    /**
     * Adds a new row (TR) to the grid, by taking a data row object. Assumes the record will have the primary key.
     *
     * @param {?=} rec     Identifier/key of row. If missing, then number of rows in grid is used.
     * @return {?}
     */
    /* istanbul ignore next */
    renderNewRow(rec) { return; }
    ;
    /**
     * If the data source points to a local JSON array of data, and it is necessary to reset it at runtime, it must be done through this API member instead of the options (options.dataSource)
     *
     * @param {?} dataSource     New data source object.
     * @return {?}
     */
    /* istanbul ignore next */
    dataSourceObject(dataSource) { return; }
    ;
    /**
     * Returns the total number of records in the underlying backend. If paging or filtering is enabled, this may differ from the number of records in the client-side data source.
     * 				In order for this to work, the response JSON/XML must include a property that specifies the total number of records, which name is specified by options.responseTotalRecCountKey.
     * 				This functionality is completely delegated to the data source control.
     * @return {?}
     */
    /* istanbul ignore next */
    totalRecordsCount() { return; }
    ;
    /**
     * Causes the grid to data bind to the data source (local or remote) , and re-render all of the data as well
     *
     * @param {?} internal
     * @return {?}
     */
    /* istanbul ignore next */
    dataBind(internal) { return; }
    ;
    /**
     * Moves a visible column at a specified place, in front or behind a target column or at a target index
     * 			Note: This method is asynchronous which means that it returns immediately and any subsequent code will execute in parallel. This may lead to runtime errors. To avoid them put the subsequent code in the callback parameter provided by the method.
     *
     * @param {?} column    An identifier of the column to be moved. It can be a key, a Multi-Column Header identificator, or an index in a number format. The latter is not supported when the grid contains multi-column headers.
     * @param {?} target    An identifier of a column where the moved column should move to or an index at which the moved column should be moved to. In the case of a column identifier the column will be moved after it by default.
     * @param {?=} after    Specifies whether the column moved should be moved after or before the target column. This parameter is disregarded if there is no target column specified but a target index is used.
     * @param {?=} inDom    Specifies whether the column moving will be enacted through DOM manipulation or through rerendering of the grid.
     * @param {?=} callback    Specifies a custom function to be called when the column is moved.
     * @return {?}
     */
    /* istanbul ignore next */
    moveColumn(column, target, after, inDom, callback) { return; }
    ;
    /**
     * Shows a hidden column. If the column is not hidden the method does nothing.
     * 				Note: This method is asynchronous which means that it returns immediately and any subsequent code will execute in parallel. This may lead to runtime errors. To avoid them put the subsequent code in the callback parameter provided by the method.
     *
     * @param {?} column     An identifier for the column. If a number is provided it will be used as a column index. If a string is provided it will be used as a column key.
     * @param {?} callback     Specifies a custom function to be called when the column is shown(optional)
     * @return {?}
     */
    /* istanbul ignore next */
    showColumn(column, callback) { return; }
    ;
    /**
     * Hides a visible column. If the column is hidden the method does nothing.
     * 				Note: This method is asynchronous which means that it returns immediately and any subsequent code will execute in parallel. This may lead to runtime errors. To avoid them put the subsequent code in the callback parameter provided by the method.
     *
     * @param {?} column     An identifier for the column. If a number is provided it will be used as a column index else if a string is provided it will be used as a column key.
     * @param {?} callback     Specifies a custom function to be called when the column is hidden(optional)
     * @return {?}
     */
    /* istanbul ignore next */
    hideColumn(column, callback) { return; }
    ;
    /**
     * Gets unbound values for the specified column key. If key is not specified returns all unboundvalues
     *
     * @param {?} key     column key
     * @return {?}
     */
    /* istanbul ignore next */
    getUnboundValues(key) { return; }
    ;
    /**
     * Sets unbound values for the unbound column with the specified key. If removeOldValues is true then values(if any) for the unbound columns are re-set with the new values
     *
     * @param {?} key     key of the unbound column
     * @param {?} values     array of values to be set on unbound values
     * @param {?} removeOldValues     if true removes current unbound values(if any) for the specified column and apply the new ones specified in parameter values. Otherwise merge current values with the specified in parameter values
     * @return {?}
     */
    /* istanbul ignore next */
    setUnboundValues(key, values, removeOldValues) { return; }
    ;
    /**
     * Sets unbound value for the unbound cell by the specified column key and row primary key.
     *
     * @param {?} col     key of the unbound column
     * @param {?} rowId     primary key value of the row
     * @param {?} val     value to be set on unbound cell
     * @param {?} notToRender     if false will re-render the row
     * @return {?}
     */
    /* istanbul ignore next */
    setUnboundValueByPK(col, rowId, val, notToRender) { return; }
    ;
    /**
     * Returns an unbound column with the specified key. If not found returns null
     *
     * @param {?} key    a column key
     * @return {?}
     */
    /* istanbul ignore next */
    getUnboundColumnByKey(key) { return; }
    ;
    /**
     * Returns whether there is vertical scrollbar. Because of perfrormance issues in older Internet Explorer especially 8,9 - there is no need to check if height is not set - there is no scrollbar OR if row virtualization is enabled - it is supposed there is vertical scrollbar
     * @return {?}
     */
    /* istanbul ignore next */
    hasVerticalScrollbar() { return; }
    ;
    /**
     * Auto resize columns that have property width set to "*" so content to be auto-fitted(not shrinked/cutted). Auto-resizing is applied ONLY for visible columns
     * @return {?}
     */
    /* istanbul ignore next */
    autoSizeColumns() { return; }
    ;
    /**
     * Calculates the width of the column so its content to be auto-fitted to the width of the data in it(the content should NOT be shrinked/cutted)
     *
     * @param {?} columnIndex    Visible column index
     * @return {?}
     */
    /* istanbul ignore next */
    calculateAutoFitColumnWidth(columnIndex) { return; }
    ;
    /**
     * Get visible index by specified column key. If column is not found or is hidden then returns -1.
     * 				Note: Method does not count column groups (Multi-Column Headers).
     *
     * @param {?} columnKey     columnKey
     * @param {?} includeDataSkip     Optional parameter - if set to true include non data columns(like expander column, row selectors column, etc.) in calculations
     * @return {?}
     */
    /* istanbul ignore next */
    getVisibleIndexByKey(columnKey, includeDataSkip) { return; }
    ;
    /**
     * When called the method re-renders the whole grid(also rebinds to the data source) and renders the cols object
     *
     * @param {?} cols an array of column objects
     * @return {?}
     */
    /* istanbul ignore next */
    renderMultiColumnHeader(cols) { return; }
    ;
    /**
     * Scroll to the specified row or specified position(in pixels)
     *
     * @param {?} scrollerPosition     An identifier of the vertical scroll position. When it is string then it is interpreted as pixels otherwise it is the row number
     * @return {?}
     */
    /* istanbul ignore next */
    virtualScrollTo(scrollerPosition) { return; }
    ;
    /**
     * Returns column object and visible index for the table cell(TD) which is passed as argument
     *
     * @param {?} $td     cell(TD) - either DOM TD element or jQuery object
     * @return {?}
     */
    /* istanbul ignore next */
    getColumnByTD($td) { return; }
    ;
    /**
     * Destroy is part of the jQuery UI widget API and does the following:
     * 				1. Remove custom CSS classes that were added.
     * 				2. Unwrap any wrapping elements such as scrolling divs and other containers.
     * 				3. Unbind all events that were bound.
     *
     * @param {?} notToCallDestroy
     * @return {?}
     */
    /* istanbul ignore next */
    destroy(notToCallDestroy) { return; }
    ;
}
IgGridComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                "selector": "ig-grid",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "width", "height", "autoAdjustHeight", "avgRowHeight", "avgColumnWidth", "defaultColumnWidth", "autoGenerateColumns", "virtualization", "virtualizationMode", "requiresDataBinding", "rowVirtualization", "columnVirtualization", "virtualizationMouseWheelStep", "adjustVirtualHeights", "templatingEngine", "columns", "dataSource", "dataSourceUrl", "dataSourceType", "responseDataKey", "responseTotalRecCountKey", "requestType", "responseContentType", "showHeader", "showFooter", "fixedHeaders", "fixedFooters", "caption", "features", "tabIndex", "localSchemaTransform", "primaryKey", "serializeTransactionLog", "autoCommit", "aggregateTransactions", "autoFormat", "renderCheckboxes", "updateUrl", "restSettings", "alternateRowStyles", "autofitLastColumn", "enableHoverStyles", "enableUTCDates", "mergeUnboundColumns", "jsonpRequest", "enableResizeContainerCheck", "featureChooserIconDisplay", "scrollSettings"],
                outputs: ["cellClick", "cellRightClick", "dataBinding", "dataBound", "rendering", "rendered", "dataRendering", "dataRendered", "headerRendering", "headerRendered", "footerRendering", "footerRendered", "headerCellRendered", "rowsRendering", "rowsRendered", "schemaGenerated", "columnsCollectionModified", "requestError", "created", "destroyed"]
            }] }
];
/** @nocollapse */
IgGridComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWdncmlkLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXItd3JhcHBlcnMvIiwic291cmNlcyI6WyJsaWIvaWdncmlkL2lnZ3JpZC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxlQUFlLEVBQUUsZUFBZSxFQUFFLHVCQUF1QixFQUFFLGlCQUFpQixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzlJLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFTMUMsTUFBTSxPQUFPLGVBQWdCLFNBQVEsVUFBa0I7Ozs7Ozs7O0lBQ25ELFlBQVksRUFBYyxFQUFFLFFBQWtCLEVBQUUsT0FBd0IsRUFBRSxRQUF5QixFQUFFLEdBQXNCLElBQUksS0FBSyxDQUFDLEVBQUUsRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7Ozs7OztJQU10SyxNQUFNLEtBQVcsT0FBTyxDQUFDLENBQUM7SUFBQSxDQUFDOzs7Ozs7SUFNM0IsMEJBQTBCLEtBQWMsT0FBTyxDQUFDLENBQUM7SUFBQSxDQUFDOzs7Ozs7SUFNbEQsZUFBZSxLQUFjLE9BQU8sQ0FBQyxDQUFDO0lBQUEsQ0FBQzs7Ozs7O0lBT3ZDLGVBQWUsS0FBYSxPQUFPLENBQUMsQ0FBQztJQUFBLENBQUM7Ozs7Ozs7O0lBUXRDLGFBQWEsQ0FBQyxNQUFjLElBQWEsT0FBTyxDQUFDLENBQUM7SUFBQSxDQUFDOzs7Ozs7SUFNbkQsZUFBZSxLQUFXLE9BQU8sQ0FBQyxDQUFDO0lBQUEsQ0FBQzs7Ozs7Ozs7SUFRcEMsYUFBYSxDQUFDLE1BQWMsSUFBWSxPQUFPLENBQUMsQ0FBQztJQUFBLENBQUM7Ozs7Ozs7Ozs7Ozs7SUFhbEQsY0FBYyxDQUFDLElBQWEsSUFBWSxPQUFPLENBQUMsQ0FBQztJQUFBLENBQUM7Ozs7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QTJCLEVBQUUsY0FBYyxFQUFFLFNBQVMsRUFBRSxXQUFXLENBQUM7YUFDMVY7Ozs7WUFUbUIsVUFBVTtZQUFFLFFBQVE7WUFBbUIsZUFBZTtZQUFoQyxlQUFlO1lBQTRDLGlCQUFpQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiwgUmVuZGVyZXIsIEtleVZhbHVlRGlmZmVycywgSXRlcmFibGVEaWZmZXJzLCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ2hhbmdlRGV0ZWN0b3JSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElnR3JpZEJhc2UgfSBmcm9tICcuL2lnZ3JpZGJhc2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICBcInNlbGVjdG9yXCI6IFwiaWctZ3JpZFwiLFxuICAgIHRlbXBsYXRlOiBcIjxuZy1jb250ZW50PjwvbmctY29udGVudD5cIixcbiAgICBpbnB1dHM6IFtcIndpZGdldElkXCIsIFwib3B0aW9uc1wiLCBcImNoYW5nZURldGVjdGlvbkludGVydmFsXCIsIFwiZGlzYWJsZWRcIiwgXCJjcmVhdGVcIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiLCBcImF1dG9BZGp1c3RIZWlnaHRcIiwgXCJhdmdSb3dIZWlnaHRcIiwgXCJhdmdDb2x1bW5XaWR0aFwiLCBcImRlZmF1bHRDb2x1bW5XaWR0aFwiLCBcImF1dG9HZW5lcmF0ZUNvbHVtbnNcIiwgXCJ2aXJ0dWFsaXphdGlvblwiLCBcInZpcnR1YWxpemF0aW9uTW9kZVwiLCBcInJlcXVpcmVzRGF0YUJpbmRpbmdcIiwgXCJyb3dWaXJ0dWFsaXphdGlvblwiLCBcImNvbHVtblZpcnR1YWxpemF0aW9uXCIsIFwidmlydHVhbGl6YXRpb25Nb3VzZVdoZWVsU3RlcFwiLCBcImFkanVzdFZpcnR1YWxIZWlnaHRzXCIsIFwidGVtcGxhdGluZ0VuZ2luZVwiLCBcImNvbHVtbnNcIiwgXCJkYXRhU291cmNlXCIsIFwiZGF0YVNvdXJjZVVybFwiLCBcImRhdGFTb3VyY2VUeXBlXCIsIFwicmVzcG9uc2VEYXRhS2V5XCIsIFwicmVzcG9uc2VUb3RhbFJlY0NvdW50S2V5XCIsIFwicmVxdWVzdFR5cGVcIiwgXCJyZXNwb25zZUNvbnRlbnRUeXBlXCIsIFwic2hvd0hlYWRlclwiLCBcInNob3dGb290ZXJcIiwgXCJmaXhlZEhlYWRlcnNcIiwgXCJmaXhlZEZvb3RlcnNcIiwgXCJjYXB0aW9uXCIsIFwiZmVhdHVyZXNcIiwgXCJ0YWJJbmRleFwiLCBcImxvY2FsU2NoZW1hVHJhbnNmb3JtXCIsIFwicHJpbWFyeUtleVwiLCBcInNlcmlhbGl6ZVRyYW5zYWN0aW9uTG9nXCIsIFwiYXV0b0NvbW1pdFwiLCBcImFnZ3JlZ2F0ZVRyYW5zYWN0aW9uc1wiLCBcImF1dG9Gb3JtYXRcIiwgXCJyZW5kZXJDaGVja2JveGVzXCIsIFwidXBkYXRlVXJsXCIsIFwicmVzdFNldHRpbmdzXCIsIFwiYWx0ZXJuYXRlUm93U3R5bGVzXCIsIFwiYXV0b2ZpdExhc3RDb2x1bW5cIiwgXCJlbmFibGVIb3ZlclN0eWxlc1wiLCBcImVuYWJsZVVUQ0RhdGVzXCIsIFwibWVyZ2VVbmJvdW5kQ29sdW1uc1wiLCBcImpzb25wUmVxdWVzdFwiLCBcImVuYWJsZVJlc2l6ZUNvbnRhaW5lckNoZWNrXCIsIFwiZmVhdHVyZUNob29zZXJJY29uRGlzcGxheVwiLCBcInNjcm9sbFNldHRpbmdzXCJdLFxuICAgIG91dHB1dHM6IFtcImNlbGxDbGlja1wiLCBcImNlbGxSaWdodENsaWNrXCIsIFwiZGF0YUJpbmRpbmdcIiwgXCJkYXRhQm91bmRcIiwgXCJyZW5kZXJpbmdcIiwgXCJyZW5kZXJlZFwiLCBcImRhdGFSZW5kZXJpbmdcIiwgXCJkYXRhUmVuZGVyZWRcIiwgXCJoZWFkZXJSZW5kZXJpbmdcIiwgXCJoZWFkZXJSZW5kZXJlZFwiLCBcImZvb3RlclJlbmRlcmluZ1wiLCBcImZvb3RlclJlbmRlcmVkXCIsIFwiaGVhZGVyQ2VsbFJlbmRlcmVkXCIsIFwicm93c1JlbmRlcmluZ1wiLCBcInJvd3NSZW5kZXJlZFwiLCBcInNjaGVtYUdlbmVyYXRlZFwiLCBcImNvbHVtbnNDb2xsZWN0aW9uTW9kaWZpZWRcIiwgXCJyZXF1ZXN0RXJyb3JcIiwgXCJjcmVhdGVkXCIsIFwiZGVzdHJveWVkXCJdXG59KVxuZXhwb3J0IGNsYXNzIElnR3JpZENvbXBvbmVudCBleHRlbmRzIElnR3JpZEJhc2U8SWdHcmlkPiB7XG4gICAgY29uc3RydWN0b3IoZWw6IEVsZW1lbnRSZWYsIHJlbmRlcmVyOiBSZW5kZXJlciwgZGlmZmVyczogSXRlcmFibGVEaWZmZXJzLCBrdmFsRGlmZjogS2V5VmFsdWVEaWZmZXJzLCBjZHI6IENoYW5nZURldGVjdG9yUmVmKSB7IHN1cGVyKGVsLCByZW5kZXJlciwgZGlmZmVycywga3ZhbERpZmYsIGNkcik7IH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGVsZW1lbnQgaG9sZGluZyB0aGUgZGF0YSByZWNvcmRzXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgd2lkZ2V0KCk6IHZvaWQgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgZ3JpZCBoYXMgbm9uLWRhdGEgZml4ZWQgY29sdW1ucyhlLmcuIHJvdyBzZWxlY3RvcnMgY29sdW1uKVxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGhhc0ZpeGVkRGF0YVNraXBwZWRDb2x1bW5zKCk6IGJvb2xlYW4geyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgZ3JpZCBoYXMgYXQgbGVhc3Qgb25lIGZpeGVkIGNvbHVtbnMoZXZlbiBpZiBhIG5vbi1kYXRhIGNvbHVtbiAtIGxpa2Ugcm93LXNlbGVjdG9ycyBjb2x1bW4pXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgaGFzRml4ZWRDb2x1bW5zKCk6IGJvb2xlYW4geyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGZpeGluZyBkaXJlY3Rpb24uIE5PVEUgLSB1c2Ugb25seSBpZiBDb2x1bW5GaXhpbmcgZmVhdHVyZSBpcyBlbmFibGVkXG4gICAgICogQHJldHVybiBsZWZ0fHJpZ2h0ICAgICBcbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBmaXhpbmdEaXJlY3Rpb24oKTogc3RyaW5nIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBjb2x1bW4gd2l0aCBpZGVudGlmaWVyIGNvbEtleSBpcyBmaXhlZFxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbEtleSAgICAgQW4gaWRlbnRpZmllciBvZiB0aGUgY29sdW1uIHdoaWNoIHNob3VsZCBiZSBjaGVja2VkLiBJdCBjYW4gYmUgYSBrZXkgb3IgdmlzaWJsZSBpbmRleC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBpc0ZpeGVkQ29sdW1uKGNvbEtleTogT2JqZWN0KTogYm9vbGVhbiB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB0byBkZXRlY3Qgd2hldGhlciBncmlkIGNvbnRhaW5lciBpcyByZXNpemVkLiBXaGVuIGF1dG9BZGp1c3RIZWlnaHQgaXMgdHJ1ZSBhbmQgaGVpZ2h0IG9mIHRoZSBncmlkIGlzIGNoYW5nZWQgdGhlbiB0aGUgaGVpZ2h0IG9mIGdyaWQgaXMgcmUtc2V0LlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIHJlc2l6ZUNvbnRhaW5lcigpOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBoZWFkZXIgaWRlbnRpZmllZCBieSBjb2xLZXkgaXMgbXVsdGljb2x1bW4gaGVhZGVyKGhhcyBjaGlsZHJlbilcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2xLZXkgICAgIHZhbHVlIG9mIHRoZSBjb2x1bW4ga2V5XG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgaXNHcm91cEhlYWRlcihjb2xLZXk6IHN0cmluZyk6IE9iamVjdCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgaW5mb3JtYXRpb24gb24gdGhlIHBhc3NlZCBEb20gZWxlbWVudFxuICAgICAqIFx0XHRcbiAgICAgKiBcdFx0XHRcdHJvd0lkIC0gdGhlIGlkIG9mIHRoZSByZWNvcmQgYXNzb2NpYXRlZCB3aXRoIHRoZSBlbGVtZW50IC0gaWYgcHJpbWFyeUtleSBpcyBub3Qgc2V0IHRoaXMgd2lsbCBiZSBudWxsLlxuICAgICAqIFx0XHRcdFx0cm93SW5kZXggLSB0aGUgaW5kZXggKGluIHRoZSBET00pIG9mIHRoZSByb3cgYXNzb2NpYXRlZCB3aXRoIHRoZSBlbGVtZW50LlxuICAgICAqIFx0XHRcdFx0cmVjb3JkSW5kZXggLSBpbmRleCBvZiB0aGUgZGF0YSByZWNvcmQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZWxlbWVudCBpbiB0aGUgY3VycmVudCBkYXRhVmlldy5cbiAgICAgKiBcdFx0XHRcdGNvbHVtbk9iamVjdCAgLSB0aGUgY29sdW1uIG9iamVjdCBhc3NvY2lhdGVkIHdpdGggdGhpcyBlbGVtZW50ICggaWYgdGhlIGVsZW1lbnQgaXMgdHIgdGhpcyB3aWxsIGJlIG51bGwpXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbSAgICBUaGUgRG9tIGVsZW1lbnQgb3IgalF1ZXJ5IG9iamVjdCB3aGljaCBjYW4gYmUgYSBURCBvciBUUiBlbGVtZW50IGZyb20gdGhlIGdyaWQuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgZ2V0RWxlbWVudEluZm8oZWxlbTogRWxlbWVudCk6IE9iamVjdCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIElEIG9mIHRoZSBUQUJMRSBlbGVtZW50IHdoZXJlIGRhdGEgcmVjb3JkcyBhcmUgcmVuZGVyZWRcbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBpZCgpOiBzdHJpbmcgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBESVYgdGhhdCBpcyB0aGUgdG9wbW9zdCBjb250YWluZXIgb2YgdGhlIGdyaWQgd2lkZ2V0XG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgY29udGFpbmVyKCk6IEVsZW1lbnQgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0YWJsZSB0aGF0IGNvbnRhaW5zIHRoZSBoZWFkZXIgY2VsbHNcbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBoZWFkZXJzVGFibGUoKTogRWxlbWVudCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRhYmxlIHRoYXQgY29udGFpbnMgdGhlIGZvb3RlciBjZWxsc1xuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGZvb3RlcnNUYWJsZSgpOiBFbGVtZW50IHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgRElWIHRoYXQgaXMgdXNlZCBhcyBhIHNjcm9sbCBjb250YWluZXIgZm9yIHRoZSBncmlkIGNvbnRlbnRzXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgc2Nyb2xsQ29udGFpbmVyKCk6IEVsZW1lbnQgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBESVYgdGhhdCBpcyB0aGUgdG9wbW9zdCBjb250YWluZXIgb2YgdGhlIGZpeGVkIGdyaWQgLSBjb250YWlucyBmaXhlZCBjb2x1bW5zKGluIENvbHVtbkZpeGluZyBzY2VuYXJpbylcbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBmaXhlZENvbnRhaW5lcigpOiBFbGVtZW50IHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgRElWIHRoYXQgaXMgdGhlIHRvcG1vc3QgY29udGFpbmVyIG9mIHRoZSBmaXhlZCBib2R5IGdyaWQgLSBjb250YWlucyBmaXhlZCBjb2x1bW5zKGluIENvbHVtbkZpeGluZyBzY2VuYXJpbylcbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBmaXhlZEJvZHlDb250YWluZXIoKTogRWxlbWVudCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29udGFpbmVyKGpRdWVyeSByZXByZXNlbnRhdGlvbikgY29udGFpbmluZyBmaXhlZCBmb290ZXIgLSBjb250YWlucyBmaXhlZCBjb2x1bW5zKGluIENvbHVtbkZpeGluZyBzY2VuYXJpbylcbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBmaXhlZEZvb3RlckNvbnRhaW5lcigpOiBPYmplY3QgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbnRhaW5lcihqUXVlcnkgcmVwcmVzZW50YXRpb24pIGNvbnRhaW5pbmcgZml4ZWQgaGVhZGVyIC0gY29udGFpbnMgZml4ZWQgY29sdW1ucyhpbiBDb2x1bW5GaXhpbmcgc2NlbmFyaW8pXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgZml4ZWRIZWFkZXJDb250YWluZXIoKTogT2JqZWN0IHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdGFibGUgdGhhdCBjb250YWlucyB0aGUgRklYRUQgaGVhZGVyIGNlbGxzIC0gY29udGFpbnMgZml4ZWQgY29sdW1ucyhpbiBDb2x1bW5GaXhpbmcgc2NlbmFyaW8pXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgZml4ZWRIZWFkZXJzVGFibGUoKTogRWxlbWVudCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRhYmxlIHRoYXQgY29udGFpbnMgdGhlIGZvb3RlciBjZWxscyAtIGNvbnRhaW5zIGZpeGVkIGNvbHVtbnMoaW4gQ29sdW1uRml4aW5nIHNjZW5hcmlvKVxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGZpeGVkRm9vdGVyc1RhYmxlKCk6IEVsZW1lbnQgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjZWxsIFREIGVsZW1lbnQgYXQgdGhlIHNwZWNpZmllZCBsb2NhdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHggICAgIFRoZSBjb2x1bW4gaW5kZXguXG4gICAgICogQHBhcmFtIHkgICAgIFRoZSByb3cgaW5kZXguXG4gICAgICogQHBhcmFtIGlzRml4ZWQgICAgIE9wdGlvbmFsIHBhcmFtZXRlciAtIGlmIHRydWUgZ2V0IGNlbGwgVEQgYXQgdGhlIHNwZWNpZmllZCBsb2NhdGlvbiBmcm9tIHRoZSBmaXhlZCB0YWJsZVxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGNlbGxBdCh4OiBudW1iZXIsIHk6IG51bWJlciwgaXNGaXhlZDogYm9vbGVhbik6IEVsZW1lbnQgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjZWxsIFREIGVsZW1lbnQgYnkgcm93IGlkIGFuZCBjb2x1bW4ga2V5XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm93SWQgICAgIFRoZSBpZCBvZiB0aGUgcm93LlxuICAgICAqIEBwYXJhbSBjb2x1bW5LZXkgICAgIFRoZSBjb2x1bW4ga2V5LlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGNlbGxCeUlkKHJvd0lkOiBPYmplY3QsIGNvbHVtbktleTogc3RyaW5nKTogRWxlbWVudCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpeGVkIHRhYmxlIC0gY29udGFpbnMgZml4ZWQgY29sdW1ucyhpbiBDb2x1bW5GaXhpbmcgc2NlbmFyaW8pLiBJZiB0aGVyZSBhcmVuJ3QgZml4ZWQgY29sdW1ucyByZXR1cm5zIHRoZSBncmlkIHRhYmxlXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgZml4ZWRUYWJsZSgpOiBPYmplY3QgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBpbW1lZGlhdGUgY2hpbGRyZW4gb2YgdGhlIGN1cnJlbnQgZ3JpZFxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGltbWVkaWF0ZUNoaWxkcmVuV2lkZ2V0cygpOiBhbnlbXSB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGNoaWxkcmVuIG9mIHRoZSBjdXJyZW50IGdyaWQsIHJlY3Vyc2l2ZWx5XG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgY2hpbGRyZW5XaWRnZXRzKCk6IGFueVtdIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgY2hpbGRyZW4ncyBlbGVtZW50cyBvZiB0aGUgY3VycmVudCBncmlkLCByZWN1cnNpdmVseVxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGNoaWxkcmVuKCk6IGFueVtdIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgaW1tZWRpYXRlIGNoaWxkcmVuJ3MgZWxlbWVudHMgb2YgdGhlIGN1cnJlbnQgZ3JpZFxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGltbWVkaWF0ZUNoaWxkcmVuKCk6IGFueVtdIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcm93IChUUiBlbGVtZW50KSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LiBqUXVlcnkgc2VsZWN0b3JzIGFyZW4ndCB1c2VkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaSAgICAgVGhlIHJvdyBpbmRleC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyByb3dBdChpOiBudW1iZXIpOiBFbGVtZW50IHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcm93IFRSIGVsZW1lbnQgYnkgcm93IGlkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm93SWQgICAgIFRoZSBpZCBvZiB0aGUgcm93LlxuICAgICAqIEBwYXJhbSBpc0ZpeGVkICAgICBTcGVjaWZ5IHNlYXJjaCBpbiB0aGUgZml4ZWQgY29udGFpbmVyLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIHJvd0J5SWQocm93SWQ6IE9iamVjdCwgaXNGaXhlZD86IGJvb2xlYW4pOiBFbGVtZW50IHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZml4ZWQgcm93IChUUiBlbGVtZW50KSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LiBqUXVlcnkgc2VsZWN0b3JzIGFyZW4ndCB1c2VkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zKGluIENvbHVtbkZpeGluZyBzY2VuYXJpbyAtIG9ubHkgd2hlbiB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgZml4ZWQgY29sdW1uKVxuICAgICAqXG4gICAgICogQHBhcmFtIGkgICAgIFRoZSByb3cgaW5kZXguXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgZml4ZWRSb3dBdChpOiBudW1iZXIpOiBFbGVtZW50IHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgYWxsIGZpeGVkIFRSIGVsZW1lbnRzIGhvbGRpbmcgZGF0YSBpbiB0aGUgZ3JpZChpbiBDb2x1bW5GaXhpbmcgc2NlbmFyaW8gLSBvbmx5IHdoZW4gdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGZpeGVkIGNvbHVtbilcbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBmaXhlZFJvd3MoKTogYW55W10geyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwgVFIgZWxlbWVudHMgaG9sZGluZyBkYXRhIGluIHRoZSBncmlkKHdoZW4gdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGZpeGVkIGNvbHVtbiByZXR1cm5zIHJvd3Mgb25seSBpbiB0aGUgVU5GSVhFRCB0YWJsZSlcbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyByb3dzKCk6IGFueVtdIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgZGF0YSBmaXhlZCByb3dzIHJlY3Vyc2l2ZWx5LCBub3Qgb25seSB0aGUgaW1tZWRpYXRlIG9uZXMoaW4gQ29sdW1uRml4aW5nIHNjZW5hcmlvIC0gb25seSB3aGVuIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBmaXhlZCBjb2x1bW4pXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgYWxsRml4ZWRSb3dzKCk6IGFueVtdIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgZGF0YSByb3dzIHJlY3Vyc2l2ZWx5LCBub3Qgb25seSB0aGUgaW1tZWRpYXRlIG9uZXMod2hlbiB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgZml4ZWQgY29sdW1uIHJldHVybnMgcm93cyBvbmx5IGluIHRoZSBVTkZJWEVEIHRhYmxlKVxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGFsbFJvd3MoKTogYW55W10geyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29sdW1uIG9iamVjdCBieSB0aGUgc3BlY2lmaWVkIGNvbHVtbiBrZXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgICAgIFRoZSBjb2x1bW4ga2V5LlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGNvbHVtbkJ5S2V5KGtleTogc3RyaW5nKTogT2JqZWN0IHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvbHVtbiBvYmplY3QgYnkgdGhlIHNwZWNpZmllZCBoZWFkZXIgdGV4dC4gSWYgdGhlcmUgYXJlIG11bHRpcGxlIG1hdGNoZXMsIHJldHVybnMgdGhlIGZpcnN0IG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0ZXh0ICAgICBUaGUgY29sdW1uIGhlYWRlciB0ZXh0LlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGNvbHVtbkJ5VGV4dCh0ZXh0OiBzdHJpbmcpOiBPYmplY3QgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHNlbGVjdGVkIGNlbGxzIGluIGFyYml0cmFyeSBvcmRlciB3aGVyZSBldmVyeSBvYmplY3RzIGhhcyB0aGUgZm9ybWF0IHsgZWxlbWVudDogLCByb3c6ICwgaW5kZXg6ICwgcm93SW5kZXg6ICwgY29sdW1uS2V5OiB9IC5cbiAgICAgKiBcdFx0XHRcdElmIG11bHRpcGxlIHNlbGVjdGlvbiBpcyBkaXNhYmxlZCB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gbnVsbC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBzZWxlY3RlZENlbGxzKCk6IGFueVtdIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBzZWxlY3RlZCByb3dzIGluIGFyYml0cmFyeSBvcmRlciB3aGVyZSBldmVyeSBvYmplY3QgaGFzIHRoZSBmb3JtYXQgeyBlbGVtZW50OiAsIGluZGV4OiB9IC5cbiAgICAgKiBcdFx0XHRcdElmIG11bHRpcGxlIHNlbGVjdGlvbiBpcyBkaXNhYmxlZCB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gbnVsbC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBzZWxlY3RlZFJvd3MoKTogYW55W10geyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgY2VsbCB0aGF0IGhhcyB0aGUgZm9ybWF0IHsgZWxlbWVudDogLCByb3c6ICwgaW5kZXg6ICwgcm93SW5kZXg6ICwgY29sdW1uS2V5OiB9LCBpZiBhbnkuXG4gICAgICogXHRcdFx0XHRJZiBtdWx0aXBsZSBzZWxlY3Rpb24gaXMgZW5hYmxlZCB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gbnVsbC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBzZWxlY3RlZENlbGwoKTogT2JqZWN0IHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHJvdyB0aGF0IGhhcyB0aGUgZm9ybWF0IHsgZWxlbWVudDogLCBpbmRleDogfSwgaWYgYW55LlxuICAgICAqIFx0XHRcdFx0SWYgbXVsdGlwbGUgc2VsZWN0aW9uIGlzIGVuYWJsZWQgdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIG51bGwuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgc2VsZWN0ZWRSb3coKTogT2JqZWN0IHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudGx5IGFjdGl2ZSAoZm9jdXNlZCkgY2VsbCB0aGF0IGhhcyB0aGUgZm9ybWF0IHsgZWxlbWVudDogLCByb3c6ICwgaW5kZXg6ICwgcm93SW5kZXg6ICwgY29sdW1uS2V5OiB9LCBpZiBhbnkuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgYWN0aXZlQ2VsbCgpOiBPYmplY3QgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50bHkgYWN0aXZlIChmb2N1c2VkKSByb3cgdGhhdCBoYXMgdGhlIGZvcm1hdCB7IGVsZW1lbnQ6ICwgaW5kZXg6IH0sIGlmIGFueS5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBhY3RpdmVSb3coKTogT2JqZWN0IHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgY2VsbCB2YWx1ZSB1c2luZyB0aGUgcm93IGluZGV4IGFuZCB0aGUgY29sdW1uIGtleS4gSWYgYSBwcmltYXJ5S2V5IGlzIGRlZmluZWQsIHJvd0lkIGlzIGFzc3VtZWQgdG8gYmUgdGhlIHJvdyBLZXkgKG5vdCBpbmRleCkuXG4gICAgICogXHRcdFx0XHRJZiBwcmltYXJ5IGtleSBpcyBub3QgZGVmaW5lZCwgdGhlbiByb3dJZCBpcyBjb252ZXJ0ZWQgdG8gYSBudW1iZXIgYW5kIGlzIHVzZWQgYXMgYSByb3cgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm93SWQgICAgIFJvdyBpbmRleCBvciByb3cga2V5IChwcmltYXJ5IGtleSkuXG4gICAgICogQHBhcmFtIGNvbEtleSAgICAgVGhlIGNvbHVtbiBrZXkuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgZ2V0Q2VsbFZhbHVlKHJvd0lkOiBPYmplY3QsIGNvbEtleTogc3RyaW5nKTogT2JqZWN0IHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY2VsbCB0ZXh0LiBJZiBjb2xLZXkgaXMgYSBudW1iZXIsIHRoZSBpbmRleCBvZiB0aGUgY29sdW1uIGlzIHVzZWQgKGluc3RlYWQgb2YgYSBjb2x1bW4gbmFtZSktIGRvZXMgbm90IGFwcGx5IHdoZW4gdXNpbmcgYSBNdWx0aS1Sb3cgTGF5b3V0IGdyaWQuXG4gICAgICogXHRcdFx0XHRUaGlzIGlzIHRoZSBhY3R1YWwgdGV4dCAob3IgSFRNTCBzdHJpbmcpIGZvciB0aGUgY29udGVudHMgb2YgdGhlIGNlbGwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm93SWQgICAgIFJvdyBpbmRleCBvciByb3cgZGF0YSBrZXkgKHByaW1hcnkga2V5KVxuICAgICAqIEBwYXJhbSBjb2xLZXkgICAgIENvbHVtbiBrZXkuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgZ2V0Q2VsbFRleHQocm93SWQ6IE9iamVjdCwgY29sS2V5OiBzdHJpbmcpOiBzdHJpbmcgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbmV3IHRlbXBsYXRlIGZvciBhIGNvbHVtbiBhZnRlciBpbml0aWFsaXphdGlvbiBhbmQgcmVuZGVycyB0aGUgZ3JpZCBpZiBub3QgZXhwbGljaXRseSBkaXNhYmxlZC4gVGhpcyBtZXRob2Qgd2lsbCByZXBsYWNlIGFueSBleGlzdGluZyBleHBsaWNpdGx5IHNldCByb3cgdGVtcGxhdGUgYW5kIHdpbGwgYnVpbGQgb25lIGFuZXcgZnJvbSB0aGUgY29sdW1uIG9uZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sICAgICBBbiBpZGVudGlmaWVyIG9mIHRoZSBjb2x1bW4gdG8gc2V0IHRlbXBsYXRlIGZvciAoaW5kZXggb3Iga2V5KVxuICAgICAqIEBwYXJhbSB0bXBsICAgICBUaGUgY29sdW1uIHRlbXBsYXRlIHRvIHNldFxuICAgICAqIEBwYXJhbSByZW5kZXIgICAgIFNob3VsZCB0aGUgZ3JpZCByZXJlbmRlciBhZnRlciB0ZW1wbGF0ZSBpcyBzZXRcbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBzZXRDb2x1bW5UZW1wbGF0ZShjb2w6IE9iamVjdCwgdG1wbDogc3RyaW5nLCByZW5kZXI/OiBib29sZWFuKTogdm9pZCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIENvbW1pdHMgYWxsIHBlbmRpbmcgdHJhbnNhY3Rpb25zIHRvIHRoZSBjbGllbnQgZGF0YSBzb3VyY2UuIE5vdGUgdGhhdCB0aGVyZSB3b24ndCBiZSBhbnl0aGluZyB0byBjb21taXQgb24gdGhlIFVJLCBzaW5jZSBpdCBpcyB1cGRhdGVkIGluc3RhbnRseS4gSW4gb3JkZXIgdG8gcm9sbGJhY2sgdGhlIGFjdHVhbCBVSSwgYSBjYWxsIHRvIGRhdGFCaW5kKCkgaXMgcmVxdWlyZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm93SWQgICAgIElmIHNwZWNpZmllZCwgd2lsbCBjb21taXQgb25seSB0aGF0IHRyYW5zYWN0aW9uIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHNwZWNpZmllZCByZWNvcmQga2V5LlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGNvbW1pdChyb3dJZD86IE9iamVjdCk6IHZvaWQgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIHRyYW5zYWN0aW9uIGxvZyAoZGVsZWdhdGVzIHRvIGlnRGF0YVNvdXJjZSkuIE5vdGUgdGhhdCB0aGlzIGRvZXMgbm90IHVwZGF0ZSB0aGUgVUkuIEluIGNhc2UgdGhlIFVJIG11c3QgYmUgdXBkYXRlZCwgc2V0IHRoZSBzZWNvbmQgcGFyYW1ldGVyIFwidXBkYXRlVUlcIiB0byB0cnVlLCB3aGljaCB3aWxsIHRyaWdnZXIgYSBjYWxsIHRvIGRhdGFCaW5kKCkgdG8gcmUtcmVuZGVyIHRoZSBjb250ZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByb3dJZCAgICAgSWYgc3BlY2lmaWVkLCB3aWxsIG9ubHkgcm9sbGJhY2sgdGhlIHRyYW5zYWN0aW9ucyB3aXRoIHRoYXQgcm93IGlkLlxuICAgICAqIEBwYXJhbSB1cGRhdGVVSSAgICAgV2hldGhlciB0byB1cGRhdGUgdGhlIFVJIG9yIG5vdC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyByb2xsYmFjayhyb3dJZD86IE9iamVjdCwgdXBkYXRlVUk/OiBib29sZWFuKTogYW55W10geyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVjb3JkIGJ5IGEgc3BlY2lmaWVkIGtleSAocmVxdWlyZXMgdGhhdCBwcmltYXJ5S2V5IGlzIHNldCBpbiB0aGUgc2V0dGluZ3MpLlxuICAgICAqIFx0XHRcdFx0VGhhdCBpcyBhIHdyYXBwZXIgZm9yIHRoaXMuZGF0YVNvdXJjZS5maW5kUmVjb3JkQnlLZXkoa2V5KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgICAgIFByaW1hcnkga2V5IG9mIHRoZSByZWNvcmRcbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBmaW5kUmVjb3JkQnlLZXkoa2V5OiBPYmplY3QpOiBPYmplY3QgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RhbmRhbG9uZSBvYmplY3QgKGNvcHkpIHRoYXQgcmVwcmVzZW50cyB0aGUgY29tbWl0dGVkIHRyYW5zYWN0aW9ucywgYnV0IGRldGFjaGVkIGZyb20gdGhlIGRhdGEgc291cmNlLlxuICAgICAqIFx0XHRcdFx0VGhhdCBpcyBhIHdyYXBwZXIgZm9yIHRoaXMuZGF0YVNvdXJjZS5nZXREZXRhY2hlZFJlY29yZCh0KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0ICAgICBBIHRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBnZXREZXRhY2hlZFJlY29yZCh0OiBPYmplY3QpOiBPYmplY3QgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwgdHJhbnNhY3Rpb24gb2JqZWN0cyB0aGF0IGFyZSBwZW5kaW5nIHRvIGJlIGNvbW1pdHRlZCBvciByb2xsZWQgYmFjayB0byB0aGUgZGF0YSBzb3VyY2UuXG4gICAgICogXHRcdFx0XHRUaGF0IGlzIGEgd3JhcHBlciBmb3IgdGhpcy5kYXRhU291cmNlLnBlbmRpbmdUcmFuc2FjdGlvbnMoKS5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBwZW5kaW5nVHJhbnNhY3Rpb25zKCk6IGFueVtdIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgYWxsIHRyYW5zYWN0aW9uIG9iamVjdHMgdGhhdCBhcmUgZWl0aGVyIHBlbmRpbmcsIG9yIGhhdmUgYmVlbiBjb21taXR0ZWQgaW4gdGhlIGRhdGEgc291cmNlLlxuICAgICAqIFx0XHRcdFx0VGhhdCBpcyBhIHdyYXBwZXIgZm9yIHRoaXMuZGF0YVNvdXJjZS5hbGxUcmFuc2FjdGlvbnMoKS5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBhbGxUcmFuc2FjdGlvbnMoKTogYW55W10geyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB0cmFuc2FjdGlvbiBsb2cgYXMgYSBzdHJpbmcuIFRoZSBwdXJwb3NlIG9mIHRoaXMgaXMgdG8gYmUgcGFzc2VkIHRvIFVSTHMgb3IgdXNlZCBjb252ZW5pZW50bHkuXG4gICAgICogXHRcdFx0XHRUaGF0IGlzIGEgd3JhcHBlciBmb3IgdGhpcy5kYXRhU291cmNlLnRyYW5zYWN0aW9uc0FzU3RyaW5nKCkuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgdHJhbnNhY3Rpb25zQXNTdHJpbmcoKTogc3RyaW5nIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyBhbiBBSkFYIHJlcXVlc3QgdG8gdGhlIHVwZGF0ZVVybCBvcHRpb24gKGlmIHNwZWNpZmllZCkgYW5kIHBhc3NlcyB0aGUgc2VyaWFsaXplZCB0cmFuc2FjdGlvbiBsb2cgKGEgc2VyaWFsaXplZCBKU09OIHN0cmluZykgYXMgcGFydCBvZiB0aGUgUE9TVCByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHN1Y2Nlc3MgICAgU3BlY2lmaWVzIGEgY3VzdG9tIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIEFKQVggcmVxdWVzdCB0byB0aGUgdXBkYXRlVXJsIG9wdGlvbiBzdWNjZWVkcyhvcHRpb25hbClcbiAgICAgKiBAcGFyYW0gZXJyb3IgICAgU3BlY2lmaWVzIGEgY3VzdG9tIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIEFKQVggcmVxdWVzdCB0byB0aGUgdXBkYXRlVXJsIG9wdGlvbiBmYWlscyhvcHRpb25hbClcbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBzYXZlQ2hhbmdlcyhzdWNjZXNzOiBGdW5jdGlvbiwgZXJyb3I6IEZ1bmN0aW9uKTogdm9pZCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgcm93IChUUikgdG8gdGhlIGdyaWQsIGJ5IHRha2luZyBhIGRhdGEgcm93IG9iamVjdC4gQXNzdW1lcyB0aGUgcmVjb3JkIHdpbGwgaGF2ZSB0aGUgcHJpbWFyeSBrZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVjICAgICBJZGVudGlmaWVyL2tleSBvZiByb3cuIElmIG1pc3NpbmcsIHRoZW4gbnVtYmVyIG9mIHJvd3MgaW4gZ3JpZCBpcyB1c2VkLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIHJlbmRlck5ld1JvdyhyZWM/OiBzdHJpbmcpOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIGRhdGEgc291cmNlIHBvaW50cyB0byBhIGxvY2FsIEpTT04gYXJyYXkgb2YgZGF0YSwgYW5kIGl0IGlzIG5lY2Vzc2FyeSB0byByZXNldCBpdCBhdCBydW50aW1lLCBpdCBtdXN0IGJlIGRvbmUgdGhyb3VnaCB0aGlzIEFQSSBtZW1iZXIgaW5zdGVhZCBvZiB0aGUgb3B0aW9ucyAob3B0aW9ucy5kYXRhU291cmNlKVxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGFTb3VyY2UgICAgIE5ldyBkYXRhIHNvdXJjZSBvYmplY3QuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgZGF0YVNvdXJjZU9iamVjdChkYXRhU291cmNlOiBPYmplY3QpOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdG90YWwgbnVtYmVyIG9mIHJlY29yZHMgaW4gdGhlIHVuZGVybHlpbmcgYmFja2VuZC4gSWYgcGFnaW5nIG9yIGZpbHRlcmluZyBpcyBlbmFibGVkLCB0aGlzIG1heSBkaWZmZXIgZnJvbSB0aGUgbnVtYmVyIG9mIHJlY29yZHMgaW4gdGhlIGNsaWVudC1zaWRlIGRhdGEgc291cmNlLlxuICAgICAqIFx0XHRcdFx0SW4gb3JkZXIgZm9yIHRoaXMgdG8gd29yaywgdGhlIHJlc3BvbnNlIEpTT04vWE1MIG11c3QgaW5jbHVkZSBhIHByb3BlcnR5IHRoYXQgc3BlY2lmaWVzIHRoZSB0b3RhbCBudW1iZXIgb2YgcmVjb3Jkcywgd2hpY2ggbmFtZSBpcyBzcGVjaWZpZWQgYnkgb3B0aW9ucy5yZXNwb25zZVRvdGFsUmVjQ291bnRLZXkuXG4gICAgICogXHRcdFx0XHRUaGlzIGZ1bmN0aW9uYWxpdHkgaXMgY29tcGxldGVseSBkZWxlZ2F0ZWQgdG8gdGhlIGRhdGEgc291cmNlIGNvbnRyb2wuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgdG90YWxSZWNvcmRzQ291bnQoKTogbnVtYmVyIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogQ2F1c2VzIHRoZSBncmlkIHRvIGRhdGEgYmluZCB0byB0aGUgZGF0YSBzb3VyY2UgKGxvY2FsIG9yIHJlbW90ZSkgLCBhbmQgcmUtcmVuZGVyIGFsbCBvZiB0aGUgZGF0YSBhcyB3ZWxsXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW50ZXJuYWwgICAgXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBkYXRhQmluZChpbnRlcm5hbDogT2JqZWN0KTogdm9pZCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGEgdmlzaWJsZSBjb2x1bW4gYXQgYSBzcGVjaWZpZWQgcGxhY2UsIGluIGZyb250IG9yIGJlaGluZCBhIHRhcmdldCBjb2x1bW4gb3IgYXQgYSB0YXJnZXQgaW5kZXhcbiAgICAgKiBcdFx0XHROb3RlOiBUaGlzIG1ldGhvZCBpcyBhc3luY2hyb25vdXMgd2hpY2ggbWVhbnMgdGhhdCBpdCByZXR1cm5zIGltbWVkaWF0ZWx5IGFuZCBhbnkgc3Vic2VxdWVudCBjb2RlIHdpbGwgZXhlY3V0ZSBpbiBwYXJhbGxlbC4gVGhpcyBtYXkgbGVhZCB0byBydW50aW1lIGVycm9ycy4gVG8gYXZvaWQgdGhlbSBwdXQgdGhlIHN1YnNlcXVlbnQgY29kZSBpbiB0aGUgY2FsbGJhY2sgcGFyYW1ldGVyIHByb3ZpZGVkIGJ5IHRoZSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uICAgIEFuIGlkZW50aWZpZXIgb2YgdGhlIGNvbHVtbiB0byBiZSBtb3ZlZC4gSXQgY2FuIGJlIGEga2V5LCBhIE11bHRpLUNvbHVtbiBIZWFkZXIgaWRlbnRpZmljYXRvciwgb3IgYW4gaW5kZXggaW4gYSBudW1iZXIgZm9ybWF0LiBUaGUgbGF0dGVyIGlzIG5vdCBzdXBwb3J0ZWQgd2hlbiB0aGUgZ3JpZCBjb250YWlucyBtdWx0aS1jb2x1bW4gaGVhZGVycy5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0ICAgIEFuIGlkZW50aWZpZXIgb2YgYSBjb2x1bW4gd2hlcmUgdGhlIG1vdmVkIGNvbHVtbiBzaG91bGQgbW92ZSB0byBvciBhbiBpbmRleCBhdCB3aGljaCB0aGUgbW92ZWQgY29sdW1uIHNob3VsZCBiZSBtb3ZlZCB0by4gSW4gdGhlIGNhc2Ugb2YgYSBjb2x1bW4gaWRlbnRpZmllciB0aGUgY29sdW1uIHdpbGwgYmUgbW92ZWQgYWZ0ZXIgaXQgYnkgZGVmYXVsdC5cbiAgICAgKiBAcGFyYW0gYWZ0ZXIgICAgU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGNvbHVtbiBtb3ZlZCBzaG91bGQgYmUgbW92ZWQgYWZ0ZXIgb3IgYmVmb3JlIHRoZSB0YXJnZXQgY29sdW1uLiBUaGlzIHBhcmFtZXRlciBpcyBkaXNyZWdhcmRlZCBpZiB0aGVyZSBpcyBubyB0YXJnZXQgY29sdW1uIHNwZWNpZmllZCBidXQgYSB0YXJnZXQgaW5kZXggaXMgdXNlZC5cbiAgICAgKiBAcGFyYW0gaW5Eb20gICAgU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGNvbHVtbiBtb3Zpbmcgd2lsbCBiZSBlbmFjdGVkIHRocm91Z2ggRE9NIG1hbmlwdWxhdGlvbiBvciB0aHJvdWdoIHJlcmVuZGVyaW5nIG9mIHRoZSBncmlkLlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAgICBTcGVjaWZpZXMgYSBjdXN0b20gZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGNvbHVtbiBpcyBtb3ZlZC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBtb3ZlQ29sdW1uKGNvbHVtbjogT2JqZWN0LCB0YXJnZXQ6IE9iamVjdCwgYWZ0ZXI/OiBib29sZWFuLCBpbkRvbT86IGJvb2xlYW4sIGNhbGxiYWNrPzogRnVuY3Rpb24pOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogU2hvd3MgYSBoaWRkZW4gY29sdW1uLiBJZiB0aGUgY29sdW1uIGlzIG5vdCBoaWRkZW4gdGhlIG1ldGhvZCBkb2VzIG5vdGhpbmcuXG4gICAgICogXHRcdFx0XHROb3RlOiBUaGlzIG1ldGhvZCBpcyBhc3luY2hyb25vdXMgd2hpY2ggbWVhbnMgdGhhdCBpdCByZXR1cm5zIGltbWVkaWF0ZWx5IGFuZCBhbnkgc3Vic2VxdWVudCBjb2RlIHdpbGwgZXhlY3V0ZSBpbiBwYXJhbGxlbC4gVGhpcyBtYXkgbGVhZCB0byBydW50aW1lIGVycm9ycy4gVG8gYXZvaWQgdGhlbSBwdXQgdGhlIHN1YnNlcXVlbnQgY29kZSBpbiB0aGUgY2FsbGJhY2sgcGFyYW1ldGVyIHByb3ZpZGVkIGJ5IHRoZSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uICAgICBBbiBpZGVudGlmaWVyIGZvciB0aGUgY29sdW1uLiBJZiBhIG51bWJlciBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWQgYXMgYSBjb2x1bW4gaW5kZXguIElmIGEgc3RyaW5nIGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgdXNlZCBhcyBhIGNvbHVtbiBrZXkuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrICAgICBTcGVjaWZpZXMgYSBjdXN0b20gZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGNvbHVtbiBpcyBzaG93bihvcHRpb25hbClcbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBzaG93Q29sdW1uKGNvbHVtbjogT2JqZWN0LCBjYWxsYmFjazogRnVuY3Rpb24pOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogSGlkZXMgYSB2aXNpYmxlIGNvbHVtbi4gSWYgdGhlIGNvbHVtbiBpcyBoaWRkZW4gdGhlIG1ldGhvZCBkb2VzIG5vdGhpbmcuXG4gICAgICogXHRcdFx0XHROb3RlOiBUaGlzIG1ldGhvZCBpcyBhc3luY2hyb25vdXMgd2hpY2ggbWVhbnMgdGhhdCBpdCByZXR1cm5zIGltbWVkaWF0ZWx5IGFuZCBhbnkgc3Vic2VxdWVudCBjb2RlIHdpbGwgZXhlY3V0ZSBpbiBwYXJhbGxlbC4gVGhpcyBtYXkgbGVhZCB0byBydW50aW1lIGVycm9ycy4gVG8gYXZvaWQgdGhlbSBwdXQgdGhlIHN1YnNlcXVlbnQgY29kZSBpbiB0aGUgY2FsbGJhY2sgcGFyYW1ldGVyIHByb3ZpZGVkIGJ5IHRoZSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uICAgICBBbiBpZGVudGlmaWVyIGZvciB0aGUgY29sdW1uLiBJZiBhIG51bWJlciBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWQgYXMgYSBjb2x1bW4gaW5kZXggZWxzZSBpZiBhIHN0cmluZyBpcyBwcm92aWRlZCBpdCB3aWxsIGJlIHVzZWQgYXMgYSBjb2x1bW4ga2V5LlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAgICAgU3BlY2lmaWVzIGEgY3VzdG9tIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBjb2x1bW4gaXMgaGlkZGVuKG9wdGlvbmFsKVxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGhpZGVDb2x1bW4oY29sdW1uOiBPYmplY3QsIGNhbGxiYWNrOiBGdW5jdGlvbik6IHZvaWQgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHVuYm91bmQgdmFsdWVzIGZvciB0aGUgc3BlY2lmaWVkIGNvbHVtbiBrZXkuIElmIGtleSBpcyBub3Qgc3BlY2lmaWVkIHJldHVybnMgYWxsIHVuYm91bmR2YWx1ZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgICAgIGNvbHVtbiBrZXlcbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBnZXRVbmJvdW5kVmFsdWVzKGtleTogc3RyaW5nKTogT2JqZWN0IHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB1bmJvdW5kIHZhbHVlcyBmb3IgdGhlIHVuYm91bmQgY29sdW1uIHdpdGggdGhlIHNwZWNpZmllZCBrZXkuIElmIHJlbW92ZU9sZFZhbHVlcyBpcyB0cnVlIHRoZW4gdmFsdWVzKGlmIGFueSkgZm9yIHRoZSB1bmJvdW5kIGNvbHVtbnMgYXJlIHJlLXNldCB3aXRoIHRoZSBuZXcgdmFsdWVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5ICAgICBrZXkgb2YgdGhlIHVuYm91bmQgY29sdW1uXG4gICAgICogQHBhcmFtIHZhbHVlcyAgICAgYXJyYXkgb2YgdmFsdWVzIHRvIGJlIHNldCBvbiB1bmJvdW5kIHZhbHVlc1xuICAgICAqIEBwYXJhbSByZW1vdmVPbGRWYWx1ZXMgICAgIGlmIHRydWUgcmVtb3ZlcyBjdXJyZW50IHVuYm91bmQgdmFsdWVzKGlmIGFueSkgZm9yIHRoZSBzcGVjaWZpZWQgY29sdW1uIGFuZCBhcHBseSB0aGUgbmV3IG9uZXMgc3BlY2lmaWVkIGluIHBhcmFtZXRlciB2YWx1ZXMuIE90aGVyd2lzZSBtZXJnZSBjdXJyZW50IHZhbHVlcyB3aXRoIHRoZSBzcGVjaWZpZWQgaW4gcGFyYW1ldGVyIHZhbHVlc1xuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIHNldFVuYm91bmRWYWx1ZXMoa2V5OiBzdHJpbmcsIHZhbHVlczogYW55W10sIHJlbW92ZU9sZFZhbHVlczogT2JqZWN0KTogdm9pZCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdW5ib3VuZCB2YWx1ZSBmb3IgdGhlIHVuYm91bmQgY2VsbCBieSB0aGUgc3BlY2lmaWVkIGNvbHVtbiBrZXkgYW5kIHJvdyBwcmltYXJ5IGtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2wgICAgIGtleSBvZiB0aGUgdW5ib3VuZCBjb2x1bW5cbiAgICAgKiBAcGFyYW0gcm93SWQgICAgIHByaW1hcnkga2V5IHZhbHVlIG9mIHRoZSByb3dcbiAgICAgKiBAcGFyYW0gdmFsICAgICB2YWx1ZSB0byBiZSBzZXQgb24gdW5ib3VuZCBjZWxsXG4gICAgICogQHBhcmFtIG5vdFRvUmVuZGVyICAgICBpZiBmYWxzZSB3aWxsIHJlLXJlbmRlciB0aGUgcm93XG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgc2V0VW5ib3VuZFZhbHVlQnlQSyhjb2w6IHN0cmluZywgcm93SWQ6IHN0cmluZywgdmFsOiBPYmplY3QsIG5vdFRvUmVuZGVyOiBPYmplY3QpOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiB1bmJvdW5kIGNvbHVtbiB3aXRoIHRoZSBzcGVjaWZpZWQga2V5LiBJZiBub3QgZm91bmQgcmV0dXJucyBudWxsXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5ICAgIGEgY29sdW1uIGtleVxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGdldFVuYm91bmRDb2x1bW5CeUtleShrZXk6IHN0cmluZyk6IE9iamVjdCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGVyZSBpcyB2ZXJ0aWNhbCBzY3JvbGxiYXIuIEJlY2F1c2Ugb2YgcGVyZnJvcm1hbmNlIGlzc3VlcyBpbiBvbGRlciBJbnRlcm5ldCBFeHBsb3JlciBlc3BlY2lhbGx5IDgsOSAtIHRoZXJlIGlzIG5vIG5lZWQgdG8gY2hlY2sgaWYgaGVpZ2h0IGlzIG5vdCBzZXQgLSB0aGVyZSBpcyBubyBzY3JvbGxiYXIgT1IgaWYgcm93IHZpcnR1YWxpemF0aW9uIGlzIGVuYWJsZWQgLSBpdCBpcyBzdXBwb3NlZCB0aGVyZSBpcyB2ZXJ0aWNhbCBzY3JvbGxiYXJcbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBoYXNWZXJ0aWNhbFNjcm9sbGJhcigpOiBPYmplY3QgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBBdXRvIHJlc2l6ZSBjb2x1bW5zIHRoYXQgaGF2ZSBwcm9wZXJ0eSB3aWR0aCBzZXQgdG8gXCIqXCIgc28gY29udGVudCB0byBiZSBhdXRvLWZpdHRlZChub3Qgc2hyaW5rZWQvY3V0dGVkKS4gQXV0by1yZXNpemluZyBpcyBhcHBsaWVkIE9OTFkgZm9yIHZpc2libGUgY29sdW1uc1xuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGF1dG9TaXplQ29sdW1ucygpOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgd2lkdGggb2YgdGhlIGNvbHVtbiBzbyBpdHMgY29udGVudCB0byBiZSBhdXRvLWZpdHRlZCB0byB0aGUgd2lkdGggb2YgdGhlIGRhdGEgaW4gaXQodGhlIGNvbnRlbnQgc2hvdWxkIE5PVCBiZSBzaHJpbmtlZC9jdXR0ZWQpXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uSW5kZXggICAgVmlzaWJsZSBjb2x1bW4gaW5kZXhcbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBjYWxjdWxhdGVBdXRvRml0Q29sdW1uV2lkdGgoY29sdW1uSW5kZXg6IG51bWJlcik6IG51bWJlciB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCB2aXNpYmxlIGluZGV4IGJ5IHNwZWNpZmllZCBjb2x1bW4ga2V5LiBJZiBjb2x1bW4gaXMgbm90IGZvdW5kIG9yIGlzIGhpZGRlbiB0aGVuIHJldHVybnMgLTEuXG4gICAgICogXHRcdFx0XHROb3RlOiBNZXRob2QgZG9lcyBub3QgY291bnQgY29sdW1uIGdyb3VwcyAoTXVsdGktQ29sdW1uIEhlYWRlcnMpLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbktleSAgICAgY29sdW1uS2V5XG4gICAgICogQHBhcmFtIGluY2x1ZGVEYXRhU2tpcCAgICAgT3B0aW9uYWwgcGFyYW1ldGVyIC0gaWYgc2V0IHRvIHRydWUgaW5jbHVkZSBub24gZGF0YSBjb2x1bW5zKGxpa2UgZXhwYW5kZXIgY29sdW1uLCByb3cgc2VsZWN0b3JzIGNvbHVtbiwgZXRjLikgaW4gY2FsY3VsYXRpb25zXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgZ2V0VmlzaWJsZUluZGV4QnlLZXkoY29sdW1uS2V5OiBzdHJpbmcsIGluY2x1ZGVEYXRhU2tpcDogYm9vbGVhbik6IG51bWJlciB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gY2FsbGVkIHRoZSBtZXRob2QgcmUtcmVuZGVycyB0aGUgd2hvbGUgZ3JpZChhbHNvIHJlYmluZHMgdG8gdGhlIGRhdGEgc291cmNlKSBhbmQgcmVuZGVycyB0aGUgY29scyBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2xzIGFuIGFycmF5IG9mIGNvbHVtbiBvYmplY3RzXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgcmVuZGVyTXVsdGlDb2x1bW5IZWFkZXIoY29sczogYW55W10pOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogU2Nyb2xsIHRvIHRoZSBzcGVjaWZpZWQgcm93IG9yIHNwZWNpZmllZCBwb3NpdGlvbihpbiBwaXhlbHMpXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2Nyb2xsZXJQb3NpdGlvbiAgICAgQW4gaWRlbnRpZmllciBvZiB0aGUgdmVydGljYWwgc2Nyb2xsIHBvc2l0aW9uLiBXaGVuIGl0IGlzIHN0cmluZyB0aGVuIGl0IGlzIGludGVycHJldGVkIGFzIHBpeGVscyBvdGhlcndpc2UgaXQgaXMgdGhlIHJvdyBudW1iZXJcbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyB2aXJ0dWFsU2Nyb2xsVG8oc2Nyb2xsZXJQb3NpdGlvbjogT2JqZWN0KTogdm9pZCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29sdW1uIG9iamVjdCBhbmQgdmlzaWJsZSBpbmRleCBmb3IgdGhlIHRhYmxlIGNlbGwoVEQpIHdoaWNoIGlzIHBhc3NlZCBhcyBhcmd1bWVudFxuICAgICAqXG4gICAgICogQHBhcmFtICR0ZCAgICAgY2VsbChURCkgLSBlaXRoZXIgRE9NIFREIGVsZW1lbnQgb3IgalF1ZXJ5IG9iamVjdFxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGdldENvbHVtbkJ5VEQoJHRkOiBPYmplY3QpOiBPYmplY3QgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95IGlzIHBhcnQgb2YgdGhlIGpRdWVyeSBVSSB3aWRnZXQgQVBJIGFuZCBkb2VzIHRoZSBmb2xsb3dpbmc6XG4gICAgICogXHRcdFx0XHQxLiBSZW1vdmUgY3VzdG9tIENTUyBjbGFzc2VzIHRoYXQgd2VyZSBhZGRlZC5cbiAgICAgKiBcdFx0XHRcdDIuIFVud3JhcCBhbnkgd3JhcHBpbmcgZWxlbWVudHMgc3VjaCBhcyBzY3JvbGxpbmcgZGl2cyBhbmQgb3RoZXIgY29udGFpbmVycy5cbiAgICAgKiBcdFx0XHRcdDMuIFVuYmluZCBhbGwgZXZlbnRzIHRoYXQgd2VyZSBib3VuZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBub3RUb0NhbGxEZXN0cm95IFxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGRlc3Ryb3kobm90VG9DYWxsRGVzdHJveTogT2JqZWN0KTogdm9pZCB7IHJldHVybjsgfTtcbn0iXX0=