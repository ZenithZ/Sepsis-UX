/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ElementRef, Renderer, IterableDiffers, KeyValueDiffers, ChangeDetectorRef } from "@angular/core";
import { IgControlBase } from "../igcontrolbase/igcontrolbase";
export class IgRadialGaugeComponent extends IgControlBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiffers, cdr) { super(el, renderer, differs, kvalDiffers, cdr); }
    /**
     * Returns a string containing the names of all the ranges delimited with a \n symbol.
     * @return {?}
     */
    /* istanbul ignore next */
    getRangeNames() { return; }
    ;
    /**
     * Adds a new range to the radial gauge.
     *
     * @param {?} value
     * @return {?}
     */
    /* istanbul ignore next */
    addRange(value) { return; }
    ;
    /**
     * Removes a specified range.
     *
     * @param {?} value
     * @return {?}
     */
    /* istanbul ignore next */
    removeRange(value) { return; }
    ;
    /**
     * Updates the range.
     *
     * @param {?} value
     * @return {?}
     */
    /* istanbul ignore next */
    updateRange(value) { return; }
    ;
    /**
     * Clears the ranges in the radial gauge.
     * @return {?}
     */
    /* istanbul ignore next */
    clearRanges() { return; }
    ;
    /**
     * Scales a value on the gauge's main scale to an angle around the center point of the gauge, in radians.
     *
     * @param {?} value
     * @return {?}
     */
    /* istanbul ignore next */
    scaleValue(value) { return; }
    ;
    /**
     * Unscales a value from an angle in radians to the represented value along the main scale of the gauge.
     *
     * @param {?} value
     * @return {?}
     */
    /* istanbul ignore next */
    unscaleValue(value) { return; }
    ;
    /**
     * Gets the value for the main scale of the gauge for a given point within the bounds of the gauge.
     *
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    /* istanbul ignore next */
    getValueForPoint(x, y) { return; }
    ;
    /**
     * Gets the point on the gauge for a given scale value and extent.
     *
     * @param {?} value
     * @param {?} extent
     * @return {?}
     */
    /* istanbul ignore next */
    getPointForValue(value, extent) { return; }
    ;
    /**
     * Returns true if the main gauge needle bounding box contains the point provided, otherwise false.
     *
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    /* istanbul ignore next */
    needleContainsPoint(x, y) { return; }
    ;
    /**
     * Exports the visual data for the radial gauge.
     * @return {?}
     */
    /* istanbul ignore next */
    exportVisualData() { return; }
    ;
    /**
     * Flushes the gauge.
     * @return {?}
     */
    /* istanbul ignore next */
    flush() { return; }
    ;
    /**
     * Destroys widget.
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
    /**
     * Returns true if the style was updated for the radial gauge.
     * @return {?}
     */
    /* istanbul ignore next */
    styleUpdated() { return; }
    ;
}
IgRadialGaugeComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-radial-gauge",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "width", "height", "ranges", "rangeBrushes", "rangeOutlines", "minimumValue", "maximumValue", "interval", "centerX", "centerY", "value", "scaleStartAngle", "scaleEndAngle", "scaleSweepDirection", "transitionDuration", "transitionEasingFunction", "needleBrush", "needleOutline", "needleStartExtent", "needleEndExtent", "needleShape", "needleStartWidthRatio", "needleEndWidthRatio", "needleBaseFeatureWidthRatio", "needleBaseFeatureExtent", "needlePointFeatureWidthRatio", "needlePointFeatureExtent", "needlePivotWidthRatio", "needlePivotInnerWidthRatio", "needlePivotShape", "scaleStartExtent", "needlePivotBrush", "needlePivotOutline", "needleStrokeThickness", "needlePivotStrokeThickness", "scaleEndExtent", "labelExtent", "labelInterval", "tickStartExtent", "tickEndExtent", "tickStrokeThickness", "tickBrush", "fontBrush", "minorTickStartExtent", "minorTickEndExtent", "minorTickStrokeThickness", "minorTickBrush", "minorTickCount", "scaleBrush", "backingBrush", "backingOutline", "backingStrokeThickness", "backingOuterExtent", "backingOversweep", "scaleOversweep", "scaleOversweepShape", "backingCornerRadius", "backingInnerExtent", "backingShape", "radiusMultiplier", "duplicateLabelOmissionStrategy", "isNeedleDraggingEnabled", "isNeedleDraggingConstrained", "font", "transitionProgress", "pixelScalingRatio"],
                outputs: ["formatLabel", "alignLabel", "valueChanged"]
            }] }
];
/** @nocollapse */
IgRadialGaugeComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWdyYWRpYWxnYXVnZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLXdyYXBwZXJzLyIsInNvdXJjZXMiOlsibGliL2lncmFkaWFsZ2F1Z2UvaWdyYWRpYWxnYXVnZS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxlQUFlLEVBQUUsZUFBZSxFQUFFLGlCQUFpQixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3JILE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQVEvRCxNQUFNLE9BQU8sc0JBQXVCLFNBQVEsYUFBNEI7Ozs7Ozs7O0lBQ3BFLFlBQVksRUFBYyxFQUFFLFFBQWtCLEVBQUUsT0FBd0IsRUFBRSxXQUE0QixFQUFFLEdBQXNCLElBQUksS0FBSyxDQUFDLEVBQUUsRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLFdBQVcsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7Ozs7OztJQU01SyxhQUFhLEtBQWEsT0FBTyxDQUFDLENBQUM7SUFBQSxDQUFDOzs7Ozs7OztJQVFwQyxRQUFRLENBQUMsS0FBYSxJQUFVLE9BQU8sQ0FBQyxDQUFDO0lBQUEsQ0FBQzs7Ozs7Ozs7SUFRMUMsV0FBVyxDQUFDLEtBQWEsSUFBVSxPQUFPLENBQUMsQ0FBQztJQUFBLENBQUM7Ozs7Ozs7O0lBUTdDLFdBQVcsQ0FBQyxLQUFhLElBQVUsT0FBTyxDQUFDLENBQUM7SUFBQSxDQUFDOzs7Ozs7SUFNN0MsV0FBVyxLQUFXLE9BQU8sQ0FBQyxDQUFDO0lBQUEsQ0FBQzs7Ozs7Ozs7SUFRaEMsVUFBVSxDQUFDLEtBQWEsSUFBVSxPQUFPLENBQUMsQ0FBQztJQUFBLENBQUM7Ozs7Ozs7O0lBUTVDLFlBQVksQ0FBQyxLQUFhLElBQVUsT0FBTyxDQUFDLENBQUM7SUFBQSxDQUFDOzs7Ozs7Ozs7SUFTOUMsZ0JBQWdCLENBQUMsQ0FBUyxFQUFFLENBQVMsSUFBWSxPQUFPLENBQUMsQ0FBQztJQUFBLENBQUM7Ozs7Ozs7OztJQVMzRCxnQkFBZ0IsQ0FBQyxLQUFhLEVBQUUsTUFBYyxJQUFVLE9BQU8sQ0FBQyxDQUFDO0lBQUEsQ0FBQzs7Ozs7Ozs7O0lBU2xFLG1CQUFtQixDQUFDLENBQVMsRUFBRSxDQUFTLElBQVUsT0FBTyxDQUFDLENBQUM7SUFBQSxDQUFDOzs7Ozs7SUFNNUQsZ0JBQWdCLEtBQVcsT0FBTyxDQUFDLENBQUM7SUFBQSxDQUFDOzs7Ozs7SUFNckMsS0FBSyxLQUFXLE9BQU8sQ0FBQyxDQUFDO0lBQUEsQ0FBQzs7Ozs7O0lBTTFCLE9BQU8sS0FBVyxPQUFPLENBQUMsQ0FBQztJQUFBLENBQUM7Ozs7OztJQU01QixZQUFZLEtBQVcsT0FBTyxDQUFDLENBQUM7SUFBQSxDQUFDOzs7WUE5RzNDLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsaUJBQWlCO2dCQUMzQixRQUFRLEVBQUUsMkJBQTJCO2dCQUNyQyxNQUFNLEVBQUUsQ0FBQyxVQUFVLEVBQUUsU0FBUyxFQUFFLHlCQUF5QixFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsY0FBYyxFQUFFLGVBQWUsRUFBRSxjQUFjLEVBQUUsY0FBYyxFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxlQUFlLEVBQUUscUJBQXFCLEVBQUUsb0JBQW9CLEVBQUUsMEJBQTBCLEVBQUUsYUFBYSxFQUFFLGVBQWUsRUFBRSxtQkFBbUIsRUFBRSxpQkFBaUIsRUFBRSxhQUFhLEVBQUUsdUJBQXVCLEVBQUUscUJBQXFCLEVBQUUsNkJBQTZCLEVBQUUseUJBQXlCLEVBQUUsOEJBQThCLEVBQUUsMEJBQTBCLEVBQUUsdUJBQXVCLEVBQUUsNEJBQTRCLEVBQUUsa0JBQWtCLEVBQUUsa0JBQWtCLEVBQUUsa0JBQWtCLEVBQUUsb0JBQW9CLEVBQUUsdUJBQXVCLEVBQUUsNEJBQTRCLEVBQUUsZ0JBQWdCLEVBQUUsYUFBYSxFQUFFLGVBQWUsRUFBRSxpQkFBaUIsRUFBRSxlQUFlLEVBQUUscUJBQXFCLEVBQUUsV0FBVyxFQUFFLFdBQVcsRUFBRSxzQkFBc0IsRUFBRSxvQkFBb0IsRUFBRSwwQkFBMEIsRUFBRSxnQkFBZ0IsRUFBRSxnQkFBZ0IsRUFBRSxZQUFZLEVBQUUsY0FBYyxFQUFFLGdCQUFnQixFQUFFLHdCQUF3QixFQUFFLG9CQUFvQixFQUFFLGtCQUFrQixFQUFFLGdCQUFnQixFQUFFLHFCQUFxQixFQUFFLHFCQUFxQixFQUFFLG9CQUFvQixFQUFFLGNBQWMsRUFBRSxrQkFBa0IsRUFBRSxnQ0FBZ0MsRUFBRSx5QkFBeUIsRUFBRSw2QkFBNkIsRUFBRSxNQUFNLEVBQUUsb0JBQW9CLEVBQUUsbUJBQW1CLENBQUM7Z0JBQ3IzQyxPQUFPLEVBQUUsQ0FBQyxhQUFhLEVBQUUsWUFBWSxFQUFFLGNBQWMsQ0FBQzthQUN6RDs7OztZQVJtQixVQUFVO1lBQUUsUUFBUTtZQUFFLGVBQWU7WUFBRSxlQUFlO1lBQUUsaUJBQWlCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBSZW5kZXJlciwgSXRlcmFibGVEaWZmZXJzLCBLZXlWYWx1ZURpZmZlcnMsIENoYW5nZURldGVjdG9yUmVmIH0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7IElnQ29udHJvbEJhc2UgfSBmcm9tIFwiLi4vaWdjb250cm9sYmFzZS9pZ2NvbnRyb2xiYXNlXCI7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiBcImlnLXJhZGlhbC1nYXVnZVwiLFxuICAgIHRlbXBsYXRlOiBcIjxuZy1jb250ZW50PjwvbmctY29udGVudD5cIixcbiAgICBpbnB1dHM6IFtcIndpZGdldElkXCIsIFwib3B0aW9uc1wiLCBcImNoYW5nZURldGVjdGlvbkludGVydmFsXCIsIFwiZGlzYWJsZWRcIiwgXCJjcmVhdGVcIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiLCBcInJhbmdlc1wiLCBcInJhbmdlQnJ1c2hlc1wiLCBcInJhbmdlT3V0bGluZXNcIiwgXCJtaW5pbXVtVmFsdWVcIiwgXCJtYXhpbXVtVmFsdWVcIiwgXCJpbnRlcnZhbFwiLCBcImNlbnRlclhcIiwgXCJjZW50ZXJZXCIsIFwidmFsdWVcIiwgXCJzY2FsZVN0YXJ0QW5nbGVcIiwgXCJzY2FsZUVuZEFuZ2xlXCIsIFwic2NhbGVTd2VlcERpcmVjdGlvblwiLCBcInRyYW5zaXRpb25EdXJhdGlvblwiLCBcInRyYW5zaXRpb25FYXNpbmdGdW5jdGlvblwiLCBcIm5lZWRsZUJydXNoXCIsIFwibmVlZGxlT3V0bGluZVwiLCBcIm5lZWRsZVN0YXJ0RXh0ZW50XCIsIFwibmVlZGxlRW5kRXh0ZW50XCIsIFwibmVlZGxlU2hhcGVcIiwgXCJuZWVkbGVTdGFydFdpZHRoUmF0aW9cIiwgXCJuZWVkbGVFbmRXaWR0aFJhdGlvXCIsIFwibmVlZGxlQmFzZUZlYXR1cmVXaWR0aFJhdGlvXCIsIFwibmVlZGxlQmFzZUZlYXR1cmVFeHRlbnRcIiwgXCJuZWVkbGVQb2ludEZlYXR1cmVXaWR0aFJhdGlvXCIsIFwibmVlZGxlUG9pbnRGZWF0dXJlRXh0ZW50XCIsIFwibmVlZGxlUGl2b3RXaWR0aFJhdGlvXCIsIFwibmVlZGxlUGl2b3RJbm5lcldpZHRoUmF0aW9cIiwgXCJuZWVkbGVQaXZvdFNoYXBlXCIsIFwic2NhbGVTdGFydEV4dGVudFwiLCBcIm5lZWRsZVBpdm90QnJ1c2hcIiwgXCJuZWVkbGVQaXZvdE91dGxpbmVcIiwgXCJuZWVkbGVTdHJva2VUaGlja25lc3NcIiwgXCJuZWVkbGVQaXZvdFN0cm9rZVRoaWNrbmVzc1wiLCBcInNjYWxlRW5kRXh0ZW50XCIsIFwibGFiZWxFeHRlbnRcIiwgXCJsYWJlbEludGVydmFsXCIsIFwidGlja1N0YXJ0RXh0ZW50XCIsIFwidGlja0VuZEV4dGVudFwiLCBcInRpY2tTdHJva2VUaGlja25lc3NcIiwgXCJ0aWNrQnJ1c2hcIiwgXCJmb250QnJ1c2hcIiwgXCJtaW5vclRpY2tTdGFydEV4dGVudFwiLCBcIm1pbm9yVGlja0VuZEV4dGVudFwiLCBcIm1pbm9yVGlja1N0cm9rZVRoaWNrbmVzc1wiLCBcIm1pbm9yVGlja0JydXNoXCIsIFwibWlub3JUaWNrQ291bnRcIiwgXCJzY2FsZUJydXNoXCIsIFwiYmFja2luZ0JydXNoXCIsIFwiYmFja2luZ091dGxpbmVcIiwgXCJiYWNraW5nU3Ryb2tlVGhpY2tuZXNzXCIsIFwiYmFja2luZ091dGVyRXh0ZW50XCIsIFwiYmFja2luZ092ZXJzd2VlcFwiLCBcInNjYWxlT3ZlcnN3ZWVwXCIsIFwic2NhbGVPdmVyc3dlZXBTaGFwZVwiLCBcImJhY2tpbmdDb3JuZXJSYWRpdXNcIiwgXCJiYWNraW5nSW5uZXJFeHRlbnRcIiwgXCJiYWNraW5nU2hhcGVcIiwgXCJyYWRpdXNNdWx0aXBsaWVyXCIsIFwiZHVwbGljYXRlTGFiZWxPbWlzc2lvblN0cmF0ZWd5XCIsIFwiaXNOZWVkbGVEcmFnZ2luZ0VuYWJsZWRcIiwgXCJpc05lZWRsZURyYWdnaW5nQ29uc3RyYWluZWRcIiwgXCJmb250XCIsIFwidHJhbnNpdGlvblByb2dyZXNzXCIsIFwicGl4ZWxTY2FsaW5nUmF0aW9cIl0sXG4gICAgb3V0cHV0czogW1wiZm9ybWF0TGFiZWxcIiwgXCJhbGlnbkxhYmVsXCIsIFwidmFsdWVDaGFuZ2VkXCJdXG59KVxuZXhwb3J0IGNsYXNzIElnUmFkaWFsR2F1Z2VDb21wb25lbnQgZXh0ZW5kcyBJZ0NvbnRyb2xCYXNlPElnUmFkaWFsR2F1Z2U+IHtcbiAgICBjb25zdHJ1Y3RvcihlbDogRWxlbWVudFJlZiwgcmVuZGVyZXI6IFJlbmRlcmVyLCBkaWZmZXJzOiBJdGVyYWJsZURpZmZlcnMsIGt2YWxEaWZmZXJzOiBLZXlWYWx1ZURpZmZlcnMsIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYpIHsgc3VwZXIoZWwsIHJlbmRlcmVyLCBkaWZmZXJzLCBrdmFsRGlmZmVycywgY2RyKTsgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyBjb250YWluaW5nIHRoZSBuYW1lcyBvZiBhbGwgdGhlIHJhbmdlcyBkZWxpbWl0ZWQgd2l0aCBhIFxcbiBzeW1ib2wuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgZ2V0UmFuZ2VOYW1lcygpOiBzdHJpbmcgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IHJhbmdlIHRvIHRoZSByYWRpYWwgZ2F1Z2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgYWRkUmFuZ2UodmFsdWU6IE9iamVjdCk6IHZvaWQgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgc3BlY2lmaWVkIHJhbmdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIFxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIHJlbW92ZVJhbmdlKHZhbHVlOiBPYmplY3QpOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcmFuZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgdXBkYXRlUmFuZ2UodmFsdWU6IE9iamVjdCk6IHZvaWQgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIHJhbmdlcyBpbiB0aGUgcmFkaWFsIGdhdWdlLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGNsZWFyUmFuZ2VzKCk6IHZvaWQgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBTY2FsZXMgYSB2YWx1ZSBvbiB0aGUgZ2F1Z2UncyBtYWluIHNjYWxlIHRvIGFuIGFuZ2xlIGFyb3VuZCB0aGUgY2VudGVyIHBvaW50IG9mIHRoZSBnYXVnZSwgaW4gcmFkaWFucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBcbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBzY2FsZVZhbHVlKHZhbHVlOiBPYmplY3QpOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogVW5zY2FsZXMgYSB2YWx1ZSBmcm9tIGFuIGFuZ2xlIGluIHJhZGlhbnMgdG8gdGhlIHJlcHJlc2VudGVkIHZhbHVlIGFsb25nIHRoZSBtYWluIHNjYWxlIG9mIHRoZSBnYXVnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBcbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyB1bnNjYWxlVmFsdWUodmFsdWU6IE9iamVjdCk6IHZvaWQgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBmb3IgdGhlIG1haW4gc2NhbGUgb2YgdGhlIGdhdWdlIGZvciBhIGdpdmVuIHBvaW50IHdpdGhpbiB0aGUgYm91bmRzIG9mIHRoZSBnYXVnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB4IFxuICAgICAqIEBwYXJhbSB5IFxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGdldFZhbHVlRm9yUG9pbnQoeDogT2JqZWN0LCB5OiBPYmplY3QpOiBudW1iZXIgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwb2ludCBvbiB0aGUgZ2F1Z2UgZm9yIGEgZ2l2ZW4gc2NhbGUgdmFsdWUgYW5kIGV4dGVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBcbiAgICAgKiBAcGFyYW0gZXh0ZW50IFxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGdldFBvaW50Rm9yVmFsdWUodmFsdWU6IE9iamVjdCwgZXh0ZW50OiBPYmplY3QpOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBtYWluIGdhdWdlIG5lZWRsZSBib3VuZGluZyBib3ggY29udGFpbnMgdGhlIHBvaW50IHByb3ZpZGVkLCBvdGhlcndpc2UgZmFsc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geCBcbiAgICAgKiBAcGFyYW0geSBcbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBuZWVkbGVDb250YWluc1BvaW50KHg6IE9iamVjdCwgeTogT2JqZWN0KTogdm9pZCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIEV4cG9ydHMgdGhlIHZpc3VhbCBkYXRhIGZvciB0aGUgcmFkaWFsIGdhdWdlLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGV4cG9ydFZpc3VhbERhdGEoKTogdm9pZCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIEZsdXNoZXMgdGhlIGdhdWdlLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGZsdXNoKCk6IHZvaWQgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB3aWRnZXQuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgZGVzdHJveSgpOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzdHlsZSB3YXMgdXBkYXRlZCBmb3IgdGhlIHJhZGlhbCBnYXVnZS5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBzdHlsZVVwZGF0ZWQoKTogdm9pZCB7IHJldHVybjsgfTtcbn0iXX0=