/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ElementRef, Renderer, IterableDiffers, KeyValueDiffers, ChangeDetectorRef } from "@angular/core";
import { IgControlBase } from "../igcontrolbase/igcontrolbase";
export class IgLinearGaugeComponent extends IgControlBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiffers, cdr) { super(el, renderer, differs, kvalDiffers, cdr); }
    /**
     * Returns a string containing the names of all the ranges delimited with a \n symbol.
     * @return {?}
     */
    /* istanbul ignore next */
    getRangeNames() { return; }
    ;
    /**
     * Adds a new range to the linear gauge.
     *
     * @param {?} value     The range object to be added.
     * @return {?}
     */
    /* istanbul ignore next */
    addRange(value) { return; }
    ;
    /**
     * Removes a range from the linear gauge.
     *
     * @param {?} value     A JS object with properties set as follows: name: nameOfTheRangeToRemove, remove: true
     * @return {?}
     */
    /* istanbul ignore next */
    removeRange(value) { return; }
    ;
    /**
     * Updates the specified range of the linear gauge.
     *
     * @param {?} value     The range object to be updated.
     * @return {?}
     */
    /* istanbul ignore next */
    updateRange(value) { return; }
    ;
    /**
     * Gets the value for the main scale of the gauge for a given point within the bounds of the gauge.
     *
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    /* istanbul ignore next */
    getValueForPoint(x, y) { return; }
    ;
    /**
     * Returns true if the main gauge needle bounding box contains the point provided, otherwise false.
     *
     * @param {?} x The x coordinate of the point.
     * @param {?} y The y coordinate of the point.
     * @return {?}
     */
    /* istanbul ignore next */
    needleContainsPoint(x, y) { return; }
    ;
    /**
     * Returns information about how the linear gauge is rendered.
     * @return {?}
     */
    /* istanbul ignore next */
    exportVisualData() { return; }
    ;
    /**
     * Causes all pending changes of the linear gauge e.g. by changed property values to be rendered immediately.
     * @return {?}
     */
    /* istanbul ignore next */
    flush() { return; }
    ;
    /**
     * Destroys widget.
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
    /**
     * Re-polls the css styles for the widget. Use this method when the css styles have been modified.
     * @return {?}
     */
    /* istanbul ignore next */
    styleUpdated() { return; }
    ;
}
IgLinearGaugeComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-linear-gauge",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "width", "height", "ranges", "rangeToolTipTemplate", "needleToolTipTemplate", "orientation", "rangeBrushes", "rangeOutlines", "minimumValue", "maximumValue", "value", "needleShape", "needleName", "rangeInnerExtent", "scaleInnerExtent", "rangeOuterExtent", "scaleOuterExtent", "needleInnerExtent", "needleOuterExtent", "needleInnerBaseWidth", "needleOuterBaseWidth", "needleInnerPointWidth", "needleOuterPointWidth", "needleInnerPointExtent", "needleOuterPointExtent", "interval", "ticksPostInitial", "ticksPreTerminal", "labelInterval", "labelExtent", "labelsPostInitial", "labelsPreTerminal", "minorTickCount", "tickStartExtent", "tickEndExtent", "tickStrokeThickness", "tickBrush", "fontBrush", "needleBreadth", "needleBrush", "needleOutline", "needleStrokeThickness", "minorTickStartExtent", "minorTickEndExtent", "minorTickStrokeThickness", "minorTickBrush", "isScaleInverted", "backingBrush", "backingOutline", "backingStrokeThickness", "backingInnerExtent", "backingOuterExtent", "scaleStartExtent", "scaleEndExtent", "scaleBrush", "scaleOutline", "scaleStrokeThickness", "isNeedleDraggingEnabled", "transitionDuration", "showToolTipTimeout", "showToolTip", "font", "pixelScalingRatio"],
                outputs: ["formatLabel", "alignLabel", "valueChanged"]
            }] }
];
/** @nocollapse */
IgLinearGaugeComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWdsaW5lYXJnYXVnZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLXdyYXBwZXJzLyIsInNvdXJjZXMiOlsibGliL2lnbGluZWFyZ2F1Z2UvaWdsaW5lYXJnYXVnZS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxlQUFlLEVBQUUsZUFBZSxFQUFFLGlCQUFpQixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3JILE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQVEvRCxNQUFNLE9BQU8sc0JBQXVCLFNBQVEsYUFBNEI7Ozs7Ozs7O0lBQ3BFLFlBQVksRUFBYyxFQUFFLFFBQWtCLEVBQUUsT0FBd0IsRUFBRSxXQUE0QixFQUFFLEdBQXNCLElBQUksS0FBSyxDQUFDLEVBQUUsRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLFdBQVcsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7Ozs7OztJQU01SyxhQUFhLEtBQWEsT0FBTyxDQUFDLENBQUM7SUFBQSxDQUFDOzs7Ozs7OztJQVFwQyxRQUFRLENBQUMsS0FBYSxJQUFVLE9BQU8sQ0FBQyxDQUFDO0lBQUEsQ0FBQzs7Ozs7Ozs7SUFRMUMsV0FBVyxDQUFDLEtBQWEsSUFBVSxPQUFPLENBQUMsQ0FBQztJQUFBLENBQUM7Ozs7Ozs7O0lBUTdDLFdBQVcsQ0FBQyxLQUFhLElBQVUsT0FBTyxDQUFDLENBQUM7SUFBQSxDQUFDOzs7Ozs7Ozs7SUFTN0MsZ0JBQWdCLENBQUMsQ0FBUyxFQUFFLENBQVMsSUFBWSxPQUFPLENBQUMsQ0FBQztJQUFBLENBQUM7Ozs7Ozs7OztJQVMzRCxtQkFBbUIsQ0FBQyxDQUFTLEVBQUUsQ0FBUyxJQUFVLE9BQU8sQ0FBQyxDQUFDO0lBQUEsQ0FBQzs7Ozs7O0lBTTVELGdCQUFnQixLQUFhLE9BQU8sQ0FBQyxDQUFDO0lBQUEsQ0FBQzs7Ozs7O0lBTXZDLEtBQUssS0FBVyxPQUFPLENBQUMsQ0FBQztJQUFBLENBQUM7Ozs7OztJQU0xQixPQUFPLEtBQVcsT0FBTyxDQUFDLENBQUM7SUFBQSxDQUFDOzs7Ozs7SUFNNUIsWUFBWSxLQUFXLE9BQU8sQ0FBQyxDQUFDO0lBQUEsQ0FBQzs7O1lBL0UzQyxTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLGlCQUFpQjtnQkFDM0IsUUFBUSxFQUFFLDJCQUEyQjtnQkFDckMsTUFBTSxFQUFFLENBQUMsVUFBVSxFQUFFLFNBQVMsRUFBRSx5QkFBeUIsRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLHNCQUFzQixFQUFFLHVCQUF1QixFQUFFLGFBQWEsRUFBRSxjQUFjLEVBQUUsZUFBZSxFQUFFLGNBQWMsRUFBRSxjQUFjLEVBQUUsT0FBTyxFQUFFLGFBQWEsRUFBRSxZQUFZLEVBQUUsa0JBQWtCLEVBQUUsa0JBQWtCLEVBQUUsa0JBQWtCLEVBQUUsa0JBQWtCLEVBQUUsbUJBQW1CLEVBQUUsbUJBQW1CLEVBQUUsc0JBQXNCLEVBQUUsc0JBQXNCLEVBQUUsdUJBQXVCLEVBQUUsdUJBQXVCLEVBQUUsd0JBQXdCLEVBQUUsd0JBQXdCLEVBQUUsVUFBVSxFQUFFLGtCQUFrQixFQUFFLGtCQUFrQixFQUFFLGVBQWUsRUFBRSxhQUFhLEVBQUUsbUJBQW1CLEVBQUUsbUJBQW1CLEVBQUUsZ0JBQWdCLEVBQUUsaUJBQWlCLEVBQUUsZUFBZSxFQUFFLHFCQUFxQixFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUUsZUFBZSxFQUFFLGFBQWEsRUFBRSxlQUFlLEVBQUUsdUJBQXVCLEVBQUUsc0JBQXNCLEVBQUUsb0JBQW9CLEVBQUUsMEJBQTBCLEVBQUUsZ0JBQWdCLEVBQUUsaUJBQWlCLEVBQUUsY0FBYyxFQUFFLGdCQUFnQixFQUFFLHdCQUF3QixFQUFFLG9CQUFvQixFQUFFLG9CQUFvQixFQUFFLGtCQUFrQixFQUFFLGdCQUFnQixFQUFFLFlBQVksRUFBRSxjQUFjLEVBQUUsc0JBQXNCLEVBQUUseUJBQXlCLEVBQUUsb0JBQW9CLEVBQUUsb0JBQW9CLEVBQUUsYUFBYSxFQUFFLE1BQU0sRUFBRSxtQkFBbUIsQ0FBQztnQkFDenZDLE9BQU8sRUFBRSxDQUFDLGFBQWEsRUFBRSxZQUFZLEVBQUUsY0FBYyxDQUFDO2FBQ3pEOzs7O1lBUm1CLFVBQVU7WUFBRSxRQUFRO1lBQUUsZUFBZTtZQUFFLGVBQWU7WUFBRSxpQkFBaUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIEVsZW1lbnRSZWYsIFJlbmRlcmVyLCBJdGVyYWJsZURpZmZlcnMsIEtleVZhbHVlRGlmZmVycywgQ2hhbmdlRGV0ZWN0b3JSZWYgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgSWdDb250cm9sQmFzZSB9IGZyb20gXCIuLi9pZ2NvbnRyb2xiYXNlL2lnY29udHJvbGJhc2VcIjtcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6IFwiaWctbGluZWFyLWdhdWdlXCIsXG4gICAgdGVtcGxhdGU6IFwiPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlwiLFxuICAgIGlucHV0czogW1wid2lkZ2V0SWRcIiwgXCJvcHRpb25zXCIsIFwiY2hhbmdlRGV0ZWN0aW9uSW50ZXJ2YWxcIiwgXCJkaXNhYmxlZFwiLCBcImNyZWF0ZVwiLCBcIndpZHRoXCIsIFwiaGVpZ2h0XCIsIFwicmFuZ2VzXCIsIFwicmFuZ2VUb29sVGlwVGVtcGxhdGVcIiwgXCJuZWVkbGVUb29sVGlwVGVtcGxhdGVcIiwgXCJvcmllbnRhdGlvblwiLCBcInJhbmdlQnJ1c2hlc1wiLCBcInJhbmdlT3V0bGluZXNcIiwgXCJtaW5pbXVtVmFsdWVcIiwgXCJtYXhpbXVtVmFsdWVcIiwgXCJ2YWx1ZVwiLCBcIm5lZWRsZVNoYXBlXCIsIFwibmVlZGxlTmFtZVwiLCBcInJhbmdlSW5uZXJFeHRlbnRcIiwgXCJzY2FsZUlubmVyRXh0ZW50XCIsIFwicmFuZ2VPdXRlckV4dGVudFwiLCBcInNjYWxlT3V0ZXJFeHRlbnRcIiwgXCJuZWVkbGVJbm5lckV4dGVudFwiLCBcIm5lZWRsZU91dGVyRXh0ZW50XCIsIFwibmVlZGxlSW5uZXJCYXNlV2lkdGhcIiwgXCJuZWVkbGVPdXRlckJhc2VXaWR0aFwiLCBcIm5lZWRsZUlubmVyUG9pbnRXaWR0aFwiLCBcIm5lZWRsZU91dGVyUG9pbnRXaWR0aFwiLCBcIm5lZWRsZUlubmVyUG9pbnRFeHRlbnRcIiwgXCJuZWVkbGVPdXRlclBvaW50RXh0ZW50XCIsIFwiaW50ZXJ2YWxcIiwgXCJ0aWNrc1Bvc3RJbml0aWFsXCIsIFwidGlja3NQcmVUZXJtaW5hbFwiLCBcImxhYmVsSW50ZXJ2YWxcIiwgXCJsYWJlbEV4dGVudFwiLCBcImxhYmVsc1Bvc3RJbml0aWFsXCIsIFwibGFiZWxzUHJlVGVybWluYWxcIiwgXCJtaW5vclRpY2tDb3VudFwiLCBcInRpY2tTdGFydEV4dGVudFwiLCBcInRpY2tFbmRFeHRlbnRcIiwgXCJ0aWNrU3Ryb2tlVGhpY2tuZXNzXCIsIFwidGlja0JydXNoXCIsIFwiZm9udEJydXNoXCIsIFwibmVlZGxlQnJlYWR0aFwiLCBcIm5lZWRsZUJydXNoXCIsIFwibmVlZGxlT3V0bGluZVwiLCBcIm5lZWRsZVN0cm9rZVRoaWNrbmVzc1wiLCBcIm1pbm9yVGlja1N0YXJ0RXh0ZW50XCIsIFwibWlub3JUaWNrRW5kRXh0ZW50XCIsIFwibWlub3JUaWNrU3Ryb2tlVGhpY2tuZXNzXCIsIFwibWlub3JUaWNrQnJ1c2hcIiwgXCJpc1NjYWxlSW52ZXJ0ZWRcIiwgXCJiYWNraW5nQnJ1c2hcIiwgXCJiYWNraW5nT3V0bGluZVwiLCBcImJhY2tpbmdTdHJva2VUaGlja25lc3NcIiwgXCJiYWNraW5nSW5uZXJFeHRlbnRcIiwgXCJiYWNraW5nT3V0ZXJFeHRlbnRcIiwgXCJzY2FsZVN0YXJ0RXh0ZW50XCIsIFwic2NhbGVFbmRFeHRlbnRcIiwgXCJzY2FsZUJydXNoXCIsIFwic2NhbGVPdXRsaW5lXCIsIFwic2NhbGVTdHJva2VUaGlja25lc3NcIiwgXCJpc05lZWRsZURyYWdnaW5nRW5hYmxlZFwiLCBcInRyYW5zaXRpb25EdXJhdGlvblwiLCBcInNob3dUb29sVGlwVGltZW91dFwiLCBcInNob3dUb29sVGlwXCIsIFwiZm9udFwiLCBcInBpeGVsU2NhbGluZ1JhdGlvXCJdLFxuICAgIG91dHB1dHM6IFtcImZvcm1hdExhYmVsXCIsIFwiYWxpZ25MYWJlbFwiLCBcInZhbHVlQ2hhbmdlZFwiXVxufSlcbmV4cG9ydCBjbGFzcyBJZ0xpbmVhckdhdWdlQ29tcG9uZW50IGV4dGVuZHMgSWdDb250cm9sQmFzZTxJZ0xpbmVhckdhdWdlPiB7XG4gICAgY29uc3RydWN0b3IoZWw6IEVsZW1lbnRSZWYsIHJlbmRlcmVyOiBSZW5kZXJlciwgZGlmZmVyczogSXRlcmFibGVEaWZmZXJzLCBrdmFsRGlmZmVyczogS2V5VmFsdWVEaWZmZXJzLCBjZHI6IENoYW5nZURldGVjdG9yUmVmKSB7IHN1cGVyKGVsLCByZW5kZXJlciwgZGlmZmVycywga3ZhbERpZmZlcnMsIGNkcik7IH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgY29udGFpbmluZyB0aGUgbmFtZXMgb2YgYWxsIHRoZSByYW5nZXMgZGVsaW1pdGVkIHdpdGggYSBcXG4gc3ltYm9sLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGdldFJhbmdlTmFtZXMoKTogc3RyaW5nIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyByYW5nZSB0byB0aGUgbGluZWFyIGdhdWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlICAgICBUaGUgcmFuZ2Ugb2JqZWN0IHRvIGJlIGFkZGVkLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGFkZFJhbmdlKHZhbHVlOiBPYmplY3QpOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHJhbmdlIGZyb20gdGhlIGxpbmVhciBnYXVnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAgICAgQSBKUyBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIHNldCBhcyBmb2xsb3dzOiBuYW1lOiBuYW1lT2ZUaGVSYW5nZVRvUmVtb3ZlLCByZW1vdmU6IHRydWVcbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyByZW1vdmVSYW5nZSh2YWx1ZTogT2JqZWN0KTogdm9pZCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHNwZWNpZmllZCByYW5nZSBvZiB0aGUgbGluZWFyIGdhdWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlICAgICBUaGUgcmFuZ2Ugb2JqZWN0IHRvIGJlIHVwZGF0ZWQuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgdXBkYXRlUmFuZ2UodmFsdWU6IE9iamVjdCk6IHZvaWQgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBmb3IgdGhlIG1haW4gc2NhbGUgb2YgdGhlIGdhdWdlIGZvciBhIGdpdmVuIHBvaW50IHdpdGhpbiB0aGUgYm91bmRzIG9mIHRoZSBnYXVnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB4IFxuICAgICAqIEBwYXJhbSB5IFxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGdldFZhbHVlRm9yUG9pbnQoeDogT2JqZWN0LCB5OiBPYmplY3QpOiBudW1iZXIgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIG1haW4gZ2F1Z2UgbmVlZGxlIGJvdW5kaW5nIGJveCBjb250YWlucyB0aGUgcG9pbnQgcHJvdmlkZWQsIG90aGVyd2lzZSBmYWxzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB4IFRoZSB4IGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50LlxuICAgICAqIEBwYXJhbSB5IFRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50LlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIG5lZWRsZUNvbnRhaW5zUG9pbnQoeDogbnVtYmVyLCB5OiBudW1iZXIpOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCBob3cgdGhlIGxpbmVhciBnYXVnZSBpcyByZW5kZXJlZC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBleHBvcnRWaXN1YWxEYXRhKCk6IE9iamVjdCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIENhdXNlcyBhbGwgcGVuZGluZyBjaGFuZ2VzIG9mIHRoZSBsaW5lYXIgZ2F1Z2UgZS5nLiBieSBjaGFuZ2VkIHByb3BlcnR5IHZhbHVlcyB0byBiZSByZW5kZXJlZCBpbW1lZGlhdGVseS5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBmbHVzaCgpOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgd2lkZ2V0LlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGRlc3Ryb3koKTogdm9pZCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFJlLXBvbGxzIHRoZSBjc3Mgc3R5bGVzIGZvciB0aGUgd2lkZ2V0LiBVc2UgdGhpcyBtZXRob2Qgd2hlbiB0aGUgY3NzIHN0eWxlcyBoYXZlIGJlZW4gbW9kaWZpZWQuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgc3R5bGVVcGRhdGVkKCk6IHZvaWQgeyByZXR1cm47IH07XG59Il19