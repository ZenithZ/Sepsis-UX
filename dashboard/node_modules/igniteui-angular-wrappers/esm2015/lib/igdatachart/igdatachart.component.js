/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ElementRef, Renderer, IterableDiffers, KeyValueDiffers, ChangeDetectorRef, Input } from "@angular/core";
import { IgControlBase } from "../igcontrolbase/igcontrolbase";
export class IgDataChartComponent extends IgControlBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiffers, cdr) { super(el, renderer, differs, kvalDiffers, cdr); }
    /**
     * @param {?} value
     * @return {?}
     */
    set dataSource(value) {
        this._dataSource = value;
        /** @type {?} */
        const chart = jQuery(this._el).data(this._widgetName);
        if (chart) {
            jQuery(this._el)[this._widgetName]("option", "dataSource", this._dataSource);
        }
    }
    ;
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this._dataSource === null || this._dataSource === undefined) {
            this._dataSource = this.options["dataSource"];
        }
        if (!this.options["dataSource"] && this._dataSource) {
            this.options["dataSource"] = this._dataSource;
        }
        super.ngOnInit();
    }
    /**
     * @return {?}
     */
    option() { return; }
    ;
    /**
     * Returns the element holding the chart.
     * @return {?}
     */
    /* istanbul ignore next */
    widget() { return; }
    ;
    /**
     * Returns the ID of parent element holding the chart.
     * @return {?}
     */
    /* istanbul ignore next */
    id() { return; }
    ;
    /**
     * Exports the chart to a PNG image.
     *
     * @param {?=} width     The width of the image.
     * @param {?=} height     The height of the image.
     * @return {?}
     */
    /* istanbul ignore next */
    exportImage(width, height) { return; }
    ;
    /**
     * Destroys the widget.
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
    /**
     * Notify the chart that styles it draws colors from may have been updated.
     * @return {?}
     */
    /* istanbul ignore next */
    styleUpdated() { return; }
    ;
    /**
     * Resets the zoom level of the chart to default.
     * @return {?}
     */
    /* istanbul ignore next */
    resetZoom() { return; }
    ;
    /**
     * Adds a new item to the data source and notifies the chart.
     *
     * @param {?} item     The item that we want to add to the data source.
     * @param {?} targetName     The name of the series or axis bound to the data source. This is required only when the data is bound to series or axis. If the data is bound to dataSource of igDataChart, the second parameter should not be set.
     * @return {?}
     */
    /* istanbul ignore next */
    addItem(item, targetName) { return; }
    ;
    /**
     * Inserts a new item to the data source and notifies the chart.
     *
     * @param {?} item     the new item that we want to insert in the data source.
     * @param {?} index     The index in the data source where the new item will be inserted.
     * @param {?} targetName     The name of the series or axis bound to the data source.
     * @return {?}
     */
    /* istanbul ignore next */
    insertItem(item, index, targetName) { return; }
    ;
    /**
     * Deletes an item from the data source and notifies the chart.
     *
     * @param {?} index     The index in the data source from where the item will be been removed.
     * @param {?} targetName     The name of the series or axis bound to the data source. This is required only when the data is bound to series or axis. If the data is bound to dataSource of igDataChart, the second parameter should not be set.
     * @return {?}
     */
    /* istanbul ignore next */
    removeItem(index, targetName) { return; }
    ;
    /**
     * Updates an item in the data source and notifies the chart.
     *
     * @param {?} index     The index of the item in the data source that we want to change.
     * @param {?} item     The new item object that will be set in the data source.
     * @param {?} targetName     The name of the series or axis bound to the data source.
     * @return {?}
     */
    /* istanbul ignore next */
    setItem(index, item, targetName) { return; }
    ;
    /**
     * Notifies the chart that an item has been set in an associated data source.
     *
     * @param {?} dataSource     The data source in which the change happened.
     * @param {?} index     The index in the items source that has been changed.
     * @param {?} newItem     the new item that has been set in the collection.
     * @param {?} oldItem     the old item that has been overwritten in the collection.
     * @return {?}
     */
    /* istanbul ignore next */
    notifySetItem(dataSource, index, newItem, oldItem) { return; }
    ;
    /**
     * Notifies the chart that the items have been cleared from an associated data source.
     * 				It's not necessary to notify more than one target of a change if they share the same items source.
     *
     * @param {?} dataSource     The data source in which the change happened.
     * @return {?}
     */
    /* istanbul ignore next */
    notifyClearItems(dataSource) { return; }
    ;
    /**
     * Notifies the target axis or series that an item has been inserted at the specified index in its data source.
     * 				It's not necessary to notify more than one target of a change if they share the same items source.
     *
     * @param {?} dataSource     The data source in which the change happened.
     * @param {?} index     The index in the items source where the new item has been inserted.
     * @param {?} newItem     the new item that has been set in the collection.
     * @return {?}
     */
    /* istanbul ignore next */
    notifyInsertItem(dataSource, index, newItem) { return; }
    ;
    /**
     * Notifies the target axis or series that an item has been removed from the specified index in its data source.
     * 				It's not necessary to notify more than one target of a change if they share the same items source.
     *
     * @param {?} dataSource     The data source in which the change happened.
     * @param {?} index     The index in the items source from where the old item has been removed.
     * @param {?} oldItem     the old item that has been removed from the collection.
     * @return {?}
     */
    /* istanbul ignore next */
    notifyRemoveItem(dataSource, index, oldItem) { return; }
    ;
    /**
     * Notifies the target axis or series that it should scroll the requested data item into view.
     *
     * @param {?} targetName     The name of the axis or series notify.
     * @param {?} item     The data item to bring into view, if possible.
     * @return {?}
     */
    /* istanbul ignore next */
    scrollIntoView(targetName, item) { return; }
    ;
    /**
     * Notifies the target axis that it should scale the requested value into chart space from axis space.
     * 				For example you can use this method if you want to find where value 50 of the x axis stands scaled to chart's width.
     *
     * @param {?} targetName     The name of the axis to notify.
     * @param {?} unscaledValue     The value in axis space to translate into chart space.
     * @return {?}
     */
    /* istanbul ignore next */
    scaleValue(targetName, unscaledValue) { return; }
    ;
    /**
     * Notifies the target axis that it should unscale the requested value into axis space from chart space.
     * 				For example you can use this method if you want to find what is the value of x axis unscaled from 0 width of the chart.
     *
     * @param {?} targetName     The name of the axis to notify.
     * @param {?} scaledValue     The value in chart space to translate into axis space.
     * @return {?}
     */
    /* istanbul ignore next */
    unscaleValue(targetName, scaledValue) { return; }
    ;
    /**
     * For the target axis, if using enhanced interval management and precise interval fitting, this will reset the cached maximum label width, and recalculate using the current labels.
     *
     * @param {?} targetName     The name of the axis to notify.
     * @return {?}
     */
    /* istanbul ignore next */
    resetCachedEnhancedInterval(targetName) { return; }
    ;
    /**
     * Notifies the target series that something that affects its visual properties has changed and the visual output needs a repaint.
     *
     * @param {?} targetName     The name of the series to notify.
     * @return {?}
     */
    /* istanbul ignore next */
    notifyVisualPropertiesChanged(targetName) { return; }
    ;
    /**
     * Forces any pending deferred work to render on the chart before continuing
     * @return {?}
     */
    /* istanbul ignore next */
    flush() { return; }
    ;
    /**
     * Exports visual data from the chart to aid in unit testing
     * @return {?}
     */
    /* istanbul ignore next */
    exportVisualData() { return; }
    ;
    /**
     * Gets the actual minimum value of the target numeric or date time axis
     *
     * @param {?} targetName    The name of the axis from which to get the minimum value.
     * @return {?}
     */
    /* istanbul ignore next */
    getActualMinimumValue(targetName) { return; }
    ;
    /**
     * Gets the actual maximum value of the target numeric or date time axis
     *
     * @param {?} targetName    The name of the axis from which to get the maximum value.
     * @return {?}
     */
    /* istanbul ignore next */
    getActualMaximumValue(targetName) { return; }
    ;
    /**
     * Gets the actual interval of the target numeric or date time axis
     *
     * @param {?} targetName    The name of the axis from which to get the interval.
     * @return {?}
     */
    /* istanbul ignore next */
    getActualInterval(targetName) { return; }
    ;
    /**
     * Creates a print preview page with the chart, hiding all other elements on the page.
     * @return {?}
     */
    /* istanbul ignore next */
    print() { return; }
    ;
    /**
     * Indicates that a series should render, even though no option has been modified that would normally cause it to refresh.
     *
     * @param {?} targetName     The name of the series to render.
     * @param {?} animate     Whether the change should be animated, if possible.
     * @return {?}
     */
    /* istanbul ignore next */
    renderSeries(targetName, animate) { return; }
    ;
    /**
     * Gets the item item index associated with the specified world position.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} worldPoint    The world position (in the form {x: [number from 0 to 1], y: [number from 0 to 1]} ) that represents a position in the space of the axes.
     * @return {?}
     */
    /* istanbul ignore next */
    getItemIndex(targetName, worldPoint) { return; }
    ;
    /**
     * Gets the item that is the best match for the specified world coordinates.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} worldPoint    The world position (in the form {x: [number from 0 to 1], y: [number from 0 to 1]} ) that represents a position in the space of the axes.
     * @return {?}
     */
    /* istanbul ignore next */
    getItem(targetName, worldPoint) { return; }
    ;
    /**
     * For a category plotted series, gets the current width of the items within the categories. This only returns a value if the items have some form of width (e.g. columns, bars, etc.) otherwise 0 is returned.
     *
     * @param {?} targetName    The name of the series to target.
     * @return {?}
     */
    /* istanbul ignore next */
    getItemSpan(targetName) { return; }
    ;
    /**
     * If possible, will return the best available main value of the series for a given world coordinate.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} worldPoint    The world position (in the form {x: [number from 0 to 1], y: [number from 0 to 1]} ) that represents a position in the space of the axes.
     * @param {?} useInterpolation    If true, interpolation should be used to get in-between values, rather than only the actual values in the data set.
     * @param {?} skipUnknowns    If true, unknown values should be skipped.
     * @return {?}
     */
    /* istanbul ignore next */
    getSeriesValue(targetName, worldPoint, useInterpolation, skipUnknowns) { return; }
    ;
    /**
     * If possible, will return the best available value bounding box within the series that has the best value match for the world position provided.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} worldPoint    The world position (in the form {x: [number from 0 to 1], y: [number from 0 to 1]} ) that represents a position in the space of the axes.
     * @return {?}
     */
    /* istanbul ignore next */
    getSeriesValueBoundingBox(targetName, worldPoint) { return; }
    ;
    /**
     * If possible, will return the best available value fine grained bounding boxes within the series that have the best value match for the world position provided.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} worldPoint    The world position (in the form {x: [number from 0 to 1], y: [number from 0 to 1]} ) that represents a position in the space of the axes.
     * @return {?}
     */
    /* istanbul ignore next */
    getSeriesValueFineGrainedBoundingBoxes(targetName, worldPoint) { return; }
    ;
    /**
     * If possible, will return the best available main value position of the series for a given world coordinate.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} worldPoint    The world position (in the form {x: [number from 0 to 1], y: [number from 0 to 1]} ) that represents a position in the space of the axes.
     * @param {?} useInterpolation    If true, interpolation should be used to get in-between values, rather than only the actual values in the data set.
     * @param {?} skipUnknowns    If true, unknown values should be skipped.
     * @return {?}
     */
    /* istanbul ignore next */
    getSeriesValuePosition(targetName, worldPoint, useInterpolation, skipUnknowns) { return; }
    ;
    /**
     * If possible, will return the best available main value position of the series for a given world coordinate.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} seriesPoint    The series pixel position (in the form {x: [number], y: [number]} that represents a position within the pixel space of the series.
     * @param {?} useInterpolation    If true, interpolation should be used to get in-between values, rather than only the actual values in the data set.
     * @param {?} skipUnknowns    If true, unknown values should be skipped.
     * @return {?}
     */
    /* istanbul ignore next */
    getSeriesValuePositionFromSeriesPixel(targetName, seriesPoint, useInterpolation, skipUnknowns) { return; }
    ;
    /**
     * If possible, will return the best available main value of the series for a given world coordinate.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} seriesPoint    The series pixel position (in the form {x: [number], y: [number]} ) that represents a position in the pixel space of the series.
     * @param {?} useInterpolation    If true, interpolation should be used to get in-between values, rather than only the actual values in the data set.
     * @param {?} skipUnknowns    If true, unknown values should be skipped.
     * @return {?}
     */
    /* istanbul ignore next */
    getSeriesValueFromSeriesPixel(targetName, seriesPoint, useInterpolation, skipUnknowns) { return; }
    ;
    /**
     * If possible, will return the best available value bounding box within the series that has the best value match for the given series pixel coordinate.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} seriesPoint    The series pixel position (in the form {x: [number], y: [number]} ) that represents a position in the pixel space of the series.
     * @return {?}
     */
    /* istanbul ignore next */
    getSeriesValueBoundingBoxFromSeriesPixel(targetName, seriesPoint) { return; }
    ;
    /**
     * If possible, will return the best available value fine grained bounding boxes within the series that have the best value match for series pixel position provided.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} worldPoint    The series pixel position (in the form {x: [number], y: [number]} ) that represents a position in the pixel space of the series.
     * @return {?}
     */
    /* istanbul ignore next */
    getSeriesValueFineGrainedBoundingBoxesFromSeriesPixel(targetName, worldPoint) { return; }
    ;
    /**
     * If possible, will return the best available high value of the series for a given world coordinate.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} worldPoint    The world position (in the form {x: [number from 0 to 1], y: [number from 0 to 1]} ) that represents a position in the space of the axes.
     * @param {?} useInterpolation    If true, interpolation should be used to get in-between values, rather than only the actual values in the data set.
     * @param {?} skipUnknowns    If true, unknown values should be skipped.
     * @return {?}
     */
    /* istanbul ignore next */
    getSeriesHighValue(targetName, worldPoint, useInterpolation, skipUnknowns) { return; }
    ;
    /**
     * If possible, will return the best available high value position of the series for a given world coordinate.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} worldPoint    The world position (in the form {x: [number from 0 to 1], y: [number from 0 to 1]} ) that represents a position in the space of the axes.
     * @param {?} useInterpolation    If true, interpolation should be used to get in-between values, rather than only the actual values in the data set.
     * @param {?} skipUnknowns    If true, unknown values should be skipped.
     * @return {?}
     */
    /* istanbul ignore next */
    getSeriesHighValuePosition(targetName, worldPoint, useInterpolation, skipUnknowns) { return; }
    ;
    /**
     * If possible, will return the best available high value position of the series for a given world coordinate.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} seriesPoint    The series pixel position (in the form {x: [number], y: [number]} that represents a position within the pixel space of the series.
     * @param {?} useInterpolation    If true, interpolation should be used to get in-between values, rather than only the actual values in the data set.
     * @param {?} skipUnknowns    If true, unknown values should be skipped.
     * @return {?}
     */
    /* istanbul ignore next */
    getSeriesHighValuePositionFromSeriesPixel(targetName, seriesPoint, useInterpolation, skipUnknowns) { return; }
    ;
    /**
     * If possible, will return the best available high value of the series for a given world coordinate.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} seriesPoint    The series pixel position (in the form {x: [number], y: [number]} ) that represents a position in the pixel space of the series.
     * @param {?} useInterpolation    If true, interpolation should be used to get in-between values, rather than only the actual values in the data set.
     * @param {?} skipUnknowns    If true, unknown values should be skipped.
     * @return {?}
     */
    /* istanbul ignore next */
    getSeriesHighValueFromSeriesPixel(targetName, seriesPoint, useInterpolation, skipUnknowns) { return; }
    ;
    /**
     * If possible, will return the best available low value of the series for a given world coordinate.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} worldPoint    The world position (in the form {x: [number from 0 to 1], y: [number from 0 to 1]} ) that represents a position in the space of the axes.
     * @param {?} useInterpolation    If true, interpolation should be used to get in-between values, rather than only the actual values in the data set.
     * @param {?} skipUnknowns    If true, unknown values should be skipped.
     * @return {?}
     */
    /* istanbul ignore next */
    getSeriesLowValue(targetName, worldPoint, useInterpolation, skipUnknowns) { return; }
    ;
    /**
     * If possible, will return the best available low value position of the series for a given world coordinate.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} worldPoint    The world position (in the form {x: [number from 0 to 1], y: [number from 0 to 1]} ) that represents a position in the space of the axes.
     * @param {?} useInterpolation    If true, interpolation should be used to get in-between values, rather than only the actual values in the data set.
     * @param {?} skipUnknowns    If true, unknown values should be skipped.
     * @return {?}
     */
    /* istanbul ignore next */
    getSeriesLowValuePosition(targetName, worldPoint, useInterpolation, skipUnknowns) { return; }
    ;
    /**
     * If possible, will return the best available low value position of the series for a given world coordinate.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} seriesPoint    The series pixel position (in the form {x: [number], y: [number]} that represents a position within the pixel space of the series.
     * @param {?} useInterpolation    If true, interpolation should be used to get in-between values, rather than only the actual values in the data set.
     * @param {?} skipUnknowns    If true, unknown values should be skipped.
     * @return {?}
     */
    /* istanbul ignore next */
    getSeriesLowValuePositionFromSeriesPixel(targetName, seriesPoint, useInterpolation, skipUnknowns) { return; }
    ;
    /**
     * If possible, will return the best available low value of the series for a given world coordinate.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} seriesPoint    The series pixel position (in the form {x: [number], y: [number]} ) that represents a position in the pixel space of the series.
     * @param {?} useInterpolation    If true, interpolation should be used to get in-between values, rather than only the actual values in the data set.
     * @param {?} skipUnknowns    If true, unknown values should be skipped.
     * @return {?}
     */
    /* istanbul ignore next */
    getSeriesLowValueFromSeriesPixel(targetName, seriesPoint, useInterpolation, skipUnknowns) { return; }
    ;
    /**
     * Gets the item item index associated with the specified series pixel coordinate.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} seriesPoint    The world position (in the form {x: [number from 0 to 1], y: [number from 0 to 1]} ) that represents a position in the space of the axes.
     * @return {?}
     */
    /* istanbul ignore next */
    getItemIndexFromSeriesPixel(targetName, seriesPoint) { return; }
    ;
    /**
     * Gets the item that is the best match for the specified world coordinates.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} seriesPoint    The series pixel position (in the form {x: [number], y: [number]} ) that represents a position in the pixel space of the series.
     * @return {?}
     */
    /* istanbul ignore next */
    getItemFromSeriesPixel(targetName, seriesPoint) { return; }
    ;
    /**
     * Gets the category offset for a series, if applicable.
     *
     * @param {?} targetName    The name of the series to target.
     * @return {?}
     */
    /* istanbul ignore next */
    getSeriesOffsetValue(targetName) { return; }
    ;
    /**
     * Gets the category width for a series, if applicable.
     *
     * @param {?} targetName    The name of the series to target.
     * @return {?}
     */
    /* istanbul ignore next */
    getSeriesCategoryWidth(targetName) { return; }
    ;
    /**
     * Replays the transition in animation for a series, if applicable.
     *
     * @param {?} targetName    The name of the series to target.
     * @return {?}
     */
    /* istanbul ignore next */
    replayTransitionIn(targetName) { return; }
    ;
    /**
     * Simulates a hover interaction over a given point in the viewport of a series.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} seriesPoint    The point at which to hover. Should have an x property with type number and a y property with type number.
     * @return {?}
     */
    /* istanbul ignore next */
    simulateHover(targetName, seriesPoint) { return; }
    ;
    /**
     * Moves the cursor point of the target annotation layer to the desired world coordinates.
     *
     * @param {?} targetName    The name of the series to target.
     * @param {?} worldPoint    The point to which to move the cursor. Should have an x property with type number and a y property with type number.
     * @return {?}
     */
    /* istanbul ignore next */
    moveCursorPoint(targetName, worldPoint) { return; }
    ;
    /**
     * Manually starts a tiled zoom if one isn't already running.
     * @return {?}
     */
    /* istanbul ignore next */
    startTiledZoomingIfNecessary() { return; }
    ;
    /**
     * Manually ends a tiled zoom if one is running.
     * @return {?}
     */
    /* istanbul ignore next */
    endTiledZoomingIfRunning() { return; }
    ;
    /**
     * Clears the tile zoom tile cache so that new tiles will be generated. Only applies if the viewer is using a tile based zoom.
     * @return {?}
     */
    /* istanbul ignore next */
    clearTileZoomCache() { return; }
    ;
}
IgDataChartComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-data-chart",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "isPagePanningAllowed", "syncChannel", "synchronizeVertically", "synchronizeHorizontally", "crosshairPoint", "windowRect", "horizontalZoomable", "verticalZoomable", "windowResponse", "windowRectMinWidth", "overviewPlusDetailPaneVisibility", "crosshairVisibility", "plotAreaBackground", "defaultInteraction", "dragModifier", "panModifier", "previewRect", "windowPositionHorizontal", "windowPositionVertical", "windowScaleHorizontal", "windowScaleVertical", "circleMarkerTemplate", "triangleMarkerTemplate", "pyramidMarkerTemplate", "squareMarkerTemplate", "diamondMarkerTemplate", "pentagonMarkerTemplate", "hexagonMarkerTemplate", "tetragramMarkerTemplate", "pentagramMarkerTemplate", "hexagramMarkerTemplate", "topMargin", "leftMargin", "rightMargin", "bottomMargin", "autoMarginWidth", "autoMarginHeight", "isSquare", "gridMode", "brushes", "markerBrushes", "outlines", "markerOutlines", "width", "height", "size", "dataSource", "dataSourceUrl", "dataSourceType", "responseDataKey", "isSurfaceInteractionDisabled", "animateSeriesWhenAxisRangeChanges", "title", "subtitle", "titleTextStyle", "titleTopMargin", "titleLeftMargin", "titleRightMargin", "titleBottomMargin", "subtitleTextStyle", "subtitleTopMargin", "subtitleLeftMargin", "subtitleRightMargin", "subtitleBottomMargin", "titleTextColor", "subtitleTextColor", "titleHorizontalAlignment", "subtitleHorizontalAlignment", "highlightingTransitionDuration", "useTiledZooming", "preferHigherResolutionTiles", "pixelScalingRatio", "zoomTileCacheSize", "contentHitTestMode", "legend", "axes", "series", "theme"],
                outputs: ["tooltipShowing", "tooltipShown", "tooltipHiding", "tooltipHidden", "browserNotSupported", "seriesCursorMouseMove", "seriesMouseLeftButtonDown", "seriesMouseLeftButtonUp", "seriesMouseMove", "seriesMouseEnter", "seriesMouseLeave", "windowRectChanged", "gridAreaRectChanged", "refreshCompleted", "axisRangeChanged", "typicalBasedOn", "progressiveLoadStatusChanged", "assigningCategoryStyle", "assigningCategoryMarkerStyle"]
            }] }
];
/** @nocollapse */
IgDataChartComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];
IgDataChartComponent.propDecorators = {
    dataSource: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    IgDataChartComponent.prototype._dataSource;
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWdkYXRhY2hhcnQuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vaWduaXRldWktYW5ndWxhci13cmFwcGVycy8iLCJzb3VyY2VzIjpbImxpYi9pZ2RhdGFjaGFydC9pZ2RhdGFjaGFydC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxlQUFlLEVBQUUsZUFBZSxFQUFFLGlCQUFpQixFQUFFLEtBQUssRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUM1SCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sZ0NBQWdDLENBQUM7QUFRL0QsTUFBTSxPQUFPLG9CQUFxQixTQUFRLGFBQTBCOzs7Ozs7OztJQUNoRSxZQUFZLEVBQWMsRUFBRSxRQUFrQixFQUFFLE9BQXdCLEVBQUUsV0FBNEIsRUFBRSxHQUFzQixJQUFJLEtBQUssQ0FBQyxFQUFFLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxXQUFXLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDOzs7OztJQUduTCxJQUNXLFVBQVUsQ0FBQyxLQUFVO1FBQzVCLElBQUksQ0FBQyxXQUFXLEdBQUcsS0FBSyxDQUFDOztjQUNuQixLQUFLLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQztRQUNyRCxJQUFJLEtBQUssRUFBRTtZQUNQLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLFFBQVEsRUFBRSxZQUFZLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1NBQ2hGO0lBQ0wsQ0FBQztJQUFBLENBQUM7Ozs7SUFJRixRQUFRO1FBQ0osSUFBSSxJQUFJLENBQUMsV0FBVyxLQUFLLElBQUksSUFBSSxJQUFJLENBQUMsV0FBVyxLQUFLLFNBQVMsRUFBRTtZQUM3RCxJQUFJ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QkFBcUIsRUFBRSxrQkFBa0IsRUFBRSxrQkFBa0IsRUFBRSxnQkFBZ0IsRUFBRSw4QkFBOEIsRUFBRSx3QkFBd0IsRUFBRSw4QkFBOEIsQ0FBQzthQUNuYjs7OztZQVJtQixVQUFVO1lBQUUsUUFBUTtZQUFFLGVBQWU7WUFBRSxlQUFlO1lBQUUsaUJBQWlCOzs7eUJBYXhGLEtBQUs7Ozs7Ozs7SUFTTiwyQ0FBeUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIEVsZW1lbnRSZWYsIFJlbmRlcmVyLCBJdGVyYWJsZURpZmZlcnMsIEtleVZhbHVlRGlmZmVycywgQ2hhbmdlRGV0ZWN0b3JSZWYsIElucHV0IH0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7IElnQ29udHJvbEJhc2UgfSBmcm9tIFwiLi4vaWdjb250cm9sYmFzZS9pZ2NvbnRyb2xiYXNlXCI7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiBcImlnLWRhdGEtY2hhcnRcIixcbiAgICB0ZW1wbGF0ZTogXCI8bmctY29udGVudD48L25nLWNvbnRlbnQ+XCIsXG4gICAgaW5wdXRzOiBbXCJ3aWRnZXRJZFwiLCBcIm9wdGlvbnNcIiwgXCJjaGFuZ2VEZXRlY3Rpb25JbnRlcnZhbFwiLCBcImRpc2FibGVkXCIsIFwiY3JlYXRlXCIsIFwiaXNQYWdlUGFubmluZ0FsbG93ZWRcIiwgXCJzeW5jQ2hhbm5lbFwiLCBcInN5bmNocm9uaXplVmVydGljYWxseVwiLCBcInN5bmNocm9uaXplSG9yaXpvbnRhbGx5XCIsIFwiY3Jvc3NoYWlyUG9pbnRcIiwgXCJ3aW5kb3dSZWN0XCIsIFwiaG9yaXpvbnRhbFpvb21hYmxlXCIsIFwidmVydGljYWxab29tYWJsZVwiLCBcIndpbmRvd1Jlc3BvbnNlXCIsIFwid2luZG93UmVjdE1pbldpZHRoXCIsIFwib3ZlcnZpZXdQbHVzRGV0YWlsUGFuZVZpc2liaWxpdHlcIiwgXCJjcm9zc2hhaXJWaXNpYmlsaXR5XCIsIFwicGxvdEFyZWFCYWNrZ3JvdW5kXCIsIFwiZGVmYXVsdEludGVyYWN0aW9uXCIsIFwiZHJhZ01vZGlmaWVyXCIsIFwicGFuTW9kaWZpZXJcIiwgXCJwcmV2aWV3UmVjdFwiLCBcIndpbmRvd1Bvc2l0aW9uSG9yaXpvbnRhbFwiLCBcIndpbmRvd1Bvc2l0aW9uVmVydGljYWxcIiwgXCJ3aW5kb3dTY2FsZUhvcml6b250YWxcIiwgXCJ3aW5kb3dTY2FsZVZlcnRpY2FsXCIsIFwiY2lyY2xlTWFya2VyVGVtcGxhdGVcIiwgXCJ0cmlhbmdsZU1hcmtlclRlbXBsYXRlXCIsIFwicHlyYW1pZE1hcmtlclRlbXBsYXRlXCIsIFwic3F1YXJlTWFya2VyVGVtcGxhdGVcIiwgXCJkaWFtb25kTWFya2VyVGVtcGxhdGVcIiwgXCJwZW50YWdvbk1hcmtlclRlbXBsYXRlXCIsIFwiaGV4YWdvbk1hcmtlclRlbXBsYXRlXCIsIFwidGV0cmFncmFtTWFya2VyVGVtcGxhdGVcIiwgXCJwZW50YWdyYW1NYXJrZXJUZW1wbGF0ZVwiLCBcImhleGFncmFtTWFya2VyVGVtcGxhdGVcIiwgXCJ0b3BNYXJnaW5cIiwgXCJsZWZ0TWFyZ2luXCIsIFwicmlnaHRNYXJnaW5cIiwgXCJib3R0b21NYXJnaW5cIiwgXCJhdXRvTWFyZ2luV2lkdGhcIiwgXCJhdXRvTWFyZ2luSGVpZ2h0XCIsIFwiaXNTcXVhcmVcIiwgXCJncmlkTW9kZVwiLCBcImJydXNoZXNcIiwgXCJtYXJrZXJCcnVzaGVzXCIsIFwib3V0bGluZXNcIiwgXCJtYXJrZXJPdXRsaW5lc1wiLCBcIndpZHRoXCIsIFwiaGVpZ2h0XCIsIFwic2l6ZVwiLCBcImRhdGFTb3VyY2VcIiwgXCJkYXRhU291cmNlVXJsXCIsIFwiZGF0YVNvdXJjZVR5cGVcIiwgXCJyZXNwb25zZURhdGFLZXlcIiwgXCJpc1N1cmZhY2VJbnRlcmFjdGlvbkRpc2FibGVkXCIsIFwiYW5pbWF0ZVNlcmllc1doZW5BeGlzUmFuZ2VDaGFuZ2VzXCIsIFwidGl0bGVcIiwgXCJzdWJ0aXRsZVwiLCBcInRpdGxlVGV4dFN0eWxlXCIsIFwidGl0bGVUb3BNYXJnaW5cIiwgXCJ0aXRsZUxlZnRNYXJnaW5cIiwgXCJ0aXRsZVJpZ2h0TWFyZ2luXCIsIFwidGl0bGVCb3R0b21NYXJnaW5cIiwgXCJzdWJ0aXRsZVRleHRTdHlsZVwiLCBcInN1YnRpdGxlVG9wTWFyZ2luXCIsIFwic3VidGl0bGVMZWZ0TWFyZ2luXCIsIFwic3VidGl0bGVSaWdodE1hcmdpblwiLCBcInN1YnRpdGxlQm90dG9tTWFyZ2luXCIsIFwidGl0bGVUZXh0Q29sb3JcIiwgXCJzdWJ0aXRsZVRleHRDb2xvclwiLCBcInRpdGxlSG9yaXpvbnRhbEFsaWdubWVudFwiLCBcInN1YnRpdGxlSG9yaXpvbnRhbEFsaWdubWVudFwiLCBcImhpZ2hsaWdodGluZ1RyYW5zaXRpb25EdXJhdGlvblwiLCBcInVzZVRpbGVkWm9vbWluZ1wiLCBcInByZWZlckhpZ2hlclJlc29sdXRpb25UaWxlc1wiLCBcInBpeGVsU2NhbGluZ1JhdGlvXCIsIFwiem9vbVRpbGVDYWNoZVNpemVcIiwgXCJjb250ZW50SGl0VGVzdE1vZGVcIiwgXCJsZWdlbmRcIiwgXCJheGVzXCIsIFwic2VyaWVzXCIsIFwidGhlbWVcIl0sXG4gICAgb3V0cHV0czogW1widG9vbHRpcFNob3dpbmdcIiwgXCJ0b29sdGlwU2hvd25cIiwgXCJ0b29sdGlwSGlkaW5nXCIsIFwidG9vbHRpcEhpZGRlblwiLCBcImJyb3dzZXJOb3RTdXBwb3J0ZWRcIiwgXCJzZXJpZXNDdXJzb3JNb3VzZU1vdmVcIiwgXCJzZXJpZXNNb3VzZUxlZnRCdXR0b25Eb3duXCIsIFwic2VyaWVzTW91c2VMZWZ0QnV0dG9uVXBcIiwgXCJzZXJpZXNNb3VzZU1vdmVcIiwgXCJzZXJpZXNNb3VzZUVudGVyXCIsIFwic2VyaWVzTW91c2VMZWF2ZVwiLCBcIndpbmRvd1JlY3RDaGFuZ2VkXCIsIFwiZ3JpZEFyZWFSZWN0Q2hhbmdlZFwiLCBcInJlZnJlc2hDb21wbGV0ZWRcIiwgXCJheGlzUmFuZ2VDaGFuZ2VkXCIsIFwidHlwaWNhbEJhc2VkT25cIiwgXCJwcm9ncmVzc2l2ZUxvYWRTdGF0dXNDaGFuZ2VkXCIsIFwiYXNzaWduaW5nQ2F0ZWdvcnlTdHlsZVwiLCBcImFzc2lnbmluZ0NhdGVnb3J5TWFya2VyU3R5bGVcIl1cbn0pXG5leHBvcnQgY2xhc3MgSWdEYXRhQ2hhcnRDb21wb25lbnQgZXh0ZW5kcyBJZ0NvbnRyb2xCYXNlPElnRGF0YUNoYXJ0PiB7XG4gICAgY29uc3RydWN0b3IoZWw6IEVsZW1lbnRSZWYsIHJlbmRlcmVyOiBSZW5kZXJlciwgZGlmZmVyczogSXRlcmFibGVEaWZmZXJzLCBrdmFsRGlmZmVyczogS2V5VmFsdWVEaWZmZXJzLCBjZHI6IENoYW5nZURldGVjdG9yUmVmKSB7IHN1cGVyKGVsLCByZW5kZXJlciwgZGlmZmVycywga3ZhbERpZmZlcnMsIGNkcik7IH1cblxuXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2V0IGRhdGFTb3VyY2UodmFsdWU6IGFueSkge1xuICAgICAgICB0aGlzLl9kYXRhU291cmNlID0gdmFsdWU7XG4gICAgICAgIGNvbnN0IGNoYXJ0ID0galF1ZXJ5KHRoaXMuX2VsKS5kYXRhKHRoaXMuX3dpZGdldE5hbWUpO1xuICAgICAgICBpZiAoY2hhcnQpIHtcbiAgICAgICAgICAgIGpRdWVyeSh0aGlzLl9lbClbdGhpcy5fd2lkZ2V0TmFtZV0oXCJvcHRpb25cIiwgXCJkYXRhU291cmNlXCIsIHRoaXMuX2RhdGFTb3VyY2UpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByaXZhdGUgX2RhdGFTb3VyY2U6IGFueTtcblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBpZiAodGhpcy5fZGF0YVNvdXJjZSA9PT0gbnVsbCB8fCB0aGlzLl9kYXRhU291cmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGFTb3VyY2UgPSB0aGlzLm9wdGlvbnNbXCJkYXRhU291cmNlXCJdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zW1wiZGF0YVNvdXJjZVwiXSAmJiB0aGlzLl9kYXRhU291cmNlKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNbXCJkYXRhU291cmNlXCJdID0gdGhpcy5fZGF0YVNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBvcHRpb24oKTogdm9pZCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGVsZW1lbnQgaG9sZGluZyB0aGUgY2hhcnQuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgd2lkZ2V0KCk6IHZvaWQgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBJRCBvZiBwYXJlbnQgZWxlbWVudCBob2xkaW5nIHRoZSBjaGFydC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBpZCgpOiBzdHJpbmcgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBFeHBvcnRzIHRoZSBjaGFydCB0byBhIFBORyBpbWFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3aWR0aCAgICAgVGhlIHdpZHRoIG9mIHRoZSBpbWFnZS5cbiAgICAgKiBAcGFyYW0gaGVpZ2h0ICAgICBUaGUgaGVpZ2h0IG9mIHRoZSBpbWFnZS5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBleHBvcnRJbWFnZSh3aWR0aD86IE9iamVjdCwgaGVpZ2h0PzogT2JqZWN0KTogT2JqZWN0IHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhlIHdpZGdldC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBkZXN0cm95KCk6IHZvaWQgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBOb3RpZnkgdGhlIGNoYXJ0IHRoYXQgc3R5bGVzIGl0IGRyYXdzIGNvbG9ycyBmcm9tIG1heSBoYXZlIGJlZW4gdXBkYXRlZC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBzdHlsZVVwZGF0ZWQoKTogT2JqZWN0IHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSB6b29tIGxldmVsIG9mIHRoZSBjaGFydCB0byBkZWZhdWx0LlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIHJlc2V0Wm9vbSgpOiBPYmplY3QgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IGl0ZW0gdG8gdGhlIGRhdGEgc291cmNlIGFuZCBub3RpZmllcyB0aGUgY2hhcnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaXRlbSAgICAgVGhlIGl0ZW0gdGhhdCB3ZSB3YW50IHRvIGFkZCB0byB0aGUgZGF0YSBzb3VyY2UuXG4gICAgICogQHBhcmFtIHRhcmdldE5hbWUgICAgIFRoZSBuYW1lIG9mIHRoZSBzZXJpZXMgb3IgYXhpcyBib3VuZCB0byB0aGUgZGF0YSBzb3VyY2UuIFRoaXMgaXMgcmVxdWlyZWQgb25seSB3aGVuIHRoZSBkYXRhIGlzIGJvdW5kIHRvIHNlcmllcyBvciBheGlzLiBJZiB0aGUgZGF0YSBpcyBib3VuZCB0byBkYXRhU291cmNlIG9mIGlnRGF0YUNoYXJ0LCB0aGUgc2Vjb25kIHBhcmFtZXRlciBzaG91bGQgbm90IGJlIHNldC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBhZGRJdGVtKGl0ZW06IE9iamVjdCwgdGFyZ2V0TmFtZTogc3RyaW5nKTogdm9pZCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIEluc2VydHMgYSBuZXcgaXRlbSB0byB0aGUgZGF0YSBzb3VyY2UgYW5kIG5vdGlmaWVzIHRoZSBjaGFydC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpdGVtICAgICB0aGUgbmV3IGl0ZW0gdGhhdCB3ZSB3YW50IHRvIGluc2VydCBpbiB0aGUgZGF0YSBzb3VyY2UuXG4gICAgICogQHBhcmFtIGluZGV4ICAgICBUaGUgaW5kZXggaW4gdGhlIGRhdGEgc291cmNlIHdoZXJlIHRoZSBuZXcgaXRlbSB3aWxsIGJlIGluc2VydGVkLlxuICAgICAqIEBwYXJhbSB0YXJnZXROYW1lICAgICBUaGUgbmFtZSBvZiB0aGUgc2VyaWVzIG9yIGF4aXMgYm91bmQgdG8gdGhlIGRhdGEgc291cmNlLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGluc2VydEl0ZW0oaXRlbTogT2JqZWN0LCBpbmRleDogbnVtYmVyLCB0YXJnZXROYW1lOiBzdHJpbmcpOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhbiBpdGVtIGZyb20gdGhlIGRhdGEgc291cmNlIGFuZCBub3RpZmllcyB0aGUgY2hhcnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kZXggICAgIFRoZSBpbmRleCBpbiB0aGUgZGF0YSBzb3VyY2UgZnJvbSB3aGVyZSB0aGUgaXRlbSB3aWxsIGJlIGJlZW4gcmVtb3ZlZC5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0TmFtZSAgICAgVGhlIG5hbWUgb2YgdGhlIHNlcmllcyBvciBheGlzIGJvdW5kIHRvIHRoZSBkYXRhIHNvdXJjZS4gVGhpcyBpcyByZXF1aXJlZCBvbmx5IHdoZW4gdGhlIGRhdGEgaXMgYm91bmQgdG8gc2VyaWVzIG9yIGF4aXMuIElmIHRoZSBkYXRhIGlzIGJvdW5kIHRvIGRhdGFTb3VyY2Ugb2YgaWdEYXRhQ2hhcnQsIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHNob3VsZCBub3QgYmUgc2V0LlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIHJlbW92ZUl0ZW0oaW5kZXg6IG51bWJlciwgdGFyZ2V0TmFtZTogc3RyaW5nKTogdm9pZCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgYW4gaXRlbSBpbiB0aGUgZGF0YSBzb3VyY2UgYW5kIG5vdGlmaWVzIHRoZSBjaGFydC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmRleCAgICAgVGhlIGluZGV4IG9mIHRoZSBpdGVtIGluIHRoZSBkYXRhIHNvdXJjZSB0aGF0IHdlIHdhbnQgdG8gY2hhbmdlLlxuICAgICAqIEBwYXJhbSBpdGVtICAgICBUaGUgbmV3IGl0ZW0gb2JqZWN0IHRoYXQgd2lsbCBiZSBzZXQgaW4gdGhlIGRhdGEgc291cmNlLlxuICAgICAqIEBwYXJhbSB0YXJnZXROYW1lICAgICBUaGUgbmFtZSBvZiB0aGUgc2VyaWVzIG9yIGF4aXMgYm91bmQgdG8gdGhlIGRhdGEgc291cmNlLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIHNldEl0ZW0oaW5kZXg6IG51bWJlciwgaXRlbTogT2JqZWN0LCB0YXJnZXROYW1lOiBzdHJpbmcpOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogTm90aWZpZXMgdGhlIGNoYXJ0IHRoYXQgYW4gaXRlbSBoYXMgYmVlbiBzZXQgaW4gYW4gYXNzb2NpYXRlZCBkYXRhIHNvdXJjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhU291cmNlICAgICBUaGUgZGF0YSBzb3VyY2UgaW4gd2hpY2ggdGhlIGNoYW5nZSBoYXBwZW5lZC5cbiAgICAgKiBAcGFyYW0gaW5kZXggICAgIFRoZSBpbmRleCBpbiB0aGUgaXRlbXMgc291cmNlIHRoYXQgaGFzIGJlZW4gY2hhbmdlZC5cbiAgICAgKiBAcGFyYW0gbmV3SXRlbSAgICAgdGhlIG5ldyBpdGVtIHRoYXQgaGFzIGJlZW4gc2V0IGluIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqIEBwYXJhbSBvbGRJdGVtICAgICB0aGUgb2xkIGl0ZW0gdGhhdCBoYXMgYmVlbiBvdmVyd3JpdHRlbiBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBub3RpZnlTZXRJdGVtKGRhdGFTb3VyY2U6IE9iamVjdCwgaW5kZXg6IG51bWJlciwgbmV3SXRlbTogT2JqZWN0LCBvbGRJdGVtOiBPYmplY3QpOiBPYmplY3QgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBOb3RpZmllcyB0aGUgY2hhcnQgdGhhdCB0aGUgaXRlbXMgaGF2ZSBiZWVuIGNsZWFyZWQgZnJvbSBhbiBhc3NvY2lhdGVkIGRhdGEgc291cmNlLlxuICAgICAqIFx0XHRcdFx0SXQncyBub3QgbmVjZXNzYXJ5IHRvIG5vdGlmeSBtb3JlIHRoYW4gb25lIHRhcmdldCBvZiBhIGNoYW5nZSBpZiB0aGV5IHNoYXJlIHRoZSBzYW1lIGl0ZW1zIHNvdXJjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhU291cmNlICAgICBUaGUgZGF0YSBzb3VyY2UgaW4gd2hpY2ggdGhlIGNoYW5nZSBoYXBwZW5lZC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBub3RpZnlDbGVhckl0ZW1zKGRhdGFTb3VyY2U6IE9iamVjdCk6IE9iamVjdCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIE5vdGlmaWVzIHRoZSB0YXJnZXQgYXhpcyBvciBzZXJpZXMgdGhhdCBhbiBpdGVtIGhhcyBiZWVuIGluc2VydGVkIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXggaW4gaXRzIGRhdGEgc291cmNlLlxuICAgICAqIFx0XHRcdFx0SXQncyBub3QgbmVjZXNzYXJ5IHRvIG5vdGlmeSBtb3JlIHRoYW4gb25lIHRhcmdldCBvZiBhIGNoYW5nZSBpZiB0aGV5IHNoYXJlIHRoZSBzYW1lIGl0ZW1zIHNvdXJjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhU291cmNlICAgICBUaGUgZGF0YSBzb3VyY2UgaW4gd2hpY2ggdGhlIGNoYW5nZSBoYXBwZW5lZC5cbiAgICAgKiBAcGFyYW0gaW5kZXggICAgIFRoZSBpbmRleCBpbiB0aGUgaXRlbXMgc291cmNlIHdoZXJlIHRoZSBuZXcgaXRlbSBoYXMgYmVlbiBpbnNlcnRlZC5cbiAgICAgKiBAcGFyYW0gbmV3SXRlbSAgICAgdGhlIG5ldyBpdGVtIHRoYXQgaGFzIGJlZW4gc2V0IGluIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIG5vdGlmeUluc2VydEl0ZW0oZGF0YVNvdXJjZTogT2JqZWN0LCBpbmRleDogbnVtYmVyLCBuZXdJdGVtOiBPYmplY3QpOiBPYmplY3QgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBOb3RpZmllcyB0aGUgdGFyZ2V0IGF4aXMgb3Igc2VyaWVzIHRoYXQgYW4gaXRlbSBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIHNwZWNpZmllZCBpbmRleCBpbiBpdHMgZGF0YSBzb3VyY2UuXG4gICAgICogXHRcdFx0XHRJdCdzIG5vdCBuZWNlc3NhcnkgdG8gbm90aWZ5IG1vcmUgdGhhbiBvbmUgdGFyZ2V0IG9mIGEgY2hhbmdlIGlmIHRoZXkgc2hhcmUgdGhlIHNhbWUgaXRlbXMgc291cmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGFTb3VyY2UgICAgIFRoZSBkYXRhIHNvdXJjZSBpbiB3aGljaCB0aGUgY2hhbmdlIGhhcHBlbmVkLlxuICAgICAqIEBwYXJhbSBpbmRleCAgICAgVGhlIGluZGV4IGluIHRoZSBpdGVtcyBzb3VyY2UgZnJvbSB3aGVyZSB0aGUgb2xkIGl0ZW0gaGFzIGJlZW4gcmVtb3ZlZC5cbiAgICAgKiBAcGFyYW0gb2xkSXRlbSAgICAgdGhlIG9sZCBpdGVtIHRoYXQgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIG5vdGlmeVJlbW92ZUl0ZW0oZGF0YVNvdXJjZTogT2JqZWN0LCBpbmRleDogbnVtYmVyLCBvbGRJdGVtOiBPYmplY3QpOiBPYmplY3QgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBOb3RpZmllcyB0aGUgdGFyZ2V0IGF4aXMgb3Igc2VyaWVzIHRoYXQgaXQgc2hvdWxkIHNjcm9sbCB0aGUgcmVxdWVzdGVkIGRhdGEgaXRlbSBpbnRvIHZpZXcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGFyZ2V0TmFtZSAgICAgVGhlIG5hbWUgb2YgdGhlIGF4aXMgb3Igc2VyaWVzIG5vdGlmeS5cbiAgICAgKiBAcGFyYW0gaXRlbSAgICAgVGhlIGRhdGEgaXRlbSB0byBicmluZyBpbnRvIHZpZXcsIGlmIHBvc3NpYmxlLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIHNjcm9sbEludG9WaWV3KHRhcmdldE5hbWU6IHN0cmluZywgaXRlbTogT2JqZWN0KTogT2JqZWN0IHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogTm90aWZpZXMgdGhlIHRhcmdldCBheGlzIHRoYXQgaXQgc2hvdWxkIHNjYWxlIHRoZSByZXF1ZXN0ZWQgdmFsdWUgaW50byBjaGFydCBzcGFjZSBmcm9tIGF4aXMgc3BhY2UuXG4gICAgICogXHRcdFx0XHRGb3IgZXhhbXBsZSB5b3UgY2FuIHVzZSB0aGlzIG1ldGhvZCBpZiB5b3Ugd2FudCB0byBmaW5kIHdoZXJlIHZhbHVlIDUwIG9mIHRoZSB4IGF4aXMgc3RhbmRzIHNjYWxlZCB0byBjaGFydCdzIHdpZHRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRhcmdldE5hbWUgICAgIFRoZSBuYW1lIG9mIHRoZSBheGlzIHRvIG5vdGlmeS5cbiAgICAgKiBAcGFyYW0gdW5zY2FsZWRWYWx1ZSAgICAgVGhlIHZhbHVlIGluIGF4aXMgc3BhY2UgdG8gdHJhbnNsYXRlIGludG8gY2hhcnQgc3BhY2UuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgc2NhbGVWYWx1ZSh0YXJnZXROYW1lOiBzdHJpbmcsIHVuc2NhbGVkVmFsdWU6IG51bWJlcik6IG51bWJlciB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIE5vdGlmaWVzIHRoZSB0YXJnZXQgYXhpcyB0aGF0IGl0IHNob3VsZCB1bnNjYWxlIHRoZSByZXF1ZXN0ZWQgdmFsdWUgaW50byBheGlzIHNwYWNlIGZyb20gY2hhcnQgc3BhY2UuXG4gICAgICogXHRcdFx0XHRGb3IgZXhhbXBsZSB5b3UgY2FuIHVzZSB0aGlzIG1ldGhvZCBpZiB5b3Ugd2FudCB0byBmaW5kIHdoYXQgaXMgdGhlIHZhbHVlIG9mIHggYXhpcyB1bnNjYWxlZCBmcm9tIDAgd2lkdGggb2YgdGhlIGNoYXJ0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHRhcmdldE5hbWUgICAgIFRoZSBuYW1lIG9mIHRoZSBheGlzIHRvIG5vdGlmeS5cbiAgICAgKiBAcGFyYW0gc2NhbGVkVmFsdWUgICAgIFRoZSB2YWx1ZSBpbiBjaGFydCBzcGFjZSB0byB0cmFuc2xhdGUgaW50byBheGlzIHNwYWNlLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIHVuc2NhbGVWYWx1ZSh0YXJnZXROYW1lOiBzdHJpbmcsIHNjYWxlZFZhbHVlOiBudW1iZXIpOiBudW1iZXIgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBGb3IgdGhlIHRhcmdldCBheGlzLCBpZiB1c2luZyBlbmhhbmNlZCBpbnRlcnZhbCBtYW5hZ2VtZW50IGFuZCBwcmVjaXNlIGludGVydmFsIGZpdHRpbmcsIHRoaXMgd2lsbCByZXNldCB0aGUgY2FjaGVkIG1heGltdW0gbGFiZWwgd2lkdGgsIGFuZCByZWNhbGN1bGF0ZSB1c2luZyB0aGUgY3VycmVudCBsYWJlbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGFyZ2V0TmFtZSAgICAgVGhlIG5hbWUgb2YgdGhlIGF4aXMgdG8gbm90aWZ5LlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIHJlc2V0Q2FjaGVkRW5oYW5jZWRJbnRlcnZhbCh0YXJnZXROYW1lOiBzdHJpbmcpOiBPYmplY3QgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBOb3RpZmllcyB0aGUgdGFyZ2V0IHNlcmllcyB0aGF0IHNvbWV0aGluZyB0aGF0IGFmZmVjdHMgaXRzIHZpc3VhbCBwcm9wZXJ0aWVzIGhhcyBjaGFuZ2VkIGFuZCB0aGUgdmlzdWFsIG91dHB1dCBuZWVkcyBhIHJlcGFpbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGFyZ2V0TmFtZSAgICAgVGhlIG5hbWUgb2YgdGhlIHNlcmllcyB0byBub3RpZnkuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgbm90aWZ5VmlzdWFsUHJvcGVydGllc0NoYW5nZWQodGFyZ2V0TmFtZTogc3RyaW5nKTogT2JqZWN0IHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogRm9yY2VzIGFueSBwZW5kaW5nIGRlZmVycmVkIHdvcmsgdG8gcmVuZGVyIG9uIHRoZSBjaGFydCBiZWZvcmUgY29udGludWluZ1xuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGZsdXNoKCk6IHZvaWQgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBFeHBvcnRzIHZpc3VhbCBkYXRhIGZyb20gdGhlIGNoYXJ0IHRvIGFpZCBpbiB1bml0IHRlc3RpbmdcbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBleHBvcnRWaXN1YWxEYXRhKCk6IHZvaWQgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBhY3R1YWwgbWluaW11bSB2YWx1ZSBvZiB0aGUgdGFyZ2V0IG51bWVyaWMgb3IgZGF0ZSB0aW1lIGF4aXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0YXJnZXROYW1lICAgIFRoZSBuYW1lIG9mIHRoZSBheGlzIGZyb20gd2hpY2ggdG8gZ2V0IHRoZSBtaW5pbXVtIHZhbHVlLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGdldEFjdHVhbE1pbmltdW1WYWx1ZSh0YXJnZXROYW1lOiBzdHJpbmcpOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYWN0dWFsIG1heGltdW0gdmFsdWUgb2YgdGhlIHRhcmdldCBudW1lcmljIG9yIGRhdGUgdGltZSBheGlzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGFyZ2V0TmFtZSAgICBUaGUgbmFtZSBvZiB0aGUgYXhpcyBmcm9tIHdoaWNoIHRvIGdldCB0aGUgbWF4aW11bSB2YWx1ZS5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBnZXRBY3R1YWxNYXhpbXVtVmFsdWUodGFyZ2V0TmFtZTogc3RyaW5nKTogdm9pZCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFjdHVhbCBpbnRlcnZhbCBvZiB0aGUgdGFyZ2V0IG51bWVyaWMgb3IgZGF0ZSB0aW1lIGF4aXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0YXJnZXROYW1lICAgIFRoZSBuYW1lIG9mIHRoZSBheGlzIGZyb20gd2hpY2ggdG8gZ2V0IHRoZSBpbnRlcnZhbC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBnZXRBY3R1YWxJbnRlcnZhbCh0YXJnZXROYW1lOiBzdHJpbmcpOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHByaW50IHByZXZpZXcgcGFnZSB3aXRoIHRoZSBjaGFydCwgaGlkaW5nIGFsbCBvdGhlciBlbGVtZW50cyBvbiB0aGUgcGFnZS5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBwcmludCgpOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgYSBzZXJpZXMgc2hvdWxkIHJlbmRlciwgZXZlbiB0aG91Z2ggbm8gb3B0aW9uIGhhcyBiZWVuIG1vZGlmaWVkIHRoYXQgd291bGQgbm9ybWFsbHkgY2F1c2UgaXQgdG8gcmVmcmVzaC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0YXJnZXROYW1lICAgICBUaGUgbmFtZSBvZiB0aGUgc2VyaWVzIHRvIHJlbmRlci5cbiAgICAgKiBAcGFyYW0gYW5pbWF0ZSAgICAgV2hldGhlciB0aGUgY2hhbmdlIHNob3VsZCBiZSBhbmltYXRlZCwgaWYgcG9zc2libGUuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgcmVuZGVyU2VyaWVzKHRhcmdldE5hbWU6IHN0cmluZywgYW5pbWF0ZTogYm9vbGVhbik6IHZvaWQgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpdGVtIGl0ZW0gaW5kZXggYXNzb2NpYXRlZCB3aXRoIHRoZSBzcGVjaWZpZWQgd29ybGQgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGFyZ2V0TmFtZSAgICBUaGUgbmFtZSBvZiB0aGUgc2VyaWVzIHRvIHRhcmdldC5cbiAgICAgKiBAcGFyYW0gd29ybGRQb2ludCAgICBUaGUgd29ybGQgcG9zaXRpb24gKGluIHRoZSBmb3JtIHt4OiBbbnVtYmVyIGZyb20gMCB0byAxXSwgeTogW251bWJlciBmcm9tIDAgdG8gMV19ICkgdGhhdCByZXByZXNlbnRzIGEgcG9zaXRpb24gaW4gdGhlIHNwYWNlIG9mIHRoZSBheGVzLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGdldEl0ZW1JbmRleCh0YXJnZXROYW1lOiBzdHJpbmcsIHdvcmxkUG9pbnQ6IE9iamVjdCk6IG51bWJlciB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGl0ZW0gdGhhdCBpcyB0aGUgYmVzdCBtYXRjaCBmb3IgdGhlIHNwZWNpZmllZCB3b3JsZCBjb29yZGluYXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0YXJnZXROYW1lICAgIFRoZSBuYW1lIG9mIHRoZSBzZXJpZXMgdG8gdGFyZ2V0LlxuICAgICAqIEBwYXJhbSB3b3JsZFBvaW50ICAgIFRoZSB3b3JsZCBwb3NpdGlvbiAoaW4gdGhlIGZvcm0ge3g6IFtudW1iZXIgZnJvbSAwIHRvIDFdLCB5OiBbbnVtYmVyIGZyb20gMCB0byAxXX0gKSB0aGF0IHJlcHJlc2VudHMgYSBwb3NpdGlvbiBpbiB0aGUgc3BhY2Ugb2YgdGhlIGF4ZXMuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgZ2V0SXRlbSh0YXJnZXROYW1lOiBzdHJpbmcsIHdvcmxkUG9pbnQ6IE9iamVjdCk6IE9iamVjdCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIEZvciBhIGNhdGVnb3J5IHBsb3R0ZWQgc2VyaWVzLCBnZXRzIHRoZSBjdXJyZW50IHdpZHRoIG9mIHRoZSBpdGVtcyB3aXRoaW4gdGhlIGNhdGVnb3JpZXMuIFRoaXMgb25seSByZXR1cm5zIGEgdmFsdWUgaWYgdGhlIGl0ZW1zIGhhdmUgc29tZSBmb3JtIG9mIHdpZHRoIChlLmcuIGNvbHVtbnMsIGJhcnMsIGV0Yy4pIG90aGVyd2lzZSAwIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRhcmdldE5hbWUgICAgVGhlIG5hbWUgb2YgdGhlIHNlcmllcyB0byB0YXJnZXQuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgZ2V0SXRlbVNwYW4odGFyZ2V0TmFtZTogc3RyaW5nKTogbnVtYmVyIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogSWYgcG9zc2libGUsIHdpbGwgcmV0dXJuIHRoZSBiZXN0IGF2YWlsYWJsZSBtYWluIHZhbHVlIG9mIHRoZSBzZXJpZXMgZm9yIGEgZ2l2ZW4gd29ybGQgY29vcmRpbmF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0YXJnZXROYW1lICAgIFRoZSBuYW1lIG9mIHRoZSBzZXJpZXMgdG8gdGFyZ2V0LlxuICAgICAqIEBwYXJhbSB3b3JsZFBvaW50ICAgIFRoZSB3b3JsZCBwb3NpdGlvbiAoaW4gdGhlIGZvcm0ge3g6IFtudW1iZXIgZnJvbSAwIHRvIDFdLCB5OiBbbnVtYmVyIGZyb20gMCB0byAxXX0gKSB0aGF0IHJlcHJlc2VudHMgYSBwb3NpdGlvbiBpbiB0aGUgc3BhY2Ugb2YgdGhlIGF4ZXMuXG4gICAgICogQHBhcmFtIHVzZUludGVycG9sYXRpb24gICAgSWYgdHJ1ZSwgaW50ZXJwb2xhdGlvbiBzaG91bGQgYmUgdXNlZCB0byBnZXQgaW4tYmV0d2VlbiB2YWx1ZXMsIHJhdGhlciB0aGFuIG9ubHkgdGhlIGFjdHVhbCB2YWx1ZXMgaW4gdGhlIGRhdGEgc2V0LlxuICAgICAqIEBwYXJhbSBza2lwVW5rbm93bnMgICAgSWYgdHJ1ZSwgdW5rbm93biB2YWx1ZXMgc2hvdWxkIGJlIHNraXBwZWQuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgZ2V0U2VyaWVzVmFsdWUodGFyZ2V0TmFtZTogc3RyaW5nLCB3b3JsZFBvaW50OiBPYmplY3QsIHVzZUludGVycG9sYXRpb246IGJvb2xlYW4sIHNraXBVbmtub3duczogYm9vbGVhbik6IG51bWJlciB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIElmIHBvc3NpYmxlLCB3aWxsIHJldHVybiB0aGUgYmVzdCBhdmFpbGFibGUgdmFsdWUgYm91bmRpbmcgYm94IHdpdGhpbiB0aGUgc2VyaWVzIHRoYXQgaGFzIHRoZSBiZXN0IHZhbHVlIG1hdGNoIGZvciB0aGUgd29ybGQgcG9zaXRpb24gcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGFyZ2V0TmFtZSAgICBUaGUgbmFtZSBvZiB0aGUgc2VyaWVzIHRvIHRhcmdldC5cbiAgICAgKiBAcGFyYW0gd29ybGRQb2ludCAgICBUaGUgd29ybGQgcG9zaXRpb24gKGluIHRoZSBmb3JtIHt4OiBbbnVtYmVyIGZyb20gMCB0byAxXSwgeTogW251bWJlciBmcm9tIDAgdG8gMV19ICkgdGhhdCByZXByZXNlbnRzIGEgcG9zaXRpb24gaW4gdGhlIHNwYWNlIG9mIHRoZSBheGVzLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGdldFNlcmllc1ZhbHVlQm91bmRpbmdCb3godGFyZ2V0TmFtZTogc3RyaW5nLCB3b3JsZFBvaW50OiBPYmplY3QpOiBPYmplY3QgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBJZiBwb3NzaWJsZSwgd2lsbCByZXR1cm4gdGhlIGJlc3QgYXZhaWxhYmxlIHZhbHVlIGZpbmUgZ3JhaW5lZCBib3VuZGluZyBib3hlcyB3aXRoaW4gdGhlIHNlcmllcyB0aGF0IGhhdmUgdGhlIGJlc3QgdmFsdWUgbWF0Y2ggZm9yIHRoZSB3b3JsZCBwb3NpdGlvbiBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0YXJnZXROYW1lICAgIFRoZSBuYW1lIG9mIHRoZSBzZXJpZXMgdG8gdGFyZ2V0LlxuICAgICAqIEBwYXJhbSB3b3JsZFBvaW50ICAgIFRoZSB3b3JsZCBwb3NpdGlvbiAoaW4gdGhlIGZvcm0ge3g6IFtudW1iZXIgZnJvbSAwIHRvIDFdLCB5OiBbbnVtYmVyIGZyb20gMCB0byAxXX0gKSB0aGF0IHJlcHJlc2VudHMgYSBwb3NpdGlvbiBpbiB0aGUgc3BhY2Ugb2YgdGhlIGF4ZXMuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgZ2V0U2VyaWVzVmFsdWVGaW5lR3JhaW5lZEJvdW5kaW5nQm94ZXModGFyZ2V0TmFtZTogc3RyaW5nLCB3b3JsZFBvaW50OiBPYmplY3QpOiBPYmplY3QgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBJZiBwb3NzaWJsZSwgd2lsbCByZXR1cm4gdGhlIGJlc3QgYXZhaWxhYmxlIG1haW4gdmFsdWUgcG9zaXRpb24gb2YgdGhlIHNlcmllcyBmb3IgYSBnaXZlbiB3b3JsZCBjb29yZGluYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRhcmdldE5hbWUgICAgVGhlIG5hbWUgb2YgdGhlIHNlcmllcyB0byB0YXJnZXQuXG4gICAgICogQHBhcmFtIHdvcmxkUG9pbnQgICAgVGhlIHdvcmxkIHBvc2l0aW9uIChpbiB0aGUgZm9ybSB7eDogW251bWJlciBmcm9tIDAgdG8gMV0sIHk6IFtudW1iZXIgZnJvbSAwIHRvIDFdfSApIHRoYXQgcmVwcmVzZW50cyBhIHBvc2l0aW9uIGluIHRoZSBzcGFjZSBvZiB0aGUgYXhlcy5cbiAgICAgKiBAcGFyYW0gdXNlSW50ZXJwb2xhdGlvbiAgICBJZiB0cnVlLCBpbnRlcnBvbGF0aW9uIHNob3VsZCBiZSB1c2VkIHRvIGdldCBpbi1iZXR3ZWVuIHZhbHVlcywgcmF0aGVyIHRoYW4gb25seSB0aGUgYWN0dWFsIHZhbHVlcyBpbiB0aGUgZGF0YSBzZXQuXG4gICAgICogQHBhcmFtIHNraXBVbmtub3ducyAgICBJZiB0cnVlLCB1bmtub3duIHZhbHVlcyBzaG91bGQgYmUgc2tpcHBlZC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBnZXRTZXJpZXNWYWx1ZVBvc2l0aW9uKHRhcmdldE5hbWU6IHN0cmluZywgd29ybGRQb2ludDogT2JqZWN0LCB1c2VJbnRlcnBvbGF0aW9uOiBib29sZWFuLCBza2lwVW5rbm93bnM6IGJvb2xlYW4pOiBPYmplY3QgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBJZiBwb3NzaWJsZSwgd2lsbCByZXR1cm4gdGhlIGJlc3QgYXZhaWxhYmxlIG1haW4gdmFsdWUgcG9zaXRpb24gb2YgdGhlIHNlcmllcyBmb3IgYSBnaXZlbiB3b3JsZCBjb29yZGluYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRhcmdldE5hbWUgICAgVGhlIG5hbWUgb2YgdGhlIHNlcmllcyB0byB0YXJnZXQuXG4gICAgICogQHBhcmFtIHNlcmllc1BvaW50ICAgIFRoZSBzZXJpZXMgcGl4ZWwgcG9zaXRpb24gKGluIHRoZSBmb3JtIHt4OiBbbnVtYmVyXSwgeTogW251bWJlcl19IHRoYXQgcmVwcmVzZW50cyBhIHBvc2l0aW9uIHdpdGhpbiB0aGUgcGl4ZWwgc3BhY2Ugb2YgdGhlIHNlcmllcy5cbiAgICAgKiBAcGFyYW0gdXNlSW50ZXJwb2xhdGlvbiAgICBJZiB0cnVlLCBpbnRlcnBvbGF0aW9uIHNob3VsZCBiZSB1c2VkIHRvIGdldCBpbi1iZXR3ZWVuIHZhbHVlcywgcmF0aGVyIHRoYW4gb25seSB0aGUgYWN0dWFsIHZhbHVlcyBpbiB0aGUgZGF0YSBzZXQuXG4gICAgICogQHBhcmFtIHNraXBVbmtub3ducyAgICBJZiB0cnVlLCB1bmtub3duIHZhbHVlcyBzaG91bGQgYmUgc2tpcHBlZC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBnZXRTZXJpZXNWYWx1ZVBvc2l0aW9uRnJvbVNlcmllc1BpeGVsKHRhcmdldE5hbWU6IHN0cmluZywgc2VyaWVzUG9pbnQ6IE9iamVjdCwgdXNlSW50ZXJwb2xhdGlvbjogYm9vbGVhbiwgc2tpcFVua25vd25zOiBib29sZWFuKTogT2JqZWN0IHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogSWYgcG9zc2libGUsIHdpbGwgcmV0dXJuIHRoZSBiZXN0IGF2YWlsYWJsZSBtYWluIHZhbHVlIG9mIHRoZSBzZXJpZXMgZm9yIGEgZ2l2ZW4gd29ybGQgY29vcmRpbmF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0YXJnZXROYW1lICAgIFRoZSBuYW1lIG9mIHRoZSBzZXJpZXMgdG8gdGFyZ2V0LlxuICAgICAqIEBwYXJhbSBzZXJpZXNQb2ludCAgICBUaGUgc2VyaWVzIHBpeGVsIHBvc2l0aW9uIChpbiB0aGUgZm9ybSB7eDogW251bWJlcl0sIHk6IFtudW1iZXJdfSApIHRoYXQgcmVwcmVzZW50cyBhIHBvc2l0aW9uIGluIHRoZSBwaXhlbCBzcGFjZSBvZiB0aGUgc2VyaWVzLlxuICAgICAqIEBwYXJhbSB1c2VJbnRlcnBvbGF0aW9uICAgIElmIHRydWUsIGludGVycG9sYXRpb24gc2hvdWxkIGJlIHVzZWQgdG8gZ2V0IGluLWJldHdlZW4gdmFsdWVzLCByYXRoZXIgdGhhbiBvbmx5IHRoZSBhY3R1YWwgdmFsdWVzIGluIHRoZSBkYXRhIHNldC5cbiAgICAgKiBAcGFyYW0gc2tpcFVua25vd25zICAgIElmIHRydWUsIHVua25vd24gdmFsdWVzIHNob3VsZCBiZSBza2lwcGVkLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGdldFNlcmllc1ZhbHVlRnJvbVNlcmllc1BpeGVsKHRhcmdldE5hbWU6IHN0cmluZywgc2VyaWVzUG9pbnQ6IE9iamVjdCwgdXNlSW50ZXJwb2xhdGlvbjogYm9vbGVhbiwgc2tpcFVua25vd25zOiBib29sZWFuKTogbnVtYmVyIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogSWYgcG9zc2libGUsIHdpbGwgcmV0dXJuIHRoZSBiZXN0IGF2YWlsYWJsZSB2YWx1ZSBib3VuZGluZyBib3ggd2l0aGluIHRoZSBzZXJpZXMgdGhhdCBoYXMgdGhlIGJlc3QgdmFsdWUgbWF0Y2ggZm9yIHRoZSBnaXZlbiBzZXJpZXMgcGl4ZWwgY29vcmRpbmF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0YXJnZXROYW1lICAgIFRoZSBuYW1lIG9mIHRoZSBzZXJpZXMgdG8gdGFyZ2V0LlxuICAgICAqIEBwYXJhbSBzZXJpZXNQb2ludCAgICBUaGUgc2VyaWVzIHBpeGVsIHBvc2l0aW9uIChpbiB0aGUgZm9ybSB7eDogW251bWJlcl0sIHk6IFtudW1iZXJdfSApIHRoYXQgcmVwcmVzZW50cyBhIHBvc2l0aW9uIGluIHRoZSBwaXhlbCBzcGFjZSBvZiB0aGUgc2VyaWVzLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGdldFNlcmllc1ZhbHVlQm91bmRpbmdCb3hGcm9tU2VyaWVzUGl4ZWwodGFyZ2V0TmFtZTogc3RyaW5nLCBzZXJpZXNQb2ludDogT2JqZWN0KTogT2JqZWN0IHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogSWYgcG9zc2libGUsIHdpbGwgcmV0dXJuIHRoZSBiZXN0IGF2YWlsYWJsZSB2YWx1ZSBmaW5lIGdyYWluZWQgYm91bmRpbmcgYm94ZXMgd2l0aGluIHRoZSBzZXJpZXMgdGhhdCBoYXZlIHRoZSBiZXN0IHZhbHVlIG1hdGNoIGZvciBzZXJpZXMgcGl4ZWwgcG9zaXRpb24gcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGFyZ2V0TmFtZSAgICBUaGUgbmFtZSBvZiB0aGUgc2VyaWVzIHRvIHRhcmdldC5cbiAgICAgKiBAcGFyYW0gd29ybGRQb2ludCAgICBUaGUgc2VyaWVzIHBpeGVsIHBvc2l0aW9uIChpbiB0aGUgZm9ybSB7eDogW251bWJlcl0sIHk6IFtudW1iZXJdfSApIHRoYXQgcmVwcmVzZW50cyBhIHBvc2l0aW9uIGluIHRoZSBwaXhlbCBzcGFjZSBvZiB0aGUgc2VyaWVzLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGdldFNlcmllc1ZhbHVlRmluZUdyYWluZWRCb3VuZGluZ0JveGVzRnJvbVNlcmllc1BpeGVsKHRhcmdldE5hbWU6IHN0cmluZywgd29ybGRQb2ludDogT2JqZWN0KTogT2JqZWN0IHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogSWYgcG9zc2libGUsIHdpbGwgcmV0dXJuIHRoZSBiZXN0IGF2YWlsYWJsZSBoaWdoIHZhbHVlIG9mIHRoZSBzZXJpZXMgZm9yIGEgZ2l2ZW4gd29ybGQgY29vcmRpbmF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0YXJnZXROYW1lICAgIFRoZSBuYW1lIG9mIHRoZSBzZXJpZXMgdG8gdGFyZ2V0LlxuICAgICAqIEBwYXJhbSB3b3JsZFBvaW50ICAgIFRoZSB3b3JsZCBwb3NpdGlvbiAoaW4gdGhlIGZvcm0ge3g6IFtudW1iZXIgZnJvbSAwIHRvIDFdLCB5OiBbbnVtYmVyIGZyb20gMCB0byAxXX0gKSB0aGF0IHJlcHJlc2VudHMgYSBwb3NpdGlvbiBpbiB0aGUgc3BhY2Ugb2YgdGhlIGF4ZXMuXG4gICAgICogQHBhcmFtIHVzZUludGVycG9sYXRpb24gICAgSWYgdHJ1ZSwgaW50ZXJwb2xhdGlvbiBzaG91bGQgYmUgdXNlZCB0byBnZXQgaW4tYmV0d2VlbiB2YWx1ZXMsIHJhdGhlciB0aGFuIG9ubHkgdGhlIGFjdHVhbCB2YWx1ZXMgaW4gdGhlIGRhdGEgc2V0LlxuICAgICAqIEBwYXJhbSBza2lwVW5rbm93bnMgICAgSWYgdHJ1ZSwgdW5rbm93biB2YWx1ZXMgc2hvdWxkIGJlIHNraXBwZWQuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgZ2V0U2VyaWVzSGlnaFZhbHVlKHRhcmdldE5hbWU6IHN0cmluZywgd29ybGRQb2ludDogT2JqZWN0LCB1c2VJbnRlcnBvbGF0aW9uOiBib29sZWFuLCBza2lwVW5rbm93bnM6IGJvb2xlYW4pOiBudW1iZXIgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBJZiBwb3NzaWJsZSwgd2lsbCByZXR1cm4gdGhlIGJlc3QgYXZhaWxhYmxlIGhpZ2ggdmFsdWUgcG9zaXRpb24gb2YgdGhlIHNlcmllcyBmb3IgYSBnaXZlbiB3b3JsZCBjb29yZGluYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRhcmdldE5hbWUgICAgVGhlIG5hbWUgb2YgdGhlIHNlcmllcyB0byB0YXJnZXQuXG4gICAgICogQHBhcmFtIHdvcmxkUG9pbnQgICAgVGhlIHdvcmxkIHBvc2l0aW9uIChpbiB0aGUgZm9ybSB7eDogW251bWJlciBmcm9tIDAgdG8gMV0sIHk6IFtudW1iZXIgZnJvbSAwIHRvIDFdfSApIHRoYXQgcmVwcmVzZW50cyBhIHBvc2l0aW9uIGluIHRoZSBzcGFjZSBvZiB0aGUgYXhlcy5cbiAgICAgKiBAcGFyYW0gdXNlSW50ZXJwb2xhdGlvbiAgICBJZiB0cnVlLCBpbnRlcnBvbGF0aW9uIHNob3VsZCBiZSB1c2VkIHRvIGdldCBpbi1iZXR3ZWVuIHZhbHVlcywgcmF0aGVyIHRoYW4gb25seSB0aGUgYWN0dWFsIHZhbHVlcyBpbiB0aGUgZGF0YSBzZXQuXG4gICAgICogQHBhcmFtIHNraXBVbmtub3ducyAgICBJZiB0cnVlLCB1bmtub3duIHZhbHVlcyBzaG91bGQgYmUgc2tpcHBlZC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBnZXRTZXJpZXNIaWdoVmFsdWVQb3NpdGlvbih0YXJnZXROYW1lOiBzdHJpbmcsIHdvcmxkUG9pbnQ6IE9iamVjdCwgdXNlSW50ZXJwb2xhdGlvbjogYm9vbGVhbiwgc2tpcFVua25vd25zOiBib29sZWFuKTogT2JqZWN0IHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogSWYgcG9zc2libGUsIHdpbGwgcmV0dXJuIHRoZSBiZXN0IGF2YWlsYWJsZSBoaWdoIHZhbHVlIHBvc2l0aW9uIG9mIHRoZSBzZXJpZXMgZm9yIGEgZ2l2ZW4gd29ybGQgY29vcmRpbmF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0YXJnZXROYW1lICAgIFRoZSBuYW1lIG9mIHRoZSBzZXJpZXMgdG8gdGFyZ2V0LlxuICAgICAqIEBwYXJhbSBzZXJpZXNQb2ludCAgICBUaGUgc2VyaWVzIHBpeGVsIHBvc2l0aW9uIChpbiB0aGUgZm9ybSB7eDogW251bWJlcl0sIHk6IFtudW1iZXJdfSB0aGF0IHJlcHJlc2VudHMgYSBwb3NpdGlvbiB3aXRoaW4gdGhlIHBpeGVsIHNwYWNlIG9mIHRoZSBzZXJpZXMuXG4gICAgICogQHBhcmFtIHVzZUludGVycG9sYXRpb24gICAgSWYgdHJ1ZSwgaW50ZXJwb2xhdGlvbiBzaG91bGQgYmUgdXNlZCB0byBnZXQgaW4tYmV0d2VlbiB2YWx1ZXMsIHJhdGhlciB0aGFuIG9ubHkgdGhlIGFjdHVhbCB2YWx1ZXMgaW4gdGhlIGRhdGEgc2V0LlxuICAgICAqIEBwYXJhbSBza2lwVW5rbm93bnMgICAgSWYgdHJ1ZSwgdW5rbm93biB2YWx1ZXMgc2hvdWxkIGJlIHNraXBwZWQuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgZ2V0U2VyaWVzSGlnaFZhbHVlUG9zaXRpb25Gcm9tU2VyaWVzUGl4ZWwodGFyZ2V0TmFtZTogc3RyaW5nLCBzZXJpZXNQb2ludDogT2JqZWN0LCB1c2VJbnRlcnBvbGF0aW9uOiBib29sZWFuLCBza2lwVW5rbm93bnM6IGJvb2xlYW4pOiBPYmplY3QgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBJZiBwb3NzaWJsZSwgd2lsbCByZXR1cm4gdGhlIGJlc3QgYXZhaWxhYmxlIGhpZ2ggdmFsdWUgb2YgdGhlIHNlcmllcyBmb3IgYSBnaXZlbiB3b3JsZCBjb29yZGluYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRhcmdldE5hbWUgICAgVGhlIG5hbWUgb2YgdGhlIHNlcmllcyB0byB0YXJnZXQuXG4gICAgICogQHBhcmFtIHNlcmllc1BvaW50ICAgIFRoZSBzZXJpZXMgcGl4ZWwgcG9zaXRpb24gKGluIHRoZSBmb3JtIHt4OiBbbnVtYmVyXSwgeTogW251bWJlcl19ICkgdGhhdCByZXByZXNlbnRzIGEgcG9zaXRpb24gaW4gdGhlIHBpeGVsIHNwYWNlIG9mIHRoZSBzZXJpZXMuXG4gICAgICogQHBhcmFtIHVzZUludGVycG9sYXRpb24gICAgSWYgdHJ1ZSwgaW50ZXJwb2xhdGlvbiBzaG91bGQgYmUgdXNlZCB0byBnZXQgaW4tYmV0d2VlbiB2YWx1ZXMsIHJhdGhlciB0aGFuIG9ubHkgdGhlIGFjdHVhbCB2YWx1ZXMgaW4gdGhlIGRhdGEgc2V0LlxuICAgICAqIEBwYXJhbSBza2lwVW5rbm93bnMgICAgSWYgdHJ1ZSwgdW5rbm93biB2YWx1ZXMgc2hvdWxkIGJlIHNraXBwZWQuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgZ2V0U2VyaWVzSGlnaFZhbHVlRnJvbVNlcmllc1BpeGVsKHRhcmdldE5hbWU6IHN0cmluZywgc2VyaWVzUG9pbnQ6IE9iamVjdCwgdXNlSW50ZXJwb2xhdGlvbjogYm9vbGVhbiwgc2tpcFVua25vd25zOiBib29sZWFuKTogbnVtYmVyIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogSWYgcG9zc2libGUsIHdpbGwgcmV0dXJuIHRoZSBiZXN0IGF2YWlsYWJsZSBsb3cgdmFsdWUgb2YgdGhlIHNlcmllcyBmb3IgYSBnaXZlbiB3b3JsZCBjb29yZGluYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRhcmdldE5hbWUgICAgVGhlIG5hbWUgb2YgdGhlIHNlcmllcyB0byB0YXJnZXQuXG4gICAgICogQHBhcmFtIHdvcmxkUG9pbnQgICAgVGhlIHdvcmxkIHBvc2l0aW9uIChpbiB0aGUgZm9ybSB7eDogW251bWJlciBmcm9tIDAgdG8gMV0sIHk6IFtudW1iZXIgZnJvbSAwIHRvIDFdfSApIHRoYXQgcmVwcmVzZW50cyBhIHBvc2l0aW9uIGluIHRoZSBzcGFjZSBvZiB0aGUgYXhlcy5cbiAgICAgKiBAcGFyYW0gdXNlSW50ZXJwb2xhdGlvbiAgICBJZiB0cnVlLCBpbnRlcnBvbGF0aW9uIHNob3VsZCBiZSB1c2VkIHRvIGdldCBpbi1iZXR3ZWVuIHZhbHVlcywgcmF0aGVyIHRoYW4gb25seSB0aGUgYWN0dWFsIHZhbHVlcyBpbiB0aGUgZGF0YSBzZXQuXG4gICAgICogQHBhcmFtIHNraXBVbmtub3ducyAgICBJZiB0cnVlLCB1bmtub3duIHZhbHVlcyBzaG91bGQgYmUgc2tpcHBlZC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBnZXRTZXJpZXNMb3dWYWx1ZSh0YXJnZXROYW1lOiBzdHJpbmcsIHdvcmxkUG9pbnQ6IE9iamVjdCwgdXNlSW50ZXJwb2xhdGlvbjogYm9vbGVhbiwgc2tpcFVua25vd25zOiBib29sZWFuKTogbnVtYmVyIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogSWYgcG9zc2libGUsIHdpbGwgcmV0dXJuIHRoZSBiZXN0IGF2YWlsYWJsZSBsb3cgdmFsdWUgcG9zaXRpb24gb2YgdGhlIHNlcmllcyBmb3IgYSBnaXZlbiB3b3JsZCBjb29yZGluYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRhcmdldE5hbWUgICAgVGhlIG5hbWUgb2YgdGhlIHNlcmllcyB0byB0YXJnZXQuXG4gICAgICogQHBhcmFtIHdvcmxkUG9pbnQgICAgVGhlIHdvcmxkIHBvc2l0aW9uIChpbiB0aGUgZm9ybSB7eDogW251bWJlciBmcm9tIDAgdG8gMV0sIHk6IFtudW1iZXIgZnJvbSAwIHRvIDFdfSApIHRoYXQgcmVwcmVzZW50cyBhIHBvc2l0aW9uIGluIHRoZSBzcGFjZSBvZiB0aGUgYXhlcy5cbiAgICAgKiBAcGFyYW0gdXNlSW50ZXJwb2xhdGlvbiAgICBJZiB0cnVlLCBpbnRlcnBvbGF0aW9uIHNob3VsZCBiZSB1c2VkIHRvIGdldCBpbi1iZXR3ZWVuIHZhbHVlcywgcmF0aGVyIHRoYW4gb25seSB0aGUgYWN0dWFsIHZhbHVlcyBpbiB0aGUgZGF0YSBzZXQuXG4gICAgICogQHBhcmFtIHNraXBVbmtub3ducyAgICBJZiB0cnVlLCB1bmtub3duIHZhbHVlcyBzaG91bGQgYmUgc2tpcHBlZC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBnZXRTZXJpZXNMb3dWYWx1ZVBvc2l0aW9uKHRhcmdldE5hbWU6IHN0cmluZywgd29ybGRQb2ludDogT2JqZWN0LCB1c2VJbnRlcnBvbGF0aW9uOiBib29sZWFuLCBza2lwVW5rbm93bnM6IGJvb2xlYW4pOiBPYmplY3QgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBJZiBwb3NzaWJsZSwgd2lsbCByZXR1cm4gdGhlIGJlc3QgYXZhaWxhYmxlIGxvdyB2YWx1ZSBwb3NpdGlvbiBvZiB0aGUgc2VyaWVzIGZvciBhIGdpdmVuIHdvcmxkIGNvb3JkaW5hdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGFyZ2V0TmFtZSAgICBUaGUgbmFtZSBvZiB0aGUgc2VyaWVzIHRvIHRhcmdldC5cbiAgICAgKiBAcGFyYW0gc2VyaWVzUG9pbnQgICAgVGhlIHNlcmllcyBwaXhlbCBwb3NpdGlvbiAoaW4gdGhlIGZvcm0ge3g6IFtudW1iZXJdLCB5OiBbbnVtYmVyXX0gdGhhdCByZXByZXNlbnRzIGEgcG9zaXRpb24gd2l0aGluIHRoZSBwaXhlbCBzcGFjZSBvZiB0aGUgc2VyaWVzLlxuICAgICAqIEBwYXJhbSB1c2VJbnRlcnBvbGF0aW9uICAgIElmIHRydWUsIGludGVycG9sYXRpb24gc2hvdWxkIGJlIHVzZWQgdG8gZ2V0IGluLWJldHdlZW4gdmFsdWVzLCByYXRoZXIgdGhhbiBvbmx5IHRoZSBhY3R1YWwgdmFsdWVzIGluIHRoZSBkYXRhIHNldC5cbiAgICAgKiBAcGFyYW0gc2tpcFVua25vd25zICAgIElmIHRydWUsIHVua25vd24gdmFsdWVzIHNob3VsZCBiZSBza2lwcGVkLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGdldFNlcmllc0xvd1ZhbHVlUG9zaXRpb25Gcm9tU2VyaWVzUGl4ZWwodGFyZ2V0TmFtZTogc3RyaW5nLCBzZXJpZXNQb2ludDogT2JqZWN0LCB1c2VJbnRlcnBvbGF0aW9uOiBib29sZWFuLCBza2lwVW5rbm93bnM6IGJvb2xlYW4pOiBPYmplY3QgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBJZiBwb3NzaWJsZSwgd2lsbCByZXR1cm4gdGhlIGJlc3QgYXZhaWxhYmxlIGxvdyB2YWx1ZSBvZiB0aGUgc2VyaWVzIGZvciBhIGdpdmVuIHdvcmxkIGNvb3JkaW5hdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGFyZ2V0TmFtZSAgICBUaGUgbmFtZSBvZiB0aGUgc2VyaWVzIHRvIHRhcmdldC5cbiAgICAgKiBAcGFyYW0gc2VyaWVzUG9pbnQgICAgVGhlIHNlcmllcyBwaXhlbCBwb3NpdGlvbiAoaW4gdGhlIGZvcm0ge3g6IFtudW1iZXJdLCB5OiBbbnVtYmVyXX0gKSB0aGF0IHJlcHJlc2VudHMgYSBwb3NpdGlvbiBpbiB0aGUgcGl4ZWwgc3BhY2Ugb2YgdGhlIHNlcmllcy5cbiAgICAgKiBAcGFyYW0gdXNlSW50ZXJwb2xhdGlvbiAgICBJZiB0cnVlLCBpbnRlcnBvbGF0aW9uIHNob3VsZCBiZSB1c2VkIHRvIGdldCBpbi1iZXR3ZWVuIHZhbHVlcywgcmF0aGVyIHRoYW4gb25seSB0aGUgYWN0dWFsIHZhbHVlcyBpbiB0aGUgZGF0YSBzZXQuXG4gICAgICogQHBhcmFtIHNraXBVbmtub3ducyAgICBJZiB0cnVlLCB1bmtub3duIHZhbHVlcyBzaG91bGQgYmUgc2tpcHBlZC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBnZXRTZXJpZXNMb3dWYWx1ZUZyb21TZXJpZXNQaXhlbCh0YXJnZXROYW1lOiBzdHJpbmcsIHNlcmllc1BvaW50OiBPYmplY3QsIHVzZUludGVycG9sYXRpb246IGJvb2xlYW4sIHNraXBVbmtub3duczogYm9vbGVhbik6IG51bWJlciB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGl0ZW0gaXRlbSBpbmRleCBhc3NvY2lhdGVkIHdpdGggdGhlIHNwZWNpZmllZCBzZXJpZXMgcGl4ZWwgY29vcmRpbmF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0YXJnZXROYW1lICAgIFRoZSBuYW1lIG9mIHRoZSBzZXJpZXMgdG8gdGFyZ2V0LlxuICAgICAqIEBwYXJhbSBzZXJpZXNQb2ludCAgICBUaGUgd29ybGQgcG9zaXRpb24gKGluIHRoZSBmb3JtIHt4OiBbbnVtYmVyIGZyb20gMCB0byAxXSwgeTogW251bWJlciBmcm9tIDAgdG8gMV19ICkgdGhhdCByZXByZXNlbnRzIGEgcG9zaXRpb24gaW4gdGhlIHNwYWNlIG9mIHRoZSBheGVzLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGdldEl0ZW1JbmRleEZyb21TZXJpZXNQaXhlbCh0YXJnZXROYW1lOiBzdHJpbmcsIHNlcmllc1BvaW50OiBPYmplY3QpOiBudW1iZXIgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpdGVtIHRoYXQgaXMgdGhlIGJlc3QgbWF0Y2ggZm9yIHRoZSBzcGVjaWZpZWQgd29ybGQgY29vcmRpbmF0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGFyZ2V0TmFtZSAgICBUaGUgbmFtZSBvZiB0aGUgc2VyaWVzIHRvIHRhcmdldC5cbiAgICAgKiBAcGFyYW0gc2VyaWVzUG9pbnQgICAgVGhlIHNlcmllcyBwaXhlbCBwb3NpdGlvbiAoaW4gdGhlIGZvcm0ge3g6IFtudW1iZXJdLCB5OiBbbnVtYmVyXX0gKSB0aGF0IHJlcHJlc2VudHMgYSBwb3NpdGlvbiBpbiB0aGUgcGl4ZWwgc3BhY2Ugb2YgdGhlIHNlcmllcy5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBnZXRJdGVtRnJvbVNlcmllc1BpeGVsKHRhcmdldE5hbWU6IHN0cmluZywgc2VyaWVzUG9pbnQ6IE9iamVjdCk6IE9iamVjdCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGNhdGVnb3J5IG9mZnNldCBmb3IgYSBzZXJpZXMsIGlmIGFwcGxpY2FibGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGFyZ2V0TmFtZSAgICBUaGUgbmFtZSBvZiB0aGUgc2VyaWVzIHRvIHRhcmdldC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBnZXRTZXJpZXNPZmZzZXRWYWx1ZSh0YXJnZXROYW1lOiBzdHJpbmcpOiBudW1iZXIgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjYXRlZ29yeSB3aWR0aCBmb3IgYSBzZXJpZXMsIGlmIGFwcGxpY2FibGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGFyZ2V0TmFtZSAgICBUaGUgbmFtZSBvZiB0aGUgc2VyaWVzIHRvIHRhcmdldC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBnZXRTZXJpZXNDYXRlZ29yeVdpZHRoKHRhcmdldE5hbWU6IHN0cmluZyk6IG51bWJlciB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFJlcGxheXMgdGhlIHRyYW5zaXRpb24gaW4gYW5pbWF0aW9uIGZvciBhIHNlcmllcywgaWYgYXBwbGljYWJsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0YXJnZXROYW1lICAgIFRoZSBuYW1lIG9mIHRoZSBzZXJpZXMgdG8gdGFyZ2V0LlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIHJlcGxheVRyYW5zaXRpb25Jbih0YXJnZXROYW1lOiBzdHJpbmcpOiBPYmplY3QgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBTaW11bGF0ZXMgYSBob3ZlciBpbnRlcmFjdGlvbiBvdmVyIGEgZ2l2ZW4gcG9pbnQgaW4gdGhlIHZpZXdwb3J0IG9mIGEgc2VyaWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRhcmdldE5hbWUgICAgVGhlIG5hbWUgb2YgdGhlIHNlcmllcyB0byB0YXJnZXQuXG4gICAgICogQHBhcmFtIHNlcmllc1BvaW50ICAgIFRoZSBwb2ludCBhdCB3aGljaCB0byBob3Zlci4gU2hvdWxkIGhhdmUgYW4geCBwcm9wZXJ0eSB3aXRoIHR5cGUgbnVtYmVyIGFuZCBhIHkgcHJvcGVydHkgd2l0aCB0eXBlIG51bWJlci5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBzaW11bGF0ZUhvdmVyKHRhcmdldE5hbWU6IHN0cmluZywgc2VyaWVzUG9pbnQ6IE9iamVjdCk6IE9iamVjdCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIE1vdmVzIHRoZSBjdXJzb3IgcG9pbnQgb2YgdGhlIHRhcmdldCBhbm5vdGF0aW9uIGxheWVyIHRvIHRoZSBkZXNpcmVkIHdvcmxkIGNvb3JkaW5hdGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRhcmdldE5hbWUgICAgVGhlIG5hbWUgb2YgdGhlIHNlcmllcyB0byB0YXJnZXQuXG4gICAgICogQHBhcmFtIHdvcmxkUG9pbnQgICAgVGhlIHBvaW50IHRvIHdoaWNoIHRvIG1vdmUgdGhlIGN1cnNvci4gU2hvdWxkIGhhdmUgYW4geCBwcm9wZXJ0eSB3aXRoIHR5cGUgbnVtYmVyIGFuZCBhIHkgcHJvcGVydHkgd2l0aCB0eXBlIG51bWJlci5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBtb3ZlQ3Vyc29yUG9pbnQodGFyZ2V0TmFtZTogc3RyaW5nLCB3b3JsZFBvaW50OiBPYmplY3QpOiBPYmplY3QgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBNYW51YWxseSBzdGFydHMgYSB0aWxlZCB6b29tIGlmIG9uZSBpc24ndCBhbHJlYWR5IHJ1bm5pbmcuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgc3RhcnRUaWxlZFpvb21pbmdJZk5lY2Vzc2FyeSgpOiB2b2lkIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogTWFudWFsbHkgZW5kcyBhIHRpbGVkIHpvb20gaWYgb25lIGlzIHJ1bm5pbmcuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgZW5kVGlsZWRab29taW5nSWZSdW5uaW5nKCk6IHZvaWQgeyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIHRpbGUgem9vbSB0aWxlIGNhY2hlIHNvIHRoYXQgbmV3IHRpbGVzIHdpbGwgYmUgZ2VuZXJhdGVkLiBPbmx5IGFwcGxpZXMgaWYgdGhlIHZpZXdlciBpcyB1c2luZyBhIHRpbGUgYmFzZWQgem9vbS5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBjbGVhclRpbGVab29tQ2FjaGUoKTogdm9pZCB7IHJldHVybjsgfTtcbn1cblxuIl19