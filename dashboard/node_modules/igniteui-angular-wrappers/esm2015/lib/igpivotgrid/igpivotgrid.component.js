/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, Renderer, ElementRef, IterableDiffers, KeyValueDiffers, ChangeDetectorRef, Input } from "@angular/core";
import { IgControlBase } from "../igcontrolbase/igcontrolbase";
export class IgPivotGridComponent extends IgControlBase {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} differs
     * @param {?} kvalDiffers
     * @param {?} cdr
     */
    constructor(el, renderer, differs, kvalDiffers, cdr) { super(el, renderer, differs, kvalDiffers, cdr); }
    /**
     * @return {?}
     */
    option() { return; }
    ;
    /**
     * @param {?} value
     * @return {?}
     */
    set dataSource(value) {
        this._dataSource = value;
        /** @type {?} */
        const widget = jQuery(this._el).data(this._widgetName);
        if (widget) {
            jQuery(this._el)[this._widgetName]("option", "dataSource", this._dataSource);
        }
    }
    ;
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this._dataSource === null || this._dataSource === undefined) {
            this._dataSource = this.options["dataSource"];
        }
        if (!this.options["dataSource"] && this._dataSource) {
            this.options["dataSource"] = this._dataSource;
        }
        super.ngOnInit();
    }
    /**
     * Returns the igGrid instance used to render the OLAP data.
     * @return {?}
     */
    /* istanbul ignore next */
    grid() { return; }
    ;
    /**
     * Triggers an update on the data source and the igPivotGrid.
     * @return {?}
     */
    /* istanbul ignore next */
    updateGrid() { return; }
    ;
    /**
     * Expands a member from the data source and returns true if the expand succeeds. If the data source has a pending update, the method will return false. Note that igPivotGrid to will display the expanded result after the data source is updated.
     *
     * @param {?} tupleLocation The name of the parent axis - 'columnAxis' or 'rowAxis'.
     * @param {?} tupleIndex The index of the containing tuple. This index should correspond to the position of the tuple in the original unsorted result of the data source.
     * @param {?} memberIndex The index of the member in the tuple. This index should correspond to the position of the member in the original unsorted result of the data source.
     * @param {?=} shouldUpdate A flag indicating whether the data source should be updated after the expand.
     * @return {?}
     */
    /* istanbul ignore next */
    expandTupleMember(tupleLocation, tupleIndex, memberIndex, shouldUpdate) { return; }
    ;
    /**
     * Collapses a member from the data source and returns true if the collapse succeeds. If the data source has a pending update, the method will return false. Note that igPivotGrid to will display the expanded result after the data source is updated.
     *
     * @param {?} tupleLocation The name of the parent axis - 'columnAxis' or 'rowAxis'.
     * @param {?} tupleIndex The index of the containing tuple. This index should correspond to the position of the tuple in the original unsorted result of the data source.
     * @param {?} memberIndex The index of the member in the tuple. This index should correspond to the position of the member in the original unsorted result of the data source.
     * @param {?=} shouldUpdate A flag indicating whether the data source should be updated after the expand.
     * @return {?}
     */
    /* istanbul ignore next */
    collapseTupleMember(tupleLocation, tupleIndex, memberIndex, shouldUpdate) { return; }
    ;
    /**
     * Returns an array with the applied sort directions on the igPivotGrid's columns. The returned array contains objects with the following properties:
     *             memberNames: The names of the members in the tuple.
     *             tupleIndex: The index of the tuple on the column axis in the original unsorted result.
     *             sortDirection: The direction of the sort - ascending or descending.
     * @return {?}
     */
    /* istanbul ignore next */
    appliedColumnSortDirections() { return; }
    ;
    /**
     * Returns an array with the applied level sort direction items, which were used for the sorting of the header cells. The returned array contains objects with the following properties:
     *             levelUniqueName: Specifies the unique name of the level, which was sorted.
     *             sortDirection: The direction of the header sort - ascending or descending.
     * @return {?}
     */
    /* istanbul ignore next */
    appliedLevelSortDirections() { return; }
    ;
    /**
     * Destroy is part of the jQuery UI widget API and does the following:
     *             1. Remove custom CSS classes that were added.
     *             2. Unwrap any wrapping elements such as scrolling divs and other containers.
     *             3. Unbind all events that were bound.
     * @return {?}
     */
    /* istanbul ignore next */
    destroy() { return; }
    ;
}
IgPivotGridComponent.decorators = [
    { type: Component, args: [{
                selector: "ig-pivot-grid",
                template: "<ng-content></ng-content>",
                inputs: ["widgetId", "options", "changeDetectionInterval", "disabled", "create", "width", "height", "dataSource", "dataSourceOptions", "deferUpdate", "isParentInFrontForColumns", "isParentInFrontForRows", "compactColumnHeaders", "compactRowHeaders", "rowHeadersLayout", "compactColumnHeaderIndentation", "compactRowHeaderIndentation", "rowHeaderLinkGroupIndentation", "treeRowHeaderIndentation", "defaultRowHeaderWidth", "allowSorting", "firstSortDirection", "allowHeaderRowsSorting", "allowHeaderColumnsSorting", "levelSortDirections", "defaultLevelSortBehavior", "firstLevelSortDirection", "gridOptions", "dragAndDropSettings", "dropDownParent", "disableRowsDropArea", "disableColumnsDropArea", "disableMeasuresDropArea", "disableFiltersDropArea", "hideRowsDropArea", "hideColumnsDropArea", "hideMeasuresDropArea", "hideFiltersDropArea", "customMoveValidation"],
                outputs: ["dataSourceInitialized", "dataSourceUpdated", "pivotGridHeadersRendered", "pivotGridRendered", "tupleMemberExpanding", "tupleMemberExpanded", "tupleMemberCollapsing", "tupleMemberCollapsed", "sorting", "sorted", "headersSorting", "headersSorted", "dragStart", "drag", "dragStop", "metadataDropping", "metadataDropped", "metadataRemoving", "metadataRemoved", "filterDropDownOpening", "filterDropDownOpened", "filterMembersLoaded", "filterDropDownOk", "filterDropDownClosing", "filterDropDownClosed"]
            }] }
];
/** @nocollapse */
IgPivotGridComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer },
    { type: IterableDiffers },
    { type: KeyValueDiffers },
    { type: ChangeDetectorRef }
];
IgPivotGridComponent.propDecorators = {
    dataSource: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    IgPivotGridComponent.prototype._dataSource;
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
    /* Skipping unhandled member: ;*/
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWdwaXZvdGdyaWQuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vaWduaXRldWktYW5ndWxhci13cmFwcGVycy8iLCJzb3VyY2VzIjpbImxpYi9pZ3Bpdm90Z3JpZC9pZ3Bpdm90Z3JpZC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBRSxlQUFlLEVBQUUsZUFBZSxFQUFFLGlCQUFpQixFQUFFLEtBQUssRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUM1SCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sZ0NBQWdDLENBQUM7QUFRL0QsTUFBTSxPQUFPLG9CQUFxQixTQUFRLGFBQTBCOzs7Ozs7OztJQUNoRSxZQUFZLEVBQWMsRUFBRSxRQUFrQixFQUFFLE9BQXdCLEVBQUUsV0FBNEIsRUFBRSxHQUFzQixJQUFJLEtBQUssQ0FBQyxFQUFFLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxXQUFXLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDOzs7O0lBQVEsTUFBTSxLQUFXLE9BQU8sQ0FBQyxDQUFDO0lBQUEsQ0FBQzs7Ozs7SUFFdE4sSUFDVyxVQUFVLENBQUMsS0FBVTtRQUM1QixJQUFJLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQzs7Y0FDbkIsTUFBTSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUM7UUFDdEQsSUFBSSxNQUFNLEVBQUU7WUFDUixNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxRQUFRLEVBQUUsWUFBWSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztTQUNoRjtJQUNMLENBQUM7SUFBQSxDQUFDOzs7O0lBSUYsUUFBUTtRQUNKLElBQUksSUFBSSxDQUFDLFdBQVcsS0FBSyxJQUFJLElBQUksSUFBSSxDQUFDLFdBQVcsS0FBSyxTQUFTLEVBQUU7WUFDN0QsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxDQUFDO1NBQ2pEO1FBQ0QsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRTtZQUNqRCxJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUM7U0FDakQ7UUFDRCxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDckIsQ0FBQzs7Ozs7O0lBTU0sSUFBSSxLQUFhLE9BQU8sQ0FBQyxDQUFDO0lBQUEsQ0FBQzs7Ozs7O0lBTTNCLFVBQVUsS0FBVyxPQUFPLENBQUMsQ0FBQztJQUFBLENBQUM7Ozs7Ozs7Ozs7O0lBVy9CLGlCQUFpQixDQUFDLGFBQXFCLEVBQUUsVUFBa0IsRUFBRSxXQUFtQixFQUFFLFlBQXNCLElBQWEsT0FBTyxDQUFDLENBQUM7SUFBQSxDQUFDOzs7Ozs7Ozs7OztJQVcvSCxtQkFBbUIsQ0FBQyxhQUFxQixFQUFFLFVBQWtCLEVBQUUsV0FBbUIsRUFBRSxZQUFzQixJQUFhLE9BQU8sQ0FBQyxDQUFDO0lBQUEsQ0FBQzs7Ozs7Ozs7O0lBU2pJLDJCQUEyQixLQUFZLE9BQU8sQ0FBQyxDQUFDO0lBQUEsQ0FBQzs7Ozs7Ozs7SUFRakQsMEJBQTBCLEtBQVksT0FBTyxDQUFDLENBQUM7SUFBQSxDQUFDOzs7Ozs7Ozs7SUFTaEQsT0FBTyxLQUFXLE9BQU8sQ0FBQyxDQUFDO0lBQUEsQ0FBQzs7O1lBeEZ0QyxTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLGVBQWU7Z0JBQ3pCLFFBQVEsRUFBRSwyQkFBMkI7Z0JBQ3JDLE1BQU0sRUFBRSxDQUFDLFVBQVUsRUFBRSxTQUFTLEVBQUUseUJBQXlCLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsUUFBUSxFQUFFLFlBQVksRUFBRSxtQkFBbUIsRUFBRSxhQUFhLEVBQUUsMkJBQTJCLEVBQUUsd0JBQXdCLEVBQUUsc0JBQXNCLEVBQUUsbUJBQW1CLEVBQUUsa0JBQWtCLEVBQUUsZ0NBQWdDLEVBQUUsNkJBQTZCLEVBQUUsK0JBQStCLEVBQUUsMEJBQTBCLEVBQUUsdUJBQXVCLEVBQUUsY0FBYyxFQUFFLG9CQUFvQixFQUFFLHdCQUF3QixFQUFFLDJCQUEyQixFQUFFLHFCQUFxQixFQUFFLDBCQUEwQixFQUFFLHlCQUF5QixFQUFFLGFBQWEsRUFBRSxxQkFBcUIsRUFBRSxnQkFBZ0IsRUFBRSxxQkFBcUIsRUFBRSx3QkFBd0IsRUFBRSx5QkFBeUIsRUFBRSx3QkFBd0IsRUFBRSxrQkFBa0IsRUFBRSxxQkFBcUIsRUFBRSxzQkFBc0IsRUFBRSxxQkFBcUIsRUFBRSxzQkFBc0IsQ0FBQztnQkFDLzFCLE9BQU8sRUFBRSxDQUFDLHVCQUF1QixFQUFFLG1CQUFtQixFQUFFLDBCQUEwQixFQUFFLG1CQUFtQixFQUFFLHNCQUFzQixFQUFFLHFCQUFxQixFQUFFLHVCQUF1QixFQUFFLHNCQUFzQixFQUFFLFNBQVMsRUFBRSxRQUFRLEVBQUUsZ0JBQWdCLEVBQUUsZUFBZSxFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLGtCQUFrQixFQUFFLGlCQUFpQixFQUFFLGtCQUFrQixFQUFFLGlCQUFpQixFQUFFLHVCQUF1QixFQUFFLHNCQUFzQixFQUFFLHFCQUFxQixFQUFFLGtCQUFrQixFQUFFLHVCQUF1QixFQUFFLHNCQUFzQixDQUFDO2FBQy9mOzs7O1lBUjZCLFVBQVU7WUFBcEIsUUFBUTtZQUFjLGVBQWU7WUFBRSxlQUFlO1lBQUUsaUJBQWlCOzs7eUJBWXhGLEtBQUs7Ozs7Ozs7SUFTTiwyQ0FBeUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIFJlbmRlcmVyLCBFbGVtZW50UmVmLCBJdGVyYWJsZURpZmZlcnMsIEtleVZhbHVlRGlmZmVycywgQ2hhbmdlRGV0ZWN0b3JSZWYsIElucHV0IH0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7IElnQ29udHJvbEJhc2UgfSBmcm9tIFwiLi4vaWdjb250cm9sYmFzZS9pZ2NvbnRyb2xiYXNlXCI7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiBcImlnLXBpdm90LWdyaWRcIixcbiAgICB0ZW1wbGF0ZTogXCI8bmctY29udGVudD48L25nLWNvbnRlbnQ+XCIsXG4gICAgaW5wdXRzOiBbXCJ3aWRnZXRJZFwiLCBcIm9wdGlvbnNcIiwgXCJjaGFuZ2VEZXRlY3Rpb25JbnRlcnZhbFwiLCBcImRpc2FibGVkXCIsIFwiY3JlYXRlXCIsIFwid2lkdGhcIiwgXCJoZWlnaHRcIiwgXCJkYXRhU291cmNlXCIsIFwiZGF0YVNvdXJjZU9wdGlvbnNcIiwgXCJkZWZlclVwZGF0ZVwiLCBcImlzUGFyZW50SW5Gcm9udEZvckNvbHVtbnNcIiwgXCJpc1BhcmVudEluRnJvbnRGb3JSb3dzXCIsIFwiY29tcGFjdENvbHVtbkhlYWRlcnNcIiwgXCJjb21wYWN0Um93SGVhZGVyc1wiLCBcInJvd0hlYWRlcnNMYXlvdXRcIiwgXCJjb21wYWN0Q29sdW1uSGVhZGVySW5kZW50YXRpb25cIiwgXCJjb21wYWN0Um93SGVhZGVySW5kZW50YXRpb25cIiwgXCJyb3dIZWFkZXJMaW5rR3JvdXBJbmRlbnRhdGlvblwiLCBcInRyZWVSb3dIZWFkZXJJbmRlbnRhdGlvblwiLCBcImRlZmF1bHRSb3dIZWFkZXJXaWR0aFwiLCBcImFsbG93U29ydGluZ1wiLCBcImZpcnN0U29ydERpcmVjdGlvblwiLCBcImFsbG93SGVhZGVyUm93c1NvcnRpbmdcIiwgXCJhbGxvd0hlYWRlckNvbHVtbnNTb3J0aW5nXCIsIFwibGV2ZWxTb3J0RGlyZWN0aW9uc1wiLCBcImRlZmF1bHRMZXZlbFNvcnRCZWhhdmlvclwiLCBcImZpcnN0TGV2ZWxTb3J0RGlyZWN0aW9uXCIsIFwiZ3JpZE9wdGlvbnNcIiwgXCJkcmFnQW5kRHJvcFNldHRpbmdzXCIsIFwiZHJvcERvd25QYXJlbnRcIiwgXCJkaXNhYmxlUm93c0Ryb3BBcmVhXCIsIFwiZGlzYWJsZUNvbHVtbnNEcm9wQXJlYVwiLCBcImRpc2FibGVNZWFzdXJlc0Ryb3BBcmVhXCIsIFwiZGlzYWJsZUZpbHRlcnNEcm9wQXJlYVwiLCBcImhpZGVSb3dzRHJvcEFyZWFcIiwgXCJoaWRlQ29sdW1uc0Ryb3BBcmVhXCIsIFwiaGlkZU1lYXN1cmVzRHJvcEFyZWFcIiwgXCJoaWRlRmlsdGVyc0Ryb3BBcmVhXCIsIFwiY3VzdG9tTW92ZVZhbGlkYXRpb25cIl0sXG4gICAgb3V0cHV0czogW1wiZGF0YVNvdXJjZUluaXRpYWxpemVkXCIsIFwiZGF0YVNvdXJjZVVwZGF0ZWRcIiwgXCJwaXZvdEdyaWRIZWFkZXJzUmVuZGVyZWRcIiwgXCJwaXZvdEdyaWRSZW5kZXJlZFwiLCBcInR1cGxlTWVtYmVyRXhwYW5kaW5nXCIsIFwidHVwbGVNZW1iZXJFeHBhbmRlZFwiLCBcInR1cGxlTWVtYmVyQ29sbGFwc2luZ1wiLCBcInR1cGxlTWVtYmVyQ29sbGFwc2VkXCIsIFwic29ydGluZ1wiLCBcInNvcnRlZFwiLCBcImhlYWRlcnNTb3J0aW5nXCIsIFwiaGVhZGVyc1NvcnRlZFwiLCBcImRyYWdTdGFydFwiLCBcImRyYWdcIiwgXCJkcmFnU3RvcFwiLCBcIm1ldGFkYXRhRHJvcHBpbmdcIiwgXCJtZXRhZGF0YURyb3BwZWRcIiwgXCJtZXRhZGF0YVJlbW92aW5nXCIsIFwibWV0YWRhdGFSZW1vdmVkXCIsIFwiZmlsdGVyRHJvcERvd25PcGVuaW5nXCIsIFwiZmlsdGVyRHJvcERvd25PcGVuZWRcIiwgXCJmaWx0ZXJNZW1iZXJzTG9hZGVkXCIsIFwiZmlsdGVyRHJvcERvd25Pa1wiLCBcImZpbHRlckRyb3BEb3duQ2xvc2luZ1wiLCBcImZpbHRlckRyb3BEb3duQ2xvc2VkXCJdXG59KVxuZXhwb3J0IGNsYXNzIElnUGl2b3RHcmlkQ29tcG9uZW50IGV4dGVuZHMgSWdDb250cm9sQmFzZTxJZ1Bpdm90R3JpZD4ge1xuICAgIGNvbnN0cnVjdG9yKGVsOiBFbGVtZW50UmVmLCByZW5kZXJlcjogUmVuZGVyZXIsIGRpZmZlcnM6IEl0ZXJhYmxlRGlmZmVycywga3ZhbERpZmZlcnM6IEtleVZhbHVlRGlmZmVycywgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZikgeyBzdXBlcihlbCwgcmVuZGVyZXIsIGRpZmZlcnMsIGt2YWxEaWZmZXJzLCBjZHIpOyB9IHB1YmxpYyBvcHRpb24oKTogdm9pZCB7IHJldHVybjsgfTtcblxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNldCBkYXRhU291cmNlKHZhbHVlOiBhbnkpIHtcbiAgICAgICAgdGhpcy5fZGF0YVNvdXJjZSA9IHZhbHVlO1xuICAgICAgICBjb25zdCB3aWRnZXQgPSBqUXVlcnkodGhpcy5fZWwpLmRhdGEodGhpcy5fd2lkZ2V0TmFtZSk7XG4gICAgICAgIGlmICh3aWRnZXQpIHtcbiAgICAgICAgICAgIGpRdWVyeSh0aGlzLl9lbClbdGhpcy5fd2lkZ2V0TmFtZV0oXCJvcHRpb25cIiwgXCJkYXRhU291cmNlXCIsIHRoaXMuX2RhdGFTb3VyY2UpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHByaXZhdGUgX2RhdGFTb3VyY2U6IGFueTtcblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBpZiAodGhpcy5fZGF0YVNvdXJjZSA9PT0gbnVsbCB8fCB0aGlzLl9kYXRhU291cmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGFTb3VyY2UgPSB0aGlzLm9wdGlvbnNbXCJkYXRhU291cmNlXCJdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zW1wiZGF0YVNvdXJjZVwiXSAmJiB0aGlzLl9kYXRhU291cmNlKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNbXCJkYXRhU291cmNlXCJdID0gdGhpcy5fZGF0YVNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGlnR3JpZCBpbnN0YW5jZSB1c2VkIHRvIHJlbmRlciB0aGUgT0xBUCBkYXRhLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGdyaWQoKTogT2JqZWN0IHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcnMgYW4gdXBkYXRlIG9uIHRoZSBkYXRhIHNvdXJjZSBhbmQgdGhlIGlnUGl2b3RHcmlkLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIHVwZGF0ZUdyaWQoKTogdm9pZCB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIEV4cGFuZHMgYSBtZW1iZXIgZnJvbSB0aGUgZGF0YSBzb3VyY2UgYW5kIHJldHVybnMgdHJ1ZSBpZiB0aGUgZXhwYW5kIHN1Y2NlZWRzLiBJZiB0aGUgZGF0YSBzb3VyY2UgaGFzIGEgcGVuZGluZyB1cGRhdGUsIHRoZSBtZXRob2Qgd2lsbCByZXR1cm4gZmFsc2UuIE5vdGUgdGhhdCBpZ1Bpdm90R3JpZCB0byB3aWxsIGRpc3BsYXkgdGhlIGV4cGFuZGVkIHJlc3VsdCBhZnRlciB0aGUgZGF0YSBzb3VyY2UgaXMgdXBkYXRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0dXBsZUxvY2F0aW9uIFRoZSBuYW1lIG9mIHRoZSBwYXJlbnQgYXhpcyAtICdjb2x1bW5BeGlzJyBvciAncm93QXhpcycuXG4gICAgICogQHBhcmFtIHR1cGxlSW5kZXggVGhlIGluZGV4IG9mIHRoZSBjb250YWluaW5nIHR1cGxlLiBUaGlzIGluZGV4IHNob3VsZCBjb3JyZXNwb25kIHRvIHRoZSBwb3NpdGlvbiBvZiB0aGUgdHVwbGUgaW4gdGhlIG9yaWdpbmFsIHVuc29ydGVkIHJlc3VsdCBvZiB0aGUgZGF0YSBzb3VyY2UuXG4gICAgICogQHBhcmFtIG1lbWJlckluZGV4IFRoZSBpbmRleCBvZiB0aGUgbWVtYmVyIGluIHRoZSB0dXBsZS4gVGhpcyBpbmRleCBzaG91bGQgY29ycmVzcG9uZCB0byB0aGUgcG9zaXRpb24gb2YgdGhlIG1lbWJlciBpbiB0aGUgb3JpZ2luYWwgdW5zb3J0ZWQgcmVzdWx0IG9mIHRoZSBkYXRhIHNvdXJjZS5cbiAgICAgKiBAcGFyYW0gc2hvdWxkVXBkYXRlIEEgZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRhdGEgc291cmNlIHNob3VsZCBiZSB1cGRhdGVkIGFmdGVyIHRoZSBleHBhbmQuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgZXhwYW5kVHVwbGVNZW1iZXIodHVwbGVMb2NhdGlvbjogc3RyaW5nLCB0dXBsZUluZGV4OiBudW1iZXIsIG1lbWJlckluZGV4OiBudW1iZXIsIHNob3VsZFVwZGF0ZT86IGJvb2xlYW4pOiBib29sZWFuIHsgcmV0dXJuOyB9O1xuXG4gICAgLyoqXG4gICAgICogQ29sbGFwc2VzIGEgbWVtYmVyIGZyb20gdGhlIGRhdGEgc291cmNlIGFuZCByZXR1cm5zIHRydWUgaWYgdGhlIGNvbGxhcHNlIHN1Y2NlZWRzLiBJZiB0aGUgZGF0YSBzb3VyY2UgaGFzIGEgcGVuZGluZyB1cGRhdGUsIHRoZSBtZXRob2Qgd2lsbCByZXR1cm4gZmFsc2UuIE5vdGUgdGhhdCBpZ1Bpdm90R3JpZCB0byB3aWxsIGRpc3BsYXkgdGhlIGV4cGFuZGVkIHJlc3VsdCBhZnRlciB0aGUgZGF0YSBzb3VyY2UgaXMgdXBkYXRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0dXBsZUxvY2F0aW9uIFRoZSBuYW1lIG9mIHRoZSBwYXJlbnQgYXhpcyAtICdjb2x1bW5BeGlzJyBvciAncm93QXhpcycuXG4gICAgICogQHBhcmFtIHR1cGxlSW5kZXggVGhlIGluZGV4IG9mIHRoZSBjb250YWluaW5nIHR1cGxlLiBUaGlzIGluZGV4IHNob3VsZCBjb3JyZXNwb25kIHRvIHRoZSBwb3NpdGlvbiBvZiB0aGUgdHVwbGUgaW4gdGhlIG9yaWdpbmFsIHVuc29ydGVkIHJlc3VsdCBvZiB0aGUgZGF0YSBzb3VyY2UuXG4gICAgICogQHBhcmFtIG1lbWJlckluZGV4IFRoZSBpbmRleCBvZiB0aGUgbWVtYmVyIGluIHRoZSB0dXBsZS4gVGhpcyBpbmRleCBzaG91bGQgY29ycmVzcG9uZCB0byB0aGUgcG9zaXRpb24gb2YgdGhlIG1lbWJlciBpbiB0aGUgb3JpZ2luYWwgdW5zb3J0ZWQgcmVzdWx0IG9mIHRoZSBkYXRhIHNvdXJjZS5cbiAgICAgKiBAcGFyYW0gc2hvdWxkVXBkYXRlIEEgZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGRhdGEgc291cmNlIHNob3VsZCBiZSB1cGRhdGVkIGFmdGVyIHRoZSBleHBhbmQuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgY29sbGFwc2VUdXBsZU1lbWJlcih0dXBsZUxvY2F0aW9uOiBzdHJpbmcsIHR1cGxlSW5kZXg6IG51bWJlciwgbWVtYmVySW5kZXg6IG51bWJlciwgc2hvdWxkVXBkYXRlPzogYm9vbGVhbik6IGJvb2xlYW4geyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IHdpdGggdGhlIGFwcGxpZWQgc29ydCBkaXJlY3Rpb25zIG9uIHRoZSBpZ1Bpdm90R3JpZCdzIGNvbHVtbnMuIFRoZSByZXR1cm5lZCBhcnJheSBjb250YWlucyBvYmplY3RzIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAqICAgICAgICAgICAgIG1lbWJlck5hbWVzOiBUaGUgbmFtZXMgb2YgdGhlIG1lbWJlcnMgaW4gdGhlIHR1cGxlLlxuICAgICAqICAgICAgICAgICAgIHR1cGxlSW5kZXg6IFRoZSBpbmRleCBvZiB0aGUgdHVwbGUgb24gdGhlIGNvbHVtbiBheGlzIGluIHRoZSBvcmlnaW5hbCB1bnNvcnRlZCByZXN1bHQuXG4gICAgICogICAgICAgICAgICAgc29ydERpcmVjdGlvbjogVGhlIGRpcmVjdGlvbiBvZiB0aGUgc29ydCAtIGFzY2VuZGluZyBvciBkZXNjZW5kaW5nLlxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcHVibGljIGFwcGxpZWRDb2x1bW5Tb3J0RGlyZWN0aW9ucygpOiBhbnlbXSB7IHJldHVybjsgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgd2l0aCB0aGUgYXBwbGllZCBsZXZlbCBzb3J0IGRpcmVjdGlvbiBpdGVtcywgd2hpY2ggd2VyZSB1c2VkIGZvciB0aGUgc29ydGluZyBvZiB0aGUgaGVhZGVyIGNlbGxzLiBUaGUgcmV0dXJuZWQgYXJyYXkgY29udGFpbnMgb2JqZWN0cyB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgKiAgICAgICAgICAgICBsZXZlbFVuaXF1ZU5hbWU6IFNwZWNpZmllcyB0aGUgdW5pcXVlIG5hbWUgb2YgdGhlIGxldmVsLCB3aGljaCB3YXMgc29ydGVkLlxuICAgICAqICAgICAgICAgICAgIHNvcnREaXJlY3Rpb246IFRoZSBkaXJlY3Rpb24gb2YgdGhlIGhlYWRlciBzb3J0IC0gYXNjZW5kaW5nIG9yIGRlc2NlbmRpbmcuXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBwdWJsaWMgYXBwbGllZExldmVsU29ydERpcmVjdGlvbnMoKTogYW55W10geyByZXR1cm47IH07XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95IGlzIHBhcnQgb2YgdGhlIGpRdWVyeSBVSSB3aWRnZXQgQVBJIGFuZCBkb2VzIHRoZSBmb2xsb3dpbmc6XG4gICAgICogICAgICAgICAgICAgMS4gUmVtb3ZlIGN1c3RvbSBDU1MgY2xhc3NlcyB0aGF0IHdlcmUgYWRkZWQuXG4gICAgICogICAgICAgICAgICAgMi4gVW53cmFwIGFueSB3cmFwcGluZyBlbGVtZW50cyBzdWNoIGFzIHNjcm9sbGluZyBkaXZzIGFuZCBvdGhlciBjb250YWluZXJzLlxuICAgICAqICAgICAgICAgICAgIDMuIFVuYmluZCBhbGwgZXZlbnRzIHRoYXQgd2VyZSBib3VuZC5cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHB1YmxpYyBkZXN0cm95KCk6IHZvaWQgeyByZXR1cm47IH07XG59XG4iXX0=